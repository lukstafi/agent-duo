#!/usr/bin/env bash
# agent-solo - Coordinate a coder/reviewer AI workflow in a single worktree
#
# Requires Bash 4.0+ (for associative arrays, regex matching, etc.)
# macOS users: install modern bash via Homebrew: brew install bash
#
# Usage: agent-solo <command> [options]
#
# Session Commands:
#   start <feature> [<feature2> ...] [options]  Start session(s)
#   run [options]        Run orchestrator loop with timeouts
#   stop                 Stop ttyd servers, keep worktree
#   restart [--auto-run] [--no-ttyd]  Restart session after system restart/crash
#   status               Show session state
#   confirm              Confirm clarify phase completion (proceed to work)
#   pr                   Create PR for coder's solution
#   cleanup [--full]     Remove session state (--full: also worktree/branch)
#   setup                Install agent-solo to PATH and skills
#
# Control Commands:
#   nudge <agent> [msg]  Send message to agent terminal (coder or reviewer)
#   interrupt <agent>    Interrupt agent (Esc)
#
# Agent Commands:
#   signal <agent> <status> [message]   Signal status change
#   peer-status                         Read peer's status
#   phase                               Read current phase

set -e

# Determine script location (resolves symlinks)
SCRIPT_PATH="${BASH_SOURCE[0]}"
while [ -L "$SCRIPT_PATH" ]; do
    SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
    SCRIPT_PATH="$(readlink "$SCRIPT_PATH")"
    [[ $SCRIPT_PATH != /* ]] && SCRIPT_PATH="$SCRIPT_DIR/$SCRIPT_PATH"
done
SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"

# Source shared library
if [ -f "$SCRIPT_DIR/agent-lib.sh" ]; then
    # shellcheck source=agent-lib.sh
    source "$SCRIPT_DIR/agent-lib.sh"
elif [ -f "$HOME/.local/bin/agent-lib.sh" ]; then
    # shellcheck source=agent-lib.sh
    source "$HOME/.local/bin/agent-lib.sh"
else
    echo "Error: agent-lib.sh not found" >&2
    exit 1
fi

# Default agents for solo mode (coder does implementation, reviewer reviews)
DEFAULT_CODER="claude"
DEFAULT_REVIEWER="codex"

# Session registry prefix for .agent-sessions/ namespace isolation
SESSION_REGISTRY_PREFIX="solo"

# Allocate ports for a solo session (3 ports: orchestrator, coder, reviewer)
# Args: peer_sync [base_port]
# If base_port is provided, uses consecutive ports starting from it (fails if any occupied)
# Otherwise, dynamically finds 3 consecutive available ports starting from DEFAULT_BASE_PORT
allocate_ports_solo() {
    local peer_sync="$1"
    local base_port="${2:-}"
    local ports_file="$peer_sync/ports"

    # If ports already allocated, return
    if [ -f "$ports_file" ]; then
        return 0
    fi

    local orchestrator_port coder_port reviewer_port

    if [ -n "$base_port" ]; then
        # User specified a port: use consecutive ports, fail if any occupied
        orchestrator_port="$base_port"
        coder_port=$((base_port + 1))
        reviewer_port=$((base_port + 2))

        if ! is_port_available "$orchestrator_port"; then
            die "Port $orchestrator_port (orchestrator) is already in use"
        fi
        if ! is_port_available "$coder_port"; then
            die "Port $coder_port (coder) is already in use"
        fi
        if ! is_port_available "$reviewer_port"; then
            die "Port $reviewer_port (reviewer) is already in use"
        fi
    else
        # Dynamic allocation: find 3 consecutive available ports
        orchestrator_port="$(find_consecutive_ports "$DEFAULT_BASE_PORT" 3)" || die "Could not find 3 consecutive available ports"
        coder_port=$((orchestrator_port + 1))
        reviewer_port=$((orchestrator_port + 2))
    fi

    cat > "$ports_file" << EOF
ORCHESTRATOR_PORT=$orchestrator_port
CODER_PORT=$coder_port
REVIEWER_PORT=$reviewer_port
EOF
}

#------------------------------------------------------------------------------
# Command: setup
#------------------------------------------------------------------------------

cmd_setup() {
    info "Installing agent-solo..."

    local templates_dir="$SCRIPT_DIR/skills/templates"

    if [ ! -d "$templates_dir" ]; then
        die "Skills templates not found at $templates_dir"
    fi

    # Install CLI to ~/.local/bin
    local install_dir="$HOME/.local/bin"
    mkdir -p "$install_dir"

    local install_path="$install_dir/agent-solo"
    if [ "$SCRIPT_DIR/agent-solo" != "$install_path" ]; then
        cp "$SCRIPT_DIR/agent-solo" "$install_path"
        chmod +x "$install_path"
        success "Installed agent-solo to $install_path"
    else
        success "agent-solo already installed at $install_path"
    fi

    # Install shared library
    local lib_path="$install_dir/agent-lib.sh"
    if [ -f "$SCRIPT_DIR/agent-lib.sh" ]; then
        cp "$SCRIPT_DIR/agent-lib.sh" "$lib_path"
        success "Installed agent-lib.sh to $lib_path"
    fi

    # Copy skills/templates to install dir so setup works from installed location
    local installed_templates="$install_dir/skills/templates"
    if [ "$templates_dir" != "$installed_templates" ]; then
        mkdir -p "$installed_templates"
        cp -r "$templates_dir"/* "$installed_templates/"
        success "Installed skill templates to $installed_templates"
    fi

    # Install shared helper scripts
    local shared_dir="$HOME/.local/share/agent-duo"
    mkdir -p "$shared_dir"
    local shared_templates="$templates_dir/shared"
    if [ -d "$shared_templates" ]; then
        cp "$shared_templates"/*.sh "$shared_dir/" 2>/dev/null || true
        chmod +x "$shared_dir"/*.sh 2>/dev/null || true
        success "Installed shared scripts to $shared_dir"
    fi

    # Check if ~/.local/bin is in PATH
    if [[ ":$PATH:" != *":$install_dir:"* ]]; then
        warn "Add $install_dir to your PATH:"
        echo "  export PATH=\"\$HOME/.local/bin:\$PATH\""
    fi

    # Skills are now installed per-session into worktrees, not globally
    # Check for and warn about legacy global skill installations
    warn_legacy_global_skills SOLO_SKILLS

    # Install unified notify hook script and configure agent hooks
    local notify_script
    notify_script="$(install_notify_hook "$install_dir")"
    success "Installed unified notify hook script to $notify_script"

    configure_codex_notify "$notify_script"
    configure_claude_notify "$notify_script"

    success "Setup complete!"
}

#------------------------------------------------------------------------------
# Command: start
#------------------------------------------------------------------------------

cmd_start() {
    local features=()
    local ttyd_mode=true
    local auto_run=false
    local gather_mode=false
    local clarify_mode=false
    local pushback_mode=false
    local plan_mode=false
    local work_timeout=$DEFAULT_WORK_TIMEOUT
    local review_timeout=$DEFAULT_REVIEW_TIMEOUT
    local gather_timeout=$DEFAULT_GATHER_TIMEOUT
    local clarify_timeout=$DEFAULT_CLARIFY_TIMEOUT
    local pushback_timeout=$DEFAULT_PUSHBACK_TIMEOUT
    local plan_timeout=$DEFAULT_PLAN_TIMEOUT
    local auto_finish=false
    local auto_finish_timeout=$DEFAULT_AUTO_FINISH_TIMEOUT
    local max_rounds=10
    local codex_thinking=$DEFAULT_CODEX_THINKING
    local coder=$DEFAULT_CODER
    local reviewer=$DEFAULT_REVIEWER
    local codex_model=""
    local claude_model=""
    local base_port=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --no-ttyd) ttyd_mode=false; shift ;;
            --auto-run) auto_run=true; shift ;;
            --gather) gather_mode=true; shift ;;
            --clarify) clarify_mode=true; shift ;;
            --pushback) pushback_mode=true; shift ;;
            --plan) plan_mode=true; shift ;;
            --auto-finish) auto_finish=true; shift ;;
            --auto-finish-timeout) auto_finish_timeout="$2"; shift 2 ;;
            --work-timeout) work_timeout="$2"; shift 2 ;;
            --review-timeout) review_timeout="$2"; shift 2 ;;
            --gather-timeout) gather_timeout="$2"; shift 2 ;;
            --clarify-timeout) clarify_timeout="$2"; shift 2 ;;
            --pushback-timeout) pushback_timeout="$2"; shift 2 ;;
            --plan-timeout) plan_timeout="$2"; shift 2 ;;
            --max-rounds) max_rounds="$2"; shift 2 ;;
            --codex-thinking) codex_thinking="$2"; shift 2 ;;
            --codex-model) codex_model="$2"; shift 2 ;;
            --claude-model) claude_model="$2"; shift 2 ;;
            --coder) coder="$2"; shift 2 ;;
            --reviewer) reviewer="$2"; shift 2 ;;
            --port) base_port="$2"; shift 2 ;;
            -*) die "Unknown option: $1" ;;
            *) features+=("$1"); shift ;;
        esac
    done

    # Export model overrides if specified (used by get_agent_cmd)
    [ -n "$codex_model" ] && export AGENT_DUO_CODEX_MODEL="$codex_model"
    [ -n "$claude_model" ] && export AGENT_DUO_CLAUDE_MODEL="$claude_model"

    [ ${#features[@]} -eq 0 ] && die "Usage: agent-solo start <feature> [feature2 ...] [--no-ttyd] [--auto-run] [--clarify] [--pushback] [--plan] [--coder <agent>] [--reviewer <agent>]"

    # Validate codex thinking effort
    case "$codex_thinking" in
        low|medium|high) ;;
        *) die "Invalid --codex-thinking value: $codex_thinking (valid: low, medium, high)" ;;
    esac

    # Ensure we're in a git repo
    git rev-parse --is-inside-work-tree >/dev/null 2>&1 || die "Not a git repository"

    # Ensure repo has at least one commit
    git rev-parse HEAD >/dev/null 2>&1 || die "Repository has no commits. Create an initial commit first."

    # Push current branch to avoid PRs incorporating unpushed commits
    info "Pushing current branch to remote..."
    git push || die "Failed to push current branch. Push manually and retry."

    local main_project_root
    main_project_root="$(get_main_project_root)"
    local project_name
    project_name="$(basename "$main_project_root")"

    # Multiple features: start each one
    if [ ${#features[@]} -gt 1 ]; then
        info "Starting ${#features[@]} parallel solo sessions..."
        local started=0 failed=0
        for feature in "${features[@]}"; do
            echo ""
            info "=== Starting session: $feature ==="
            if start_single_solo_session "$feature" "$main_project_root" "$project_name" \
                "$ttyd_mode" "$auto_run" "$gather_mode" "$clarify_mode" "$pushback_mode" "$plan_mode" \
                "$auto_finish" "$auto_finish_timeout" \
                "$work_timeout" "$review_timeout" "$gather_timeout" "$clarify_timeout" "$pushback_timeout" "$plan_timeout" \
                "$max_rounds" "$codex_thinking" "$coder" "$reviewer" "$base_port"; then
                started=$((started + 1))
            else
                failed=$((failed + 1))
            fi
        done
        echo ""
        echo "=== Summary ==="
        success "Started: $started"
        [ $failed -gt 0 ] && warn "Failed: $failed"
        if [ $started -gt 0 ]; then
            echo ""
            echo "View all sessions: agent-solo status"
        fi
        return 0
    fi

    # Single feature
    local feature="${features[0]}"
    start_single_solo_session "$feature" "$main_project_root" "$project_name" \
        "$ttyd_mode" "$auto_run" "$gather_mode" "$clarify_mode" "$pushback_mode" "$plan_mode" \
        "$auto_finish" "$auto_finish_timeout" \
        "$work_timeout" "$review_timeout" "$gather_timeout" "$clarify_timeout" "$pushback_timeout" "$plan_timeout" \
        "$max_rounds" "$codex_thinking" "$coder" "$reviewer" "$base_port"
}

# Start a single solo session for one feature
start_single_solo_session() {
    local feature="$1"
    local main_project_root="$2"
    local project_name="$3"
    local ttyd_mode="$4"
    local auto_run="$5"
    local gather_mode="$6"
    local clarify_mode="$7"
    local pushback_mode="$8"
    local plan_mode="$9"
    local auto_finish="${10}"
    local auto_finish_timeout="${11}"
    local work_timeout="${12}"
    local review_timeout="${13}"
    local gather_timeout="${14}"
    local clarify_timeout="${15}"
    local pushback_timeout="${16}"
    local plan_timeout="${17}"
    local max_rounds="${18}"
    local codex_thinking="${19}"
    local coder="${20}"
    local reviewer="${21}"
    local base_port="${22}"

    # Check for existing session for THIS feature
    local sessions_dir="$main_project_root/.agent-sessions"
    if [ -L "$sessions_dir/solo-${feature}.session" ]; then
        warn "Session already exists for feature '$feature'."
        warn "To continue: agent-solo run --feature $feature"
        warn "To start fresh: agent-solo cleanup --feature $feature && agent-solo start $feature"
        return 1
    fi

    # Check for task file in main project
    local task_file
    if task_file="$(find_task_file "$main_project_root" "$feature")"; then
        info "Found task file: $task_file"
    else
        warn "Task file not found: $feature.md"
        warn "Searched: $feature.md, doc/$feature.md, docs/$feature.md, **/$feature.md"
        warn "Create it with the task description, or the agents won't know what to do."
    fi

    info "Starting Agent Solo session: $feature"
    info "Project: $project_name"
    info "Coder: $coder, Reviewer: $reviewer"

    local parent_dir
    parent_dir="$(dirname "$main_project_root")"

    # Detect main branch
    cd "$main_project_root"
    local main_branch
    main_branch="$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@')" || true
    if [ -z "$main_branch" ]; then
        for candidate in main master; do
            if git rev-parse --verify "$candidate" >/dev/null 2>&1; then
                main_branch="$candidate"
                break
            fi
        done
    fi
    if [ -z "$main_branch" ]; then
        main_branch="$(git rev-parse --abbrev-ref HEAD)"
    fi

    # Create worktree (shared by coder and reviewer)
    local worktree="$parent_dir/${project_name}-${feature}"
    if [ ! -d "$worktree" ]; then
        info "Creating worktree..."
        git worktree add -b "${feature}" "$worktree" "$main_branch" 2>/dev/null || \
            git worktree add "$worktree" "${feature}"
    else
        warn "Worktree already exists: $worktree"
    fi

    # Initialize .peer-sync in the worktree (for multi-session support)
    local peer_sync="$worktree/.peer-sync"
    mkdir -p "$peer_sync/reviews"
    mkdir -p "$peer_sync/pids"

    echo "active" > "$peer_sync/session"
    echo "solo" > "$peer_sync/mode"
    echo "$coder" > "$peer_sync/coder-agent"
    echo "$reviewer" > "$peer_sync/reviewer-agent"
    # Determine initial phase: gather -> clarify -> pushback -> plan -> work
    if [ "$gather_mode" = "true" ]; then
        echo "gather" > "$peer_sync/phase"
        echo "waiting|$(date +%s)|waiting for reviewer to gather context" > "$peer_sync/coder.status"
        echo "gathering|$(date +%s)|starting" > "$peer_sync/reviewer.status"
    elif [ "$clarify_mode" = "true" ]; then
        echo "clarify" > "$peer_sync/phase"
        echo "clarifying|$(date +%s)|starting" > "$peer_sync/coder.status"
        echo "waiting|$(date +%s)|waiting for coder" > "$peer_sync/reviewer.status"
    elif [ "$pushback_mode" = "true" ]; then
        echo "pushback" > "$peer_sync/phase"
        echo "waiting|$(date +%s)|waiting for reviewer pushback" > "$peer_sync/coder.status"
        echo "pushing-back|$(date +%s)|starting" > "$peer_sync/reviewer.status"
    elif [ "$plan_mode" = "true" ]; then
        echo "plan" > "$peer_sync/phase"
        echo "planning|$(date +%s)|starting" > "$peer_sync/coder.status"
        echo "waiting|$(date +%s)|waiting for coder plan" > "$peer_sync/reviewer.status"
        echo "1" > "$peer_sync/plan-round"
    else
        echo "work" > "$peer_sync/phase"
        echo "working|$(date +%s)|starting" > "$peer_sync/coder.status"
        echo "waiting|$(date +%s)|waiting for coder" > "$peer_sync/reviewer.status"
    fi
    echo "$gather_mode" > "$peer_sync/gather-mode"
    echo "$clarify_mode" > "$peer_sync/clarify-mode"
    echo "$pushback_mode" > "$peer_sync/pushback-mode"
    echo "$plan_mode" > "$peer_sync/plan-mode"
    echo "$auto_finish" > "$peer_sync/auto-finish"
    echo "$auto_finish_timeout" > "$peer_sync/auto-finish-timeout"
    echo "1" > "$peer_sync/round"
    echo "$feature" > "$peer_sync/feature"
    echo "$codex_thinking" > "$peer_sync/codex-thinking"

    # Register session in main project's .agent-sessions directory
    mkdir -p "$sessions_dir"
    ln -sfn "$peer_sync" "$sessions_dir/solo-${feature}.session"

    # Ensure .peer-sync, .agent-sessions, .claude, and .agents are excluded from git
    local git_exclude="$main_project_root/.git/info/exclude"
    if [ -f "$git_exclude" ]; then
        grep -qxF ".peer-sync" "$git_exclude" || echo ".peer-sync" >> "$git_exclude"
        grep -qxF ".agent-sessions" "$git_exclude" || echo ".agent-sessions" >> "$git_exclude"
        grep -qxF ".claude" "$git_exclude" || echo ".claude" >> "$git_exclude"
        grep -qxF ".agents" "$git_exclude" || echo ".agents" >> "$git_exclude"
    else
        mkdir -p "$(dirname "$git_exclude")"
        printf '%s\n' ".peer-sync" ".agent-sessions" ".claude" ".agents" > "$git_exclude"
    fi

    # Install skills to worktree (per-session, not global)
    local templates_dir
    templates_dir="$(get_templates_dir)"
    install_solo_skills_to_worktree "$worktree" "$templates_dir"
    success "Installed skills to worktree"

    # Copy task file to worktree if it exists
    if [ -n "$task_file" ] && [ -f "$task_file" ]; then
        cp "$task_file" "$worktree/"
    fi

    # Save ttyd mode setting for restart command
    echo "$ttyd_mode" > "$peer_sync/ttyd-mode"

    if [ "$ttyd_mode" = "true" ]; then
        start_ttyd_mode_solo "$feature" "$worktree" "$worktree" "$peer_sync" \
            "$auto_run" "$work_timeout" "$review_timeout" "$max_rounds" "$codex_thinking" "$clarify_mode" "$clarify_timeout" "$coder" "$reviewer" "$pushback_mode" "$pushback_timeout" "$gather_mode" "$gather_timeout" "$plan_mode" "$plan_timeout"
    else
        start_tmux_mode_solo "$feature" "$worktree" "$worktree" "$peer_sync" "$codex_thinking" "$clarify_mode" "$coder" "$reviewer" "$pushback_mode" "$gather_mode" "$plan_mode"
    fi
}

start_tmux_mode_solo() {
    local feature="$1"
    local project_root="$2"
    local worktree="$3"
    local peer_sync="$4"
    local codex_thinking="${5:-$DEFAULT_CODEX_THINKING}"
    local clarify_mode="${6:-false}"
    local coder="${7:-$DEFAULT_CODER}"
    local reviewer="${8:-$DEFAULT_REVIEWER}"
    local pushback_mode="${9:-false}"
    local gather_mode="${10:-false}"
    local plan_mode="${11:-false}"

    local session_name="solo-${feature}"

    # Kill existing session if any
    tmux kill-session -t "$session_name" 2>/dev/null || true

    # Create new tmux session with orchestrator window
    tmux new-session -d -s "$session_name" -n "orchestrator" -c "$project_root"

    # Create coder window (in shared worktree)
    tmux new-window -t "$session_name" -n "coder" -c "$worktree"
    tmux send-keys -t "$session_name:coder" "export PEER_SYNC='$peer_sync'"
    tmux send-keys -t "$session_name:coder" C-m
    tmux send-keys -t "$session_name:coder" "export MY_NAME='coder'"
    tmux send-keys -t "$session_name:coder" C-m
    tmux send-keys -t "$session_name:coder" "export MY_ROLE='coder'"
    tmux send-keys -t "$session_name:coder" C-m
    tmux send-keys -t "$session_name:coder" "export PEER_NAME='reviewer'"
    tmux send-keys -t "$session_name:coder" C-m
    tmux send-keys -t "$session_name:coder" "export FEATURE='$feature'"
    tmux send-keys -t "$session_name:coder" C-m
    tmux send-keys -t "$session_name:coder" "export WORKTREE='$worktree'"
    tmux send-keys -t "$session_name:coder" C-m

    # Create reviewer window (in same shared worktree)
    tmux new-window -t "$session_name" -n "reviewer" -c "$worktree"
    tmux send-keys -t "$session_name:reviewer" "export PEER_SYNC='$peer_sync'"
    tmux send-keys -t "$session_name:reviewer" C-m
    tmux send-keys -t "$session_name:reviewer" "export MY_NAME='reviewer'"
    tmux send-keys -t "$session_name:reviewer" C-m
    tmux send-keys -t "$session_name:reviewer" "export MY_ROLE='reviewer'"
    tmux send-keys -t "$session_name:reviewer" C-m
    tmux send-keys -t "$session_name:reviewer" "export PEER_NAME='coder'"
    tmux send-keys -t "$session_name:reviewer" C-m
    tmux send-keys -t "$session_name:reviewer" "export FEATURE='$feature'"
    tmux send-keys -t "$session_name:reviewer" C-m
    tmux send-keys -t "$session_name:reviewer" "export WORKTREE='$worktree'"
    tmux send-keys -t "$session_name:reviewer" C-m

    success "Created tmux session: $session_name"
    echo ""
    echo "Windows:"
    echo "  0: orchestrator  - Main project root"
    echo "  1: coder         - $worktree (coder: $coder)"
    echo "  2: reviewer      - $worktree (reviewer: $reviewer)"
    echo ""
    echo "Attach with: tmux attach -t $session_name"
    echo ""
    echo "To start agents, in each window run their CLI:"
    echo "  coder window:    $(get_agent_cmd "$coder" "$codex_thinking")"
    echo "  reviewer window: $(get_agent_cmd "$reviewer" "$codex_thinking")"
    if [ "$gather_mode" = "true" ]; then
        echo ""
        echo "Gather stage enabled. The reviewer will first:"
        echo "  1. Collect context: links to relevant code and documentation with notes"
        echo "  2. Write context to .peer-sync/task-context.md for the coder to read"
    fi
    if [ "$clarify_mode" = "true" ]; then
        echo ""
        echo "Clarify stage enabled. After coder submits approach and reviewer comments:"
        echo "  1. Review in .peer-sync/clarify-coder.md and clarify-reviewer.md"
        echo "  2. Respond to agents in their terminals (back-and-forth OK)"
        echo "  3. Press Enter in the orchestrator to proceed"
    fi
    if [ "$pushback_mode" = "true" ]; then
        echo ""
        echo "Pushback stage enabled. After clarify (if enabled), the reviewer will:"
        echo "  1. Propose improvements to the task file"
        echo "  2. You can accept, reject, or modify the pushback"
    fi
    if [ "$plan_mode" = "true" ]; then
        echo ""
        echo "Plan stage enabled. After pushback (if enabled):"
        echo "  1. Coder writes an implementation plan"
        echo "  2. Reviewer evaluates it before work begins"
    fi
}

start_ttyd_mode_solo() {
    local feature="$1"
    local project_root="$2"
    local worktree="$3"
    local peer_sync="$4"
    local auto_run="${5:-false}"
    local work_timeout="${6:-$DEFAULT_WORK_TIMEOUT}"
    local review_timeout="${7:-$DEFAULT_REVIEW_TIMEOUT}"
    local max_rounds="${8:-10}"
    local codex_thinking="${9:-$DEFAULT_CODEX_THINKING}"
    local clarify_mode="${10:-false}"
    local clarify_timeout="${11:-$DEFAULT_CLARIFY_TIMEOUT}"
    local coder="${12:-$DEFAULT_CODER}"
    local reviewer="${13:-$DEFAULT_REVIEWER}"
    local pushback_mode="${14:-false}"
    local pushback_timeout="${15:-$DEFAULT_PUSHBACK_TIMEOUT}"
    local gather_mode="${16:-false}"
    local gather_timeout="${17:-$DEFAULT_GATHER_TIMEOUT}"
    local plan_mode="${18:-false}"
    local plan_timeout="${19:-$DEFAULT_PLAN_TIMEOUT}"

    local session_name="solo-${feature}"

    # Check ttyd is installed
    command -v ttyd >/dev/null 2>&1 || die "ttyd not found. Install with: brew install ttyd"

    # Kill existing sessions if any
    tmux kill-session -t "${session_name}-orchestrator" 2>/dev/null || true
    tmux kill-session -t "${session_name}-coder" 2>/dev/null || true
    tmux kill-session -t "${session_name}-reviewer" 2>/dev/null || true

    # Create tmux sessions for orchestrator and each agent (both in same worktree)
    tmux new-session -d -s "${session_name}-orchestrator" -c "$project_root"
    tmux new-session -d -s "${session_name}-coder" -c "$worktree"
    tmux new-session -d -s "${session_name}-reviewer" -c "$worktree"

    # Set environment variables for orchestrator
    for var in "PEER_SYNC='$peer_sync'" "FEATURE='$feature'"; do
        tmux send-keys -t "${session_name}-orchestrator" "export $var"
        tmux send-keys -t "${session_name}-orchestrator" C-m
    done

    # Set environment variables for coder
    for var in "PEER_SYNC='$peer_sync'" "MY_NAME='coder'" "MY_ROLE='coder'" "PEER_NAME='reviewer'" "FEATURE='$feature'" "WORKTREE='$worktree'"; do
        tmux send-keys -t "${session_name}-coder" "export $var"
        tmux send-keys -t "${session_name}-coder" C-m
    done

    # Set environment variables for reviewer
    for var in "PEER_SYNC='$peer_sync'" "MY_NAME='reviewer'" "MY_ROLE='reviewer'" "PEER_NAME='coder'" "FEATURE='$feature'" "WORKTREE='$worktree'"; do
        tmux send-keys -t "${session_name}-reviewer" "export $var"
        tmux send-keys -t "${session_name}-reviewer" C-m
    done

    # Allocate and load ports
    allocate_ports_solo "$peer_sync" "$base_port"
    get_ports "$peer_sync"
    local orchestrator_port=$ORCHESTRATOR_PORT
    local coder_port=$CODER_PORT
    local reviewer_port=$REVIEWER_PORT

    ttyd -p "$orchestrator_port" -t titleFixed="orchestrator: ${feature}" -W tmux attach -t "${session_name}-orchestrator" &
    echo $! > "$peer_sync/pids/ttyd-orchestrator.pid"

    ttyd -p "$coder_port" -t titleFixed="${coder}: ${feature}" -W tmux attach -t "${session_name}-coder" &
    echo $! > "$peer_sync/pids/ttyd-coder.pid"

    ttyd -p "$reviewer_port" -t titleFixed="${reviewer}: ${feature}" -W tmux attach -t "${session_name}-reviewer" &
    echo $! > "$peer_sync/pids/ttyd-reviewer.pid"

    success "Started ttyd servers"
    echo ""
    echo "Web terminals:"
    echo "  Orchestrator: http://localhost:$orchestrator_port"
    echo "  Coder ($coder):       http://localhost:$coder_port"
    echo "  Reviewer ($reviewer): http://localhost:$reviewer_port"
    echo ""

    # If auto-run, start the orchestrator loop in the orchestrator session
    if [ "$auto_run" = "true" ]; then
        info "Starting orchestrator with --auto-start..."
        local run_cmd="agent-solo run --auto-start --work-timeout $work_timeout --review-timeout $review_timeout --max-rounds $max_rounds"
        if [ "$gather_mode" = "true" ]; then
            run_cmd="$run_cmd --gather-timeout $gather_timeout"
        fi
        if [ "$clarify_mode" = "true" ]; then
            run_cmd="$run_cmd --clarify-timeout $clarify_timeout"
        fi
        if [ "$pushback_mode" = "true" ]; then
            run_cmd="$run_cmd --pushback-timeout $pushback_timeout"
        fi
        if [ "$plan_mode" = "true" ]; then
            run_cmd="$run_cmd --plan-timeout $plan_timeout"
        fi
        tmux send-keys -t "${session_name}-orchestrator" "$run_cmd"
        tmux send-keys -t "${session_name}-orchestrator" C-m
    else
        echo "Start orchestrator with: agent-solo run --auto-start"
    fi
    echo "Stop with: agent-solo stop"
    if [ "$gather_mode" = "true" ]; then
        echo ""
        echo "Gather stage enabled. The reviewer will first:"
        echo "  1. Collect context: links to relevant code and documentation with notes"
        echo "  2. Write context to .peer-sync/task-context.md for the coder to read"
    fi
    if [ "$clarify_mode" = "true" ]; then
        echo ""
        echo "Clarify stage enabled. Coder proposes approach, reviewer comments."
        echo "  1. Review in orchestrator or read .peer-sync/clarify-*.md"
        echo "  2. Respond to agents in their terminals (back-and-forth OK)"
        echo "  3. Press Enter in the orchestrator to proceed"
    fi
    if [ "$pushback_mode" = "true" ]; then
        echo ""
        echo "Pushback stage enabled. After clarify (if enabled), the reviewer will:"
        echo "  1. Propose improvements to the task file"
        echo "  2. You can accept, reject, or modify the pushback"
    fi
    if [ "$plan_mode" = "true" ]; then
        echo ""
        echo "Plan stage enabled. After pushback (if enabled):"
        echo "  1. Coder writes an implementation plan"
        echo "  2. Reviewer evaluates it before work begins"
    fi
}

#------------------------------------------------------------------------------
# Command: stop
#------------------------------------------------------------------------------

cmd_stop() {
    local feature_arg=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --feature) feature_arg="$2"; shift 2 ;;
            *) shift ;;
        esac
    done

    local main_root
    main_root="$(get_main_project_root 2>/dev/null)" || die "Not in a git repository"

    # If feature specified, stop just that one
    if [ -n "$feature_arg" ]; then
        local root_worktree
        root_worktree="$(get_session_root "$feature_arg" "$main_root")" || die "No session found for feature: $feature_arg"
        stop_single_solo_session "$feature_arg" "$root_worktree" "$root_worktree/.peer-sync"
        return
    fi

    # Try to resolve session from current directory
    if resolve_session 2>/dev/null; then
        stop_single_solo_session "$RESOLVED_FEATURE" "$RESOLVED_ROOT" "$RESOLVED_PEER_SYNC"
        return
    fi

    # In main project - stop all sessions from registry
    local sessions
    sessions="$(list_active_sessions "$main_root")"

    if [ -z "$sessions" ]; then
        die "No active sessions found."
    fi

    info "Stopping all sessions..."

    while IFS=: read -r feat root state; do
        [ -z "$feat" ] && continue
        echo ""
        info "=== Stopping: $feat ==="
        stop_single_solo_session "$feat" "$root" "$root/.peer-sync"
    done <<< "$sessions"

    success "All sessions stopped"
}

# Stop a single solo session
stop_single_solo_session() {
    local feature="$1"
    local root="$2"
    local peer_sync="$3"

    info "Stopping Agent Solo session: $feature"

    # Kill ttyd processes from PID files
    if [ -d "$peer_sync/pids" ]; then
        for pidfile in "$peer_sync/pids"/*.pid; do
            [ -f "$pidfile" ] || continue
            local pid
            pid="$(cat "$pidfile")"
            if kill -0 "$pid" 2>/dev/null; then
                kill "$pid" 2>/dev/null || true
                info "Killed process $pid ($(basename "$pidfile" .pid))"
            fi
            rm -f "$pidfile"
        done
    fi

    # Kill tmux sessions for this feature
    pkill -f "ttyd.*solo-${feature}-" 2>/dev/null && info "Killed remaining ttyd processes for solo-${feature}" || true
    tmux kill-session -t "solo-${feature}" 2>/dev/null && info "Killed tmux session: solo-${feature}" || true
    tmux kill-session -t "solo-${feature}-orchestrator" 2>/dev/null && info "Killed tmux session: solo-${feature}-orchestrator" || true
    tmux kill-session -t "solo-${feature}-coder" 2>/dev/null && info "Killed tmux session: solo-${feature}-coder" || true
    tmux kill-session -t "solo-${feature}-reviewer" 2>/dev/null && info "Killed tmux session: solo-${feature}-reviewer" || true

    success "Stopped: $feature"
}

#------------------------------------------------------------------------------
# Command: restart
#------------------------------------------------------------------------------

cmd_restart() {
    local auto_run=false
    local work_timeout=$DEFAULT_WORK_TIMEOUT
    local review_timeout=$DEFAULT_REVIEW_TIMEOUT
    local clarify_timeout=$DEFAULT_CLARIFY_TIMEOUT
    local pushback_timeout=$DEFAULT_PUSHBACK_TIMEOUT
    local max_rounds=10
    local feature_arg=""
    local ttyd_mode_override=""  # Empty means use recorded setting
    local auto_finish=""         # Empty means use session default
    local auto_finish_timeout="" # Empty means use session default

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --auto-run) auto_run=true; shift ;;
            --no-ttyd) ttyd_mode_override="false"; shift ;;
            --work-timeout) work_timeout="$2"; shift 2 ;;
            --review-timeout) review_timeout="$2"; shift 2 ;;
            --clarify-timeout) clarify_timeout="$2"; shift 2 ;;
            --pushback-timeout) pushback_timeout="$2"; shift 2 ;;
            --max-rounds) max_rounds="$2"; shift 2 ;;
            --feature) feature_arg="$2"; shift 2 ;;
            --auto-finish) auto_finish="true"; shift ;;
            --auto-finish-timeout) auto_finish_timeout="$2"; shift 2 ;;
            -*) die "Unknown option: $1" ;;
            *) die "Unknown argument: $1" ;;
        esac
    done

    # Resolve session
    if [ -n "$feature_arg" ]; then
        resolve_session --feature "$feature_arg"
    else
        if ! resolve_session 2>/dev/null; then
            # Check if we're in main project with multiple sessions
            local main_root
            main_root="$(get_main_project_root)"
            local sessions
            sessions="$(list_active_sessions "$main_root")"
            if [ -n "$sessions" ]; then
                # Restart all sessions
                local session_count=0
                local features=()
                while IFS=: read -r feat root state; do
                    features+=("$feat")
                    session_count=$((session_count + 1))
                done <<< "$sessions"

                info "Restarting $session_count sessions..."
                local failed=0
                for feat in "${features[@]}"; do
                    echo ""
                    info "=== Restarting session: $feat ==="
                    # Build command with all the options
                    local cmd_args=(--feature "$feat")
                    cmd_args+=(--work-timeout "$work_timeout")
                    cmd_args+=(--review-timeout "$review_timeout")
                    cmd_args+=(--clarify-timeout "$clarify_timeout")
                    cmd_args+=(--pushback-timeout "$pushback_timeout")
                    cmd_args+=(--max-rounds "$max_rounds")
                    [ "$auto_run" = true ] && cmd_args+=(--auto-run)
                    [ "$ttyd_mode_override" = "false" ] && cmd_args+=(--no-ttyd)
                    [ -n "$auto_finish" ] && cmd_args+=(--auto-finish)
                    [ -n "$auto_finish_timeout" ] && cmd_args+=(--auto-finish-timeout "$auto_finish_timeout")

                    if ! "$0" restart "${cmd_args[@]}"; then
                        failed=$((failed + 1))
                    fi
                done

                echo ""
                if [ $failed -eq 0 ]; then
                    success "All $session_count sessions restarted"
                else
                    warn "$failed of $session_count sessions failed"
                fi
                return $failed
            fi
            die "No active session found. Use --feature <name> or cd to a session worktree."
        fi
    fi

    local root="$RESOLVED_ROOT"
    local peer_sync="$RESOLVED_PEER_SYNC"

    # Check we have an active session
    [ -f "$peer_sync/feature" ] || die "No active session (missing .peer-sync/feature)"

    # Check ttyd mode (default to true for backward compatibility with old sessions)
    # Command-line override takes precedence over recorded setting
    local ttyd_mode="true"
    if [ -n "$ttyd_mode_override" ]; then
        ttyd_mode="$ttyd_mode_override"
    elif [ -f "$peer_sync/ttyd-mode" ]; then
        ttyd_mode="$(cat "$peer_sync/ttyd-mode")"
    fi

    # For ttyd mode, we need ports
    if [ "$ttyd_mode" = "true" ]; then
        [ -f "$peer_sync/ports" ] || die "No port allocations found. Was this a ttyd session?"
    fi

    local feature="$RESOLVED_FEATURE"
    local project_name
    project_name="$(basename "$root")"

    # In agent-solo, the root worktree IS the shared worktree (contains .peer-sync/)
    local worktree="$root"
    local session_name="solo-${feature}"

    # Load ports (only for ttyd mode)
    local orchestrator_port="" coder_port="" reviewer_port=""
    if [ "$ttyd_mode" = "true" ]; then
        get_ports "$peer_sync"
        orchestrator_port=$ORCHESTRATOR_PORT
        coder_port=$CODER_PORT
        reviewer_port=$REVIEWER_PORT
    fi

    # Load agent assignments
    local coder_agent reviewer_agent
    coder_agent="$(cat "$peer_sync/coder-agent" 2>/dev/null)" || coder_agent="$DEFAULT_CODER"
    reviewer_agent="$(cat "$peer_sync/reviewer-agent" 2>/dev/null)" || reviewer_agent="$DEFAULT_REVIEWER"

    # Load codex thinking effort
    local codex_thinking
    codex_thinking="$(cat "$peer_sync/codex-thinking" 2>/dev/null)" || codex_thinking="$DEFAULT_CODEX_THINKING"

    echo ""
    echo "=== Agent Solo Restart ==="
    echo ""
    echo "Feature:  $feature"
    echo "Project:  $project_name"
    echo "Coder:    $coder_agent"
    echo "Reviewer: $reviewer_agent"
    echo "Mode:     $([ "$ttyd_mode" = "true" ] && echo "ttyd (web terminals)" || echo "tmux (single session)")"
    echo ""

    # Ensure pids directory exists (only needed for ttyd mode, but harmless otherwise)
    mkdir -p "$peer_sync/pids"

    local errors=0
    local restarted=0

    #---------------------------------------------------------------------------
    # Phase 1: Check and restart tmux sessions
    #---------------------------------------------------------------------------
    info "Checking tmux sessions..."

    # Tmux target names depend on mode
    local orchestrator_target coder_target reviewer_target
    if [ "$ttyd_mode" = "true" ]; then
        # ttyd mode: separate sessions
        orchestrator_target="${session_name}-orchestrator"
        coder_target="${session_name}-coder"
        reviewer_target="${session_name}-reviewer"

        # Check orchestrator tmux session
        if ! tmux_session_exists "$orchestrator_target"; then
            info "Creating tmux session: $orchestrator_target"
            tmux new-session -d -s "$orchestrator_target" -c "$root"
            for var in "PEER_SYNC='$peer_sync'" "FEATURE='$feature'"; do
                tmux send-keys -t "$orchestrator_target" "export $var"
                tmux send-keys -t "$orchestrator_target" C-m
            done
            restarted=$((restarted + 1))
        else
            success "  orchestrator tmux session: OK"
        fi

        # Check coder tmux session
        if ! tmux_session_exists "$coder_target"; then
            if [ ! -d "$worktree" ]; then
                warn "  worktree missing: $worktree"
                errors=$((errors + 1))
            else
                info "Creating tmux session: $coder_target"
                tmux new-session -d -s "$coder_target" -c "$worktree"
                for var in "PEER_SYNC='$peer_sync'" "MY_NAME='coder'" "MY_ROLE='coder'" "PEER_NAME='reviewer'" "FEATURE='$feature'" "WORKTREE='$worktree'"; do
                    tmux send-keys -t "$coder_target" "export $var"
                    tmux send-keys -t "$coder_target" C-m
                done
                restarted=$((restarted + 1))
            fi
        else
            success "  coder tmux session: OK"
        fi

        # Check reviewer tmux session
        if ! tmux_session_exists "$reviewer_target"; then
            if [ ! -d "$worktree" ]; then
                warn "  worktree missing: $worktree"
                errors=$((errors + 1))
            else
                info "Creating tmux session: $reviewer_target"
                tmux new-session -d -s "$reviewer_target" -c "$worktree"
                for var in "PEER_SYNC='$peer_sync'" "MY_NAME='reviewer'" "MY_ROLE='reviewer'" "PEER_NAME='coder'" "FEATURE='$feature'" "WORKTREE='$worktree'"; do
                    tmux send-keys -t "$reviewer_target" "export $var"
                    tmux send-keys -t "$reviewer_target" C-m
                done
                restarted=$((restarted + 1))
            fi
        else
            success "  reviewer tmux session: OK"
        fi
    else
        # no-ttyd mode: single session with windows
        orchestrator_target="${session_name}:orchestrator"
        coder_target="${session_name}:coder"
        reviewer_target="${session_name}:reviewer"

        if ! tmux_session_exists "$session_name"; then
            info "Creating tmux session: $session_name"
            # Create session with orchestrator window
            tmux new-session -d -s "$session_name" -n "orchestrator" -c "$root"

            if [ -d "$worktree" ]; then
                # Create coder window
                tmux new-window -t "$session_name" -n "coder" -c "$worktree"
                for var in "PEER_SYNC='$peer_sync'" "MY_NAME='coder'" "MY_ROLE='coder'" "PEER_NAME='reviewer'" "FEATURE='$feature'" "WORKTREE='$worktree'"; do
                    tmux send-keys -t "$coder_target" "export $var"
                    tmux send-keys -t "$coder_target" C-m
                done

                # Create reviewer window
                tmux new-window -t "$session_name" -n "reviewer" -c "$worktree"
                for var in "PEER_SYNC='$peer_sync'" "MY_NAME='reviewer'" "MY_ROLE='reviewer'" "PEER_NAME='coder'" "FEATURE='$feature'" "WORKTREE='$worktree'"; do
                    tmux send-keys -t "$reviewer_target" "export $var"
                    tmux send-keys -t "$reviewer_target" C-m
                done
            else
                warn "  worktree missing: $worktree"
                errors=$((errors + 1))
            fi

            restarted=$((restarted + 1))
        else
            success "  tmux session $session_name: OK"
        fi
    fi

    #---------------------------------------------------------------------------
    # Phase 2: Check and restart ttyd servers (only for ttyd mode)
    #---------------------------------------------------------------------------
    if [ "$ttyd_mode" = "true" ]; then
        echo ""
        info "Checking ttyd servers..."

        # Check orchestrator ttyd
        if ! restart_ttyd_for_session "orchestrator" "$orchestrator_port" \
                "$orchestrator_target" "$peer_sync/pids/ttyd-orchestrator.pid"; then
            errors=$((errors + 1))
        fi

        # Check coder ttyd
        if ! restart_ttyd_for_session "coder" "$coder_port" \
                "$coder_target" "$peer_sync/pids/ttyd-coder.pid"; then
            errors=$((errors + 1))
        fi

        # Check reviewer ttyd
        if ! restart_ttyd_for_session "reviewer" "$reviewer_port" \
                "$reviewer_target" "$peer_sync/pids/ttyd-reviewer.pid"; then
            errors=$((errors + 1))
        fi
    fi

    #---------------------------------------------------------------------------
    # Phase 3: Check and restart agent TUIs
    #---------------------------------------------------------------------------
    echo ""
    info "Checking agent TUIs..."

    # Determine thinking effort for each agent
    local coder_thinking="" reviewer_thinking=""
    [ "$coder_agent" = "codex" ] && coder_thinking="$codex_thinking"
    [ "$reviewer_agent" = "codex" ] && reviewer_thinking="$codex_thinking"

    # Check coder TUI
    if ! restart_agent_tui "$coder_agent" "$coder_target" "$coder_thinking" "coder ($coder_agent)"; then
        errors=$((errors + 1))
    fi

    # Check reviewer TUI
    if ! restart_agent_tui "$reviewer_agent" "$reviewer_target" "$reviewer_thinking" "reviewer ($reviewer_agent)"; then
        errors=$((errors + 1))
    fi

    #---------------------------------------------------------------------------
    # Phase 4: Check orchestration state and optionally restart orchestrator
    #---------------------------------------------------------------------------
    echo ""
    info "Checking orchestration state..."

    local session_state
    session_state="$(cat "$peer_sync/session" 2>/dev/null)" || session_state="unknown"
    local phase
    phase="$(cat "$peer_sync/phase" 2>/dev/null)" || phase="unknown"
    local round
    round="$(cat "$peer_sync/round" 2>/dev/null)" || round="1"

    echo "  Session: $session_state"
    echo "  Phase:   $phase"
    echo "  Round:   $round"

    # Check if PR has been created (terminal state for solo mode)
    local has_pr=false
    [ -f "$peer_sync/coder.pr" ] && has_pr=true

    if [ "$session_state" = "complete" ] || $has_pr; then
        echo ""
        if [ -f "$peer_sync/coder.pr" ]; then
            echo "  PR: $(cat "$peer_sync/coder.pr")"
        fi
        if [ "$auto_run" = "true" ]; then
            info "PR created. Transitioning to pr-comments phase for monitoring..."
            echo "pr-comments" > "$peer_sync/phase"
            echo "active" > "$peer_sync/session"
            local run_cmd="agent-solo run --auto-start --work-timeout $work_timeout --review-timeout $review_timeout --max-rounds $max_rounds"
            run_cmd="$run_cmd --clarify-timeout $clarify_timeout --pushback-timeout $pushback_timeout"
            [ -n "$auto_finish" ] && run_cmd+=" --auto-finish"
            [ -n "$auto_finish_timeout" ] && run_cmd+=" --auto-finish-timeout $auto_finish_timeout"
            tmux send-keys -t "$orchestrator_target" "$run_cmd"
            tmux send-keys -t "$orchestrator_target" C-m
            success "Started PR comment monitoring"
        else
            info "PR created. To monitor for PR comments:"
            echo "  agent-solo restart --auto-run"
        fi
    elif [ "$auto_run" = "true" ]; then
        echo ""
        info "Restarting orchestrator loop..."

        # Determine if orchestrator is already running
        local orchestrator_running=false
        if agent_tui_is_running "$orchestrator_target" "orchestrator"; then
            orchestrator_running=true
        fi

        if ! $orchestrator_running; then
            local run_cmd="agent-solo run --auto-start --work-timeout $work_timeout --review-timeout $review_timeout --max-rounds $max_rounds"
            run_cmd="$run_cmd --clarify-timeout $clarify_timeout --pushback-timeout $pushback_timeout"
            [ -n "$auto_finish" ] && run_cmd+=" --auto-finish"
            [ -n "$auto_finish_timeout" ] && run_cmd+=" --auto-finish-timeout $auto_finish_timeout"
            tmux send-keys -t "$orchestrator_target" "$run_cmd"
            tmux send-keys -t "$orchestrator_target" C-m
            success "Started orchestrator loop"
        else
            info "Orchestrator appears to already be running"
        fi
    else
        echo ""
        info "Session is not complete. To restart the orchestrator loop:"
        echo "  agent-solo restart --auto-run"
        echo "Or manually in the orchestrator terminal:"
        echo "  agent-solo run --auto-start"
    fi

    #---------------------------------------------------------------------------
    # Summary
    #---------------------------------------------------------------------------
    echo ""
    if [ "$ttyd_mode" = "true" ]; then
        echo "--- Web Terminals ---"
        echo "Orchestrator: http://localhost:$orchestrator_port"
        echo "Coder ($coder_agent):       http://localhost:$coder_port"
        echo "Reviewer ($reviewer_agent): http://localhost:$reviewer_port"
    else
        echo "--- tmux Session ---"
        echo "Attach with: tmux attach -t $session_name"
        echo "Windows: orchestrator, coder, reviewer"
    fi
    echo ""

    if [ "$errors" -gt 0 ]; then
        warn "Restart completed with $errors error(s)"
        return 1
    else
        success "Restart complete!"
        return 0
    fi
}

#------------------------------------------------------------------------------
# Command: status
#------------------------------------------------------------------------------

cmd_status() {
    local feature_arg=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --feature) feature_arg="$2"; shift 2 ;;
            *) shift ;;
        esac
    done

    # Try to resolve session
    if [ -n "$feature_arg" ]; then
        resolve_session --feature "$feature_arg"
        show_single_solo_status "$RESOLVED_PEER_SYNC"
    elif resolve_session 2>/dev/null; then
        show_single_solo_status "$RESOLVED_PEER_SYNC"
    else
        local main_root
        main_root="$(get_main_project_root 2>/dev/null)" || die "Not in a git repository"

        # Show all sessions from registry
        local sessions
        sessions="$(list_active_sessions "$main_root")"

        if [ -z "$sessions" ]; then
            die "No active sessions found. Start one with: agent-solo start <feature>"
        fi

        echo ""
        echo "=== All Agent Solo Sessions ==="

        while IFS=: read -r feat root state; do
            [ -z "$feat" ] && continue
            echo ""
            echo "━━━ Feature: $feat ($state) ━━━"
            show_single_solo_status "$root/.peer-sync"
        done <<< "$sessions"
    fi
}

# Show status for a single solo session
show_single_solo_status() {
    local peer_sync="$1"

    echo ""
    echo "=== Agent Solo Status ==="
    echo ""

    if [ -f "$peer_sync/feature" ]; then
        echo "Feature:  $(cat "$peer_sync/feature")"
    fi

    if [ -f "$peer_sync/session" ]; then
        echo "Session:  $(cat "$peer_sync/session")"
    fi

    if [ -f "$peer_sync/phase" ]; then
        echo "Phase:    $(cat "$peer_sync/phase")"
    fi

    if [ -f "$peer_sync/round" ]; then
        echo "Round:    $(cat "$peer_sync/round")"
    fi

    # Show coder/reviewer assignments
    if [ -f "$peer_sync/coder-agent" ]; then
        echo "Coder:    $(cat "$peer_sync/coder-agent")"
    fi
    if [ -f "$peer_sync/reviewer-agent" ]; then
        echo "Reviewer: $(cat "$peer_sync/reviewer-agent")"
    fi

    # Show allocated ports if available
    if [ -f "$peer_sync/ports" ]; then
        # shellcheck source=/dev/null
        source "$peer_sync/ports"
        echo ""
        echo "--- Web Terminals ---"
        echo "Orchestrator: http://localhost:$ORCHESTRATOR_PORT"
        echo "Coder:        http://localhost:$CODER_PORT"
        echo "Reviewer:     http://localhost:$REVIEWER_PORT"
    fi

    echo ""
    echo "--- Agent Status ---"

    for agent in coder reviewer; do
        local status_file="$peer_sync/${agent}.status"
        if [ -f "$status_file" ]; then
            local line
            line="$(cat "$status_file")"
            local status msg timestamp
            status="$(echo "$line" | cut -d'|' -f1)"
            timestamp="$(echo "$line" | cut -d'|' -f2)"
            msg="$(echo "$line" | cut -d'|' -f3-)"

            local time_str=""
            if [ -n "$timestamp" ] && [ "$timestamp" != "$status" ]; then
                time_str=" ($(date -r "$timestamp" '+%H:%M:%S' 2>/dev/null || echo "$timestamp"))"
            fi

            printf "%-10s: %s%s" "$agent" "$status" "$time_str"
            [ -n "$msg" ] && [ "$msg" != "$status" ] && printf " - %s" "$msg"
            echo ""
        else
            echo "$agent:     (no status)"
        fi
    done

    # Check for PR
    echo ""
    echo "--- Pull Request ---"
    if [ -f "$peer_sync/coder.pr" ]; then
        echo "PR: $(cat "$peer_sync/coder.pr")"
    else
        echo "PR: (none)"
    fi

    # List reviews
    if [ -d "$peer_sync/reviews" ] && [ "$(ls -A "$peer_sync/reviews" 2>/dev/null)" ]; then
        echo ""
        echo "--- Reviews ---"
        ls -1 "$peer_sync/reviews"
    fi

    echo ""
}

#------------------------------------------------------------------------------
# Command: run (orchestrator)
#------------------------------------------------------------------------------

# Generate clarify message for coder
generate_coder_clarify_message() {
    local feature="$1"
    local task_content="$2"
    local peer_sync="$3"

    cat <<EOF
# Task: $feature

$task_content

---
## Agent-Solo Context - CLARIFY PHASE (Coder)

You are the **CODER** in a solo workflow. A reviewer will review your code.

**PHASE: CLARIFY** - Before starting implementation, propose your high-level approach and ask clarifying questions.

### Your Task

Produce TWO outputs:

1. **High-level approach** - Not a detailed plan, but a sketch: the key idea, first steps to explore, or general direction
2. **Clarifying questions** - Questions for the user that would help you start more effectively

### Write Your Approach and Questions

\`\`\`bash
cat > "$peer_sync/clarify-coder.md" << 'CLARIFY_EOF'
# Coder's Proposed Approach

## High-Level Approach

[Write 3-5 sentences describing your high-level approach.]

## Questions for the User

1. [Question 1]
2. [Question 2]
3. [Question 3 - optional]

CLARIFY_EOF
\`\`\`

Edit the file with actual content, then signal completion:

\`\`\`bash
agent-solo signal coder clarify-done "approach and questions submitted"
\`\`\`

Then **STOP and wait**. The reviewer will also provide comments, then the user will respond.
Do NOT start implementing until the work phase begins.
EOF
}

# Generate clarify message for reviewer (reviews coder's approach)
generate_reviewer_clarify_message() {
    local feature="$1"
    local task_content="$2"
    local peer_sync="$3"

    cat <<EOF
# Task: $feature

$task_content

---
## Agent-Solo Context - CLARIFY PHASE (Reviewer)

You are the **REVIEWER** in a solo workflow. The coder has proposed an approach.

**PHASE: CLARIFY** - Review the coder's proposed approach and add your own questions or comments.

### Your Task

1. **Read the coder's proposed approach**:
   \`\`\`bash
   cat "$peer_sync/clarify-coder.md"
   \`\`\`

2. **Write your comments and additional questions**:
   \`\`\`bash
   cat > "$peer_sync/clarify-reviewer.md" << 'CLARIFY_EOF'
# Reviewer's Comments

## Comments on Coder's Approach

[What do you think of the proposed approach? Any concerns or suggestions?]

## Additional Questions

1. [Any additional questions you have for the user?]

CLARIFY_EOF
   \`\`\`

Edit the file with actual content, then signal completion:

\`\`\`bash
agent-solo signal reviewer clarify-done "comments submitted"
\`\`\`

Then **STOP and wait**. The user will review both and respond.
EOF
}

# Generate work message for coder (round 1)
generate_coder_work_message() {
    local feature="$1"
    local task_content="$2"
    local peer_sync="$3"
    local round="$4"

    cat <<EOF
# Task: $feature

$task_content

---
## Agent-Solo Context - WORK PHASE (Coder)

You are the **CODER** in a solo workflow. A reviewer will review your code.

- **Phase**: Work (Round $round)
- **Worktree**: Current directory (read/write)
- **Sync directory**: $peer_sync

### Your Goal

Implement the solution. The reviewer will examine your work after you signal done.

### Guidelines

1. Implement your solution following best practices
2. Make sure the code works (run tests if available)
3. If round > 1, check the reviewer's feedback from the previous round:
   \`\`\`bash
   cat "$peer_sync/reviews/round-$((round - 1))-review.md" 2>/dev/null
   \`\`\`

### If You Discover a Blocking Issue

If you find ambiguity, inconsistency, or evidence the task is misguided — escalate:
\`\`\`bash
agent-solo escalate ambiguity "requirements unclear: what should happen when X?"
agent-solo escalate inconsistency "docs say X but code does Y"
agent-solo escalate misguided "this feature already exists in module Z"
\`\`\`
This notifies the user without interrupting your work. Continue with your best interpretation.

### When Done

Signal completion and **STOP**:
\`\`\`bash
agent-solo signal coder done "brief summary of what you did"
\`\`\`

The reviewer will then examine your work.

### When Ready for Final PR

When the reviewer approves your solution:
\`\`\`bash
agent-solo pr   # handles commit, push, and PR creation
\`\`\`
EOF
}

# Generate pushback message for reviewer (only reviewer pushes back in solo mode)
generate_solo_pushback_message() {
    local feature="$1"
    local task_content="$2"
    local peer_sync="$3"

    cat <<EOF
# Task: $feature

$task_content

---
## Agent-Solo Context - PUSHBACK STAGE (Reviewer)

You are the **REVIEWER** in a solo workflow. Before the coder starts implementing, you may propose improvements to the task specification.

- **Sync directory**: $peer_sync

### Purpose

The task file may specify both a goal and a plan. Sometimes the plan is suboptimal or could be improved. This is your opportunity to suggest modifications that would lead to a better solution.

### Your Task

Consider:
1. Is the stated plan the best approach to achieve the core goal?
2. Are there better alternatives or optimizations?
3. Are there missing requirements or edge cases?

### Modify the Task File Directly

If you believe the task could be improved, edit \`$feature.md\` directly. The user will compare your version with the original using diff.

If the task is well-specified and needs no changes, skip to writing your rationale.

### Write Your Rationale

\`\`\`bash
cat > "$peer_sync/pushback-reviewer.md" << 'PUSHBACK_EOF'
# Pushback from Reviewer

## Summary of Proposed Changes

[1-3 sentences explaining what you changed and why, or "No changes proposed - the task is well-specified."]

## Reasoning

[Explain why your changes would improve the solution quality, or why the original is already good]

PUSHBACK_EOF
\`\`\`

Edit the file with actual content, then signal completion:

\`\`\`bash
agent-solo signal reviewer pushback-done "proposed task modifications submitted"
\`\`\`

Then **STOP and wait**. The user will review task file changes (via diff) and your rationale, then decide whether to accept or reject.
Do NOT provide implementation guidance yet - wait for the work phase.
EOF
}

# Generate gather message for reviewer (reviewer gathers context before coder starts)
generate_reviewer_gather_message() {
    local feature="$1"
    local task_content="$2"
    local peer_sync="$3"

    cat <<EOF
# Task: $feature

$task_content

---
## Agent-Solo Context - GATHER PHASE (Reviewer)

You are the **REVIEWER** in a solo workflow. Before the coder starts implementing, you will gather relevant context from the codebase to help them.

- **Sync directory**: $peer_sync

### Purpose

The coder will benefit from knowing which files and code sections are relevant to this task. Your job is to explore the codebase and document:
1. **Relevant source files** - code that will need to be modified or understood
2. **Documentation** - existing docs that explain the relevant systems
3. **Tests** - existing tests that demonstrate expected behavior
4. **Dependencies** - related code that the implementation must integrate with

### Your Task

1. **Explore the codebase** to find relevant files and code sections
2. **Document your findings** with file paths, line numbers, and brief notes explaining why each is relevant

### Write the Task Context

Create a context file that the coder will read before starting work:

\`\`\`bash
cat > "$peer_sync/task-context.md" << 'CONTEXT_EOF'
# Task Context for $feature

## Relevant Source Files

- [path/to/file.ext:line-range](path/to/file.ext) - Brief note on why this is relevant
- [path/to/another.ext:42-60](path/to/another.ext) - What this code does and why it matters

## Documentation

- [docs/relevant.md](docs/relevant.md) - Description of relevant documentation

## Tests

- [tests/relevant_test.ext](tests/relevant_test.ext) - Tests that demonstrate expected behavior

## Key Dependencies

- [path/to/dependency.ext](path/to/dependency.ext) - How this relates to the task

## Notes

[Any additional context, gotchas, or suggestions for the coder]

CONTEXT_EOF
\`\`\`

Edit the file with actual content based on your exploration. Use specific file:line references.

### Signal Completion

\`\`\`bash
agent-solo signal reviewer gather-done "task context collected"
\`\`\`

Then **STOP and wait**. The coder will read your context file before starting work.
Do NOT start implementing - that's the coder's job in the work phase.
EOF
}

#------------------------------------------------------------------------------
# Trigger final merge for PR (auto-finish mode)
# Usage: trigger_solo_final_merge <coder> <session> <peer_sync> <tui_exit_behavior>
#------------------------------------------------------------------------------
trigger_solo_final_merge() {
    local coder="$1"
    local session="$2"
    local peer_sync="$3"
    local tui_exit_behavior="${4:-$DEFAULT_TUI_EXIT_BEHAVIOR}"

    local pr_url
    pr_url="$(cat "$peer_sync/coder.pr")"

    echo "final-merge" > "$peer_sync/phase"
    check_tui_health "$coder" "$session" "$peer_sync" "$tui_exit_behavior"
    atomic_write "$peer_sync/coder.status" "working|$(date +%s)|performing final merge"

    info "Triggering solo-final-merge for coder..."
    send_to_agent "coder" "$session" "$peer_sync" skill "solo-final-merge"

    # Wait for completion
    local merge_start=$SECONDS
    local merge_timeout=600  # 10 minutes

    while true; do
        local elapsed=$((SECONDS - merge_start))
        local status
        status="$(get_agent_status "coder" "$peer_sync")"

        if [[ "$status" =~ ^(final-merge-done|done)$ ]]; then
            success "Final merge completed"
            break
        fi

        # Check for API errors and retry
        check_and_retry_on_error "coder" "$session" "$peer_sync"

        if [ "$elapsed" -ge "$merge_timeout" ]; then
            warn "Final merge timeout (${merge_timeout}s)"
            break
        fi

        printf "\r  Waiting for final merge... coder=%s (%ds)  " "$status" "$elapsed"
        sleep 5
    done
    echo ""

    # Check if PR was merged
    if is_pr_merged "$pr_url"; then
        success "PR merged successfully!"
        echo "accepted" > "$peer_sync/session"
    else
        warn "PR not yet merged - agent may need manual intervention"
    fi
}

cmd_run() {
    local work_timeout=$DEFAULT_WORK_TIMEOUT
    local review_timeout=$DEFAULT_REVIEW_TIMEOUT
    local gather_timeout=$DEFAULT_GATHER_TIMEOUT
    local clarify_timeout=$DEFAULT_CLARIFY_TIMEOUT
    local pushback_timeout=$DEFAULT_PUSHBACK_TIMEOUT
    local plan_timeout=$DEFAULT_PLAN_TIMEOUT
    local poll_interval=$DEFAULT_POLL_INTERVAL
    local max_rounds=10
    local auto_start=false
    local enable_gather=""
    local enable_clarify=""
    local enable_pushback=""
    local enable_plan=""
    local enable_auto_finish=""
    local auto_finish_timeout=""
    local tui_exit_behavior=$DEFAULT_TUI_EXIT_BEHAVIOR

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --work-timeout) work_timeout="$2"; shift 2 ;;
            --review-timeout) review_timeout="$2"; shift 2 ;;
            --gather-timeout) gather_timeout="$2"; shift 2 ;;
            --clarify-timeout) clarify_timeout="$2"; shift 2 ;;
            --pushback-timeout) pushback_timeout="$2"; shift 2 ;;
            --plan-timeout) plan_timeout="$2"; shift 2 ;;
            --gather) enable_gather="true"; shift ;;
            --clarify) enable_clarify="true"; shift ;;
            --pushback) enable_pushback="true"; shift ;;
            --plan) enable_plan="true"; shift ;;
            --auto-finish) enable_auto_finish="true"; shift ;;
            --auto-finish-timeout) auto_finish_timeout="$2"; shift 2 ;;
            --poll) poll_interval="$2"; shift 2 ;;
            --max-rounds) max_rounds="$2"; shift 2 ;;
            --auto-start) auto_start=true; shift ;;
            --on-tui-exit) tui_exit_behavior="$2"; shift 2 ;;
            -*) die "Unknown option: $1" ;;
            *) die "Unknown argument: $1" ;;
        esac
    done

    # Must be run from within a session worktree
    local root
    root="$(get_project_root 2>/dev/null)" || die "Not in an agent-solo session. Run from the orchestrator worktree."
    local peer_sync="$root/.peer-sync"
    [ -f "$peer_sync/feature" ] || die "No active session (missing .peer-sync/feature)"

    local feature
    feature="$(get_feature)"

    # Get coder/reviewer agent assignments
    local coder reviewer
    coder="$(cat "$peer_sync/coder-agent" 2>/dev/null)" || coder="$DEFAULT_CODER"
    reviewer="$(cat "$peer_sync/reviewer-agent" 2>/dev/null)" || reviewer="$DEFAULT_REVIEWER"

    # Determine tmux session name
    local session_name="solo-${feature}"

    # Check tmux session exists
    local coder_session reviewer_session
    if tmux has-session -t "${session_name}-coder" 2>/dev/null; then
        coder_session="${session_name}-coder"
        reviewer_session="${session_name}-reviewer"
    elif tmux has-session -t "$session_name" 2>/dev/null; then
        coder_session="${session_name}:coder"
        reviewer_session="${session_name}:reviewer"
    else
        die "No tmux session found. Run 'agent-solo restart' to resume, or 'agent-solo start $feature' to start fresh."
    fi

    echo ""
    echo "=== Agent Solo Orchestrator ==="
    echo "Feature:        $feature"
    echo "Coder:          $coder"
    echo "Reviewer:       $reviewer"
    echo "Work timeout:   ${work_timeout}s"
    echo "Review timeout: ${review_timeout}s"
    echo "Max rounds:     $max_rounds"
    echo ""

    # Calculate worktree path (use main project root, not the orchestrator worktree)
    local main_root
    main_root="$(get_main_project_root)"
    local project_name
    project_name="$(basename "$main_root")"
    local parent_dir
    parent_dir="$(dirname "$main_root")"
    local worktree="$parent_dir/${project_name}-${feature}"

    # Load codex thinking effort from session
    local codex_thinking
    codex_thinking="$(cat "$peer_sync/codex-thinking" 2>/dev/null)" || codex_thinking="$DEFAULT_CODEX_THINKING"

    # Optionally auto-start agents (only if not already running)
    if $auto_start; then
        info "Starting agents..."
        if ! agent_tui_is_running "$coder_session" "$coder"; then
            tmux send-keys -t "$coder_session" "$(get_agent_cmd "$coder" "$codex_thinking")"
            tmux send-keys -t "$coder_session" C-m
        fi
        if ! agent_tui_is_running "$reviewer_session" "$reviewer"; then
            tmux send-keys -t "$reviewer_session" "$(get_agent_cmd "$reviewer" "$codex_thinking")"
            tmux send-keys -t "$reviewer_session" C-m
        fi
        sleep 3
    fi

    # Check if gather mode is enabled
    local gather_mode
    if [ -n "$enable_gather" ]; then
        gather_mode="$enable_gather"
        echo "$enable_gather" > "$peer_sync/gather-mode"
    else
        gather_mode="$(cat "$peer_sync/gather-mode" 2>/dev/null)" || gather_mode="false"
    fi

    # Handle gather phase if enabled and not already confirmed
    # Gather phase: reviewer collects context for the coder
    if [ "$gather_mode" = "true" ] && [ ! -f "$peer_sync/gather-confirmed" ]; then
        info "=== Gather Phase ==="
        echo "gather" > "$peer_sync/phase"

        # Read task content
        local task_file
        local task_content=""
        if task_file="$(find_task_file "$root" "$feature")"; then
            task_content="$(cat "$task_file" | head -c 4000)"
        fi

        # Reviewer gathers context
        atomic_write "$peer_sync/coder.status" "waiting|$(date +%s)|waiting for reviewer to gather context"
        atomic_write "$peer_sync/reviewer.status" "gathering|$(date +%s)|gather phase"
        info "Reviewer: gather relevant context for the coder..."
        local reviewer_gather_msg
        reviewer_gather_msg="$(generate_reviewer_gather_message "$feature" "$task_content" "$peer_sync")"
        send_to_agent "reviewer" "$reviewer_session" "$peer_sync" message "$reviewer_gather_msg" "gather"

        # Wait for reviewer to complete gather
        local gather_start=$SECONDS
        while true; do
            local elapsed=$((SECONDS - gather_start))
            local reviewer_status
            reviewer_status="$(get_agent_status "reviewer" "$peer_sync")"

            if [ "$reviewer_status" = "gather-done" ]; then
                break
            fi

            # Check for API errors and retry if needed
            check_and_retry_on_error "reviewer" "$reviewer_session" "$peer_sync"

            if [ "$elapsed" -ge "$gather_timeout" ]; then
                warn "Reviewer gather timeout (${gather_timeout}s)"
                break
            fi

            printf "\r  Waiting for reviewer... status=%s (%ds/%ds)  " "$reviewer_status" "$elapsed" "$gather_timeout"
            sleep "$poll_interval"
        done
        echo ""

        # Display gather results
        echo ""
        info "=== Gather Phase Results ==="
        echo ""

        if [ -f "$peer_sync/task-context.md" ]; then
            echo "--- Task Context ---"
            cat "$peer_sync/task-context.md"
            echo ""
        else
            warn "Reviewer did not create task-context.md"
        fi

        echo ""
        echo "=================================="
        echo ""

        # Mark gather as confirmed
        echo "confirmed" > "$peer_sync/gather-confirmed"

        success "Gather phase complete!"
        echo ""
    fi

    # Check if clarify mode is enabled
    local clarify_mode
    if [ -n "$enable_clarify" ]; then
        clarify_mode="$enable_clarify"
        echo "$enable_clarify" > "$peer_sync/clarify-mode"
    else
        clarify_mode="$(cat "$peer_sync/clarify-mode" 2>/dev/null)" || clarify_mode="false"
    fi

    # Handle clarify phase if enabled and not already confirmed
    if [ "$clarify_mode" = "true" ] && [ ! -f "$peer_sync/clarify-confirmed" ]; then
        info "=== Clarify Phase ==="
        echo "clarify" > "$peer_sync/phase"

        # Read task content
        local task_file
        local task_content=""
        if task_file="$(find_task_file "$root" "$feature")"; then
            task_content="$(cat "$task_file" | head -c 4000)"
        fi

        # Step 1: Coder proposes approach
        atomic_write "$peer_sync/coder.status" "clarifying|$(date +%s)|clarify phase"
        info "Coder: propose your approach..."
        local coder_clarify_msg
        coder_clarify_msg="$(generate_coder_clarify_message "$feature" "$task_content" "$peer_sync")"
        send_to_agent "coder" "$coder_session" "$peer_sync" message "$coder_clarify_msg" "clarify"

        # Wait for coder to complete clarify
        local clarify_start=$SECONDS
        while true; do
            local elapsed=$((SECONDS - clarify_start))
            local coder_status
            coder_status="$(get_agent_status "coder" "$peer_sync")"

            if [ "$coder_status" = "clarify-done" ]; then
                break
            fi

            # Check for API errors and retry if needed
            check_and_retry_on_error "coder" "$coder_session" "$peer_sync"

            if [ "$elapsed" -ge "$clarify_timeout" ]; then
                warn "Coder clarify timeout (${clarify_timeout}s)"
                break
            fi

            printf "\r  Waiting for coder... status=%s (%ds/%ds)  " "$coder_status" "$elapsed" "$clarify_timeout"
            sleep "$poll_interval"
        done
        echo ""

        # Step 2: Reviewer reviews coder's approach and adds comments
        atomic_write "$peer_sync/reviewer.status" "clarifying|$(date +%s)|reviewing approach"
        info "Reviewer: review approach and add comments..."
        local reviewer_clarify_msg
        reviewer_clarify_msg="$(generate_reviewer_clarify_message "$feature" "$task_content" "$peer_sync")"
        send_to_agent "reviewer" "$reviewer_session" "$peer_sync" message "$reviewer_clarify_msg" "clarify"

        # Wait for reviewer to complete clarify
        clarify_start=$SECONDS
        while true; do
            local elapsed=$((SECONDS - clarify_start))
            local reviewer_status
            reviewer_status="$(get_agent_status "reviewer" "$peer_sync")"

            if [ "$reviewer_status" = "clarify-done" ]; then
                break
            fi

            # Check for API errors and retry if needed
            check_and_retry_on_error "reviewer" "$reviewer_session" "$peer_sync"

            if [ "$elapsed" -ge "$clarify_timeout" ]; then
                warn "Reviewer clarify timeout (${clarify_timeout}s)"
                break
            fi

            printf "\r  Waiting for reviewer... status=%s (%ds/%ds)  " "$reviewer_status" "$elapsed" "$clarify_timeout"
            sleep "$poll_interval"
        done
        echo ""

        # Send notification (ntfy and/or email)
        send_clarify_notification "$peer_sync" "$feature" "solo"

        # Display clarify results
        echo ""
        info "=== Clarify Phase Results ==="
        echo ""

        if [ -f "$peer_sync/clarify-coder.md" ]; then
            echo "--- Coder's Approach ---"
            cat "$peer_sync/clarify-coder.md"
            echo ""
        else
            warn "Coder did not submit a clarification"
        fi

        if [ -f "$peer_sync/clarify-reviewer.md" ]; then
            echo "--- Reviewer's Comments ---"
            cat "$peer_sync/clarify-reviewer.md"
            echo ""
        else
            warn "Reviewer did not submit comments"
        fi

        echo ""
        echo "=================================="
        echo ""
        info "Respond to agents in their terminals if needed."
        echo ""
        read -r -p "Press Enter when ready to proceed... "

        # Mark clarify as confirmed
        echo "confirmed" > "$peer_sync/clarify-confirmed"

        success "Clarify stage confirmed!"
        echo ""
    fi

    # Check if pushback mode is enabled (command line overrides session setting)
    local pushback_mode
    if [ -n "$enable_pushback" ]; then
        pushback_mode="$enable_pushback"
        echo "$enable_pushback" > "$peer_sync/pushback-mode"
    else
        pushback_mode="$(cat "$peer_sync/pushback-mode" 2>/dev/null)" || pushback_mode="false"
    fi

    # Check if auto-finish mode is enabled (command line overrides session setting)
    local auto_finish
    if [ -n "$enable_auto_finish" ]; then
        auto_finish="$enable_auto_finish"
        echo "$enable_auto_finish" > "$peer_sync/auto-finish"
    else
        auto_finish="$(cat "$peer_sync/auto-finish" 2>/dev/null)" || auto_finish="false"
    fi
    if [ -z "$auto_finish_timeout" ]; then
        auto_finish_timeout="$(cat "$peer_sync/auto-finish-timeout" 2>/dev/null)" || auto_finish_timeout="$DEFAULT_AUTO_FINISH_TIMEOUT"
    else
        echo "$auto_finish_timeout" > "$peer_sync/auto-finish-timeout"
    fi

    # Handle pushback stage if enabled and not already confirmed
    # In solo mode, only the reviewer pushes back
    if [ "$pushback_mode" = "true" ] && [ ! -f "$peer_sync/pushback-confirmed" ]; then
        info "=== Pushback Stage ==="
        echo "pushback" > "$peer_sync/phase"

        # Find task file
        local task_file
        local task_content=""
        if task_file="$(find_task_file "$root" "$feature")"; then
            task_content="$(cat "$task_file" | head -c 4000)"
        fi
        local task_basename="${feature}.md"

        # Only reviewer pushes back in solo mode
        atomic_write "$peer_sync/coder.status" "waiting|$(date +%s)|waiting for reviewer pushback"
        atomic_write "$peer_sync/reviewer.status" "pushing-back|$(date +%s)|pushback stage"
        info "Sending pushback task to reviewer..."
        local reviewer_pushback_msg
        reviewer_pushback_msg="$(generate_solo_pushback_message "$feature" "$task_content" "$peer_sync")"
        send_to_agent "reviewer" "$reviewer_session" "$peer_sync" message "$reviewer_pushback_msg" "pushback"

        # Wait for reviewer to complete pushback stage
        local pushback_start=$SECONDS
        local reviewer_pushback_done=false

        while ! $reviewer_pushback_done; do
            local elapsed=$((SECONDS - pushback_start))

            # Check for completion
            local reviewer_status
            reviewer_status="$(get_agent_status "reviewer" "$peer_sync")"

            [ "$reviewer_status" = "pushback-done" ] && reviewer_pushback_done=true

            if $reviewer_pushback_done; then
                break
            fi

            # Check for API errors and retry if needed
            check_and_retry_on_error "reviewer" "$reviewer_session" "$peer_sync"

            # Check timeout
            if [ "$elapsed" -ge "$pushback_timeout" ]; then
                warn "Pushback stage timeout (${pushback_timeout}s)"
                break
            fi

            printf "\r  Waiting... reviewer=%s (%ds/%ds)  " "$reviewer_status" "$elapsed" "$pushback_timeout"
            sleep "$poll_interval"
        done
        echo ""

        # Send notification with pushback results
        send_pushback_notification "$peer_sync" "$feature" "solo"

        # Display pushback results
        echo ""
        info "=== Pushback Stage Results ==="
        echo ""

        if [ -f "$peer_sync/pushback-reviewer.md" ]; then
            echo "--- Reviewer's Pushback ---"
            cat "$peer_sync/pushback-reviewer.md"
            echo ""
        else
            warn "Reviewer did not submit a pushback"
        fi

        echo ""
        echo "=================================="
        echo ""
        info "Options:"
        echo "  [Enter] - Reject pushback, proceed with original task"
        echo "  [a]     - Accept the pushback"
        echo ""
        read -r -p "Your choice: " pushback_choice

        case "$pushback_choice" in
            a|A)
                # Accept: keep the modified task file as-is
                info "Accepting reviewer's pushback (keeping modified task file)..."
                echo "reviewer" > "$peer_sync/pushback-accepted"
                ;;
            *)
                # Reject: restore original task file from project root
                info "Rejecting pushback, restoring original task..."
                if [ -f "$root/$task_basename" ]; then
                    cp "$root/$task_basename" "$worktree/$task_basename"
                    success "Restored original task file"
                else
                    warn "Original task file not found in project root"
                fi
                echo "rejected" > "$peer_sync/pushback-accepted"
                ;;
        esac

        # Mark pushback as confirmed
        echo "confirmed" > "$peer_sync/pushback-confirmed"
        echo "work" > "$peer_sync/phase"

        success "Pushback stage complete!"
        echo ""
    fi

    # Check if plan mode is enabled (command line overrides session setting)
    local plan_mode
    if [ -n "$enable_plan" ]; then
        plan_mode="$enable_plan"
        echo "$enable_plan" > "$peer_sync/plan-mode"
    else
        plan_mode="$(cat "$peer_sync/plan-mode" 2>/dev/null)" || plan_mode="false"
    fi

    # Handle plan phase if enabled and not already confirmed
    if [ "$plan_mode" = "true" ] && [ ! -f "$peer_sync/plan-confirmed" ]; then
        local plan_round
        plan_round="$(cat "$peer_sync/plan-round" 2>/dev/null)" || plan_round=1
        local max_plan_rounds=3

        while [ "$plan_round" -le "$max_plan_rounds" ]; do
            info "=== Plan Phase (Round $plan_round/$max_plan_rounds) ==="
            echo "plan" > "$peer_sync/phase"
            echo "$plan_round" > "$peer_sync/plan-round"

            check_tui_health "coder" "$coder_session" "$peer_sync" "$tui_exit_behavior"
            atomic_write "$peer_sync/coder.status" "planning|$(date +%s)|plan phase round $plan_round"
            atomic_write "$peer_sync/reviewer.status" "waiting|$(date +%s)|waiting for coder plan"
            info "Triggering solo-coder-plan for coder..."
            send_to_agent "coder" "$coder_session" "$peer_sync" skill "solo-coder-plan"

            local plan_start=$SECONDS
            local coder_plan_done=false
            local coder_needs_notice=false

            while ! $coder_plan_done; do
                local elapsed=$((SECONDS - plan_start))

                local coder_status
                coder_status="$(get_agent_status "coder" "$peer_sync")"

                [ "$coder_status" = "plan-done" ] && coder_plan_done=true

                if [ "$coder_status" = "needs-clarify" ] && [ "$coder_needs_notice" = "false" ]; then
                    coder_needs_notice=true
                    echo ""
                    warn "Coder needs clarification during planning"
                    echo "Respond in the coder terminal, then they will signal plan-done."
                    echo ""
                fi

                if $coder_plan_done; then
                    break
                fi

                if ! $coder_plan_done; then
                    check_tui_health "coder" "$coder_session" "$peer_sync" "$tui_exit_behavior"
                    check_and_retry_on_error "coder" "$coder_session" "$peer_sync"
                fi

                if [ "$elapsed" -ge "$plan_timeout" ]; then
                    warn "Plan phase timeout (${plan_timeout}s)"
                    break
                fi

                printf "\r  Waiting... coder=%s (%ds/%ds)  " "$coder_status" "$elapsed" "$plan_timeout"
                sleep "$poll_interval"
            done
            echo ""

            if [ -f "$peer_sync/plan-coder.md" ]; then
                echo ""
                info "--- Coder's Plan ---"
                cat "$peer_sync/plan-coder.md"
                echo ""
            else
                warn "Coder did not submit a plan"
            fi

            info "=== Plan-Review Phase (Round $plan_round/$max_plan_rounds) ==="
            echo "plan-review" > "$peer_sync/phase"

            check_tui_health "reviewer" "$reviewer_session" "$peer_sync" "$tui_exit_behavior"
            atomic_write "$peer_sync/reviewer.status" "plan-reviewing|$(date +%s)|plan-review phase round $plan_round"
            atomic_write "$peer_sync/coder.status" "waiting|$(date +%s)|waiting for reviewer verdict"
            info "Triggering solo-reviewer-plan for reviewer..."
            send_to_agent "reviewer" "$reviewer_session" "$peer_sync" skill "solo-reviewer-plan"

            local review_start=$SECONDS
            local reviewer_review_done=false
            local reviewer_needs_notice=false

            while ! $reviewer_review_done; do
                local elapsed=$((SECONDS - review_start))

                local reviewer_status
                reviewer_status="$(get_agent_status "reviewer" "$peer_sync")"

                [ "$reviewer_status" = "plan-review-done" ] && reviewer_review_done=true

                if [ "$reviewer_status" = "needs-clarify" ] && [ "$reviewer_needs_notice" = "false" ]; then
                    reviewer_needs_notice=true
                    echo ""
                    warn "Reviewer needs clarification during plan review"
                    echo "Respond in the reviewer terminal, then they will signal plan-review-done."
                    echo ""
                fi

                if $reviewer_review_done; then
                    break
                fi

                if ! $reviewer_review_done; then
                    check_tui_health "reviewer" "$reviewer_session" "$peer_sync" "$tui_exit_behavior"
                    check_and_retry_on_error "reviewer" "$reviewer_session" "$peer_sync"
                fi

                if [ "$elapsed" -ge "$plan_timeout" ]; then
                    warn "Plan-review phase timeout (${plan_timeout}s)"
                    break
                fi

                printf "\r  Waiting... reviewer=%s (%ds/%ds)  " "$reviewer_status" "$elapsed" "$plan_timeout"
                sleep "$poll_interval"
            done
            echo ""

            if [ -f "$peer_sync/plan-review.md" ]; then
                echo ""
                info "--- Reviewer's Plan Review ---"
                cat "$peer_sync/plan-review.md"
                echo ""
            fi

            local verdict=""
            if [ -f "$peer_sync/plan-review.md" ]; then
                if grep -qi "APPROVE" "$peer_sync/plan-review.md"; then
                    verdict="APPROVE"
                elif grep -qi "REQUEST_CHANGES" "$peer_sync/plan-review.md"; then
                    verdict="REQUEST_CHANGES"
                fi
            fi

            local reviewer_msg
            reviewer_msg="$(cut -d'|' -f3- < "$peer_sync/reviewer.status" 2>/dev/null)" || reviewer_msg=""
            if echo "$reviewer_msg" | grep -qi "approve"; then
                verdict="APPROVE"
            elif echo "$reviewer_msg" | grep -qi "request[ _-]*changes"; then
                verdict="REQUEST_CHANGES"
            fi

            if [ "$verdict" = "APPROVE" ]; then
                success "Plan approved! Proceeding to work phase..."
                echo "confirmed" > "$peer_sync/plan-confirmed"
                break
            fi

            if [ "$verdict" = "REQUEST_CHANGES" ] && [ "$plan_round" -lt "$max_plan_rounds" ]; then
                warn "Reviewer requested changes. Coder will revise the plan..."
                plan_round=$((plan_round + 1))
                continue
            fi

            if [ "$plan_round" -ge "$max_plan_rounds" ]; then
                warn "Max plan rounds ($max_plan_rounds) reached. Proceeding to work phase..."
            else
                info "Proceeding to work phase..."
            fi
            echo "confirmed" > "$peer_sync/plan-confirmed"
            break
        done

        echo "work" > "$peer_sync/phase"
        echo ""
    fi

    # Set phase to work if not already set
    if [ "$(cat "$peer_sync/phase" 2>/dev/null)" != "work" ]; then
        echo "work" > "$peer_sync/phase"
    fi

    # Main loop: Sequential work/review
    # Resume from persisted round if restarting
    local round
    round="$(cat "$peer_sync/round" 2>/dev/null)" || round=1

    while [ "$round" -le "$max_rounds" ]; do
        # Check if session is complete
        if [ "$(cat "$peer_sync/session" 2>/dev/null)" = "complete" ]; then
            success "Session complete!"
            break
        fi

        # Check if PR was created
        if has_pr "coder" "$peer_sync"; then
            echo "complete" > "$peer_sync/session"
            success "PR created - session complete!"
            echo ""
            echo "PR: $(cat "$peer_sync/coder.pr")"
            break
        fi

        # Check if review from a previous run was already approved
        local prev_review="$peer_sync/reviews/round-${round}-review.md"
        if [ -f "$prev_review" ] && grep -qi "APPROVE" "$prev_review" 2>/dev/null; then
            success "Found approved review (round $round). Creating PR..."
            if ( lib_create_pr "$feature" "coder" "$worktree" "$root" "$peer_sync" "$feature" "solo" "Solution for $feature" \
                 && persist_workflow_feedback "$peer_sync" "$feature" "solo" \
                 && echo "complete" > "$peer_sync/session" ); then
                success "PR created!"
            else
                warn "PR creation failed — create manually with: agent-solo pr"
            fi
            break
        fi

        echo ""
        info "=== Round $round: Coder Work Phase ==="
        echo "$round" > "$peer_sync/round"
        echo "work" > "$peer_sync/phase"

        # Trigger work phase for coder
        atomic_write "$peer_sync/coder.status" "working|$(date +%s)|round $round work phase"
        atomic_write "$peer_sync/reviewer.status" "waiting|$(date +%s)|waiting for coder"

        if [ "$round" -eq 1 ]; then
            # Round 1: Send full context message
            local task_file
            local task_content=""
            if task_file="$(find_task_file "$root" "$feature")"; then
                task_content="$(cat "$task_file" | head -c 4000)"
            fi

            info "Sending task to coder..."
            local coder_msg
            coder_msg="$(generate_coder_work_message "$feature" "$task_content" "$peer_sync" "$round")"
            send_to_agent "coder" "$coder_session" "$peer_sync" message "$coder_msg" "round1-work"
        else
            # Round 2+: Trigger skill
            info "Triggering solo-coder-work for coder..."
            send_to_agent "coder" "$coder_session" "$peer_sync" skill "solo-coder-work"
        fi

        # Wait for coder to complete work
        local work_start=$SECONDS
        while true; do
            local elapsed=$((SECONDS - work_start))
            local coder_status
            coder_status="$(get_agent_status "coder" "$peer_sync")"

            # Accept done or pr-created
            if [[ "$coder_status" =~ ^(done|pr-created)$ ]]; then
                break
            fi

            # Check for PR created mid-phase
            if has_pr "coder" "$peer_sync"; then
                break
            fi

            # Check for API errors and retry if needed
            check_and_retry_on_error "coder" "$coder_session" "$peer_sync"

            # Check timeout
            if [ "$elapsed" -ge "$work_timeout" ]; then
                warn "Work phase timeout (${work_timeout}s)"
                interrupt_agent "coder" "$coder_session" "$peer_sync"
                break
            fi

            printf "\r  Waiting for coder... status=%s (%ds/%ds)  " "$coder_status" "$elapsed" "$work_timeout"
            sleep "$poll_interval"
        done
        echo ""

        # Check if PR was created during work
        if has_pr "coder" "$peer_sync"; then
            echo "complete" > "$peer_sync/session"
            success "PR created - session complete!"
            echo ""
            echo "PR: $(cat "$peer_sync/coder.pr")"
            break
        fi

        # Check for escalations before transitioning to review phase
        # If user chooses to defer, escalations remain but we continue to review phase
        # They'll be checked again at the next phase boundary
        if has_pending_escalations "$peer_sync" >/dev/null; then
            handle_escalation_block "$peer_sync" "$feature" "solo" || true
        fi

        # Review phase
        info "=== Round $round: Review Phase ==="
        echo "review" > "$peer_sync/phase"

        atomic_write "$peer_sync/reviewer.status" "reviewing|$(date +%s)|round $round review phase"
        atomic_write "$peer_sync/coder.status" "waiting|$(date +%s)|waiting for review"

        info "Triggering solo-reviewer-work for reviewer..."
        send_to_agent "reviewer" "$reviewer_session" "$peer_sync" "skill" "solo-reviewer-work"

        # Wait for reviewer to complete review
        local review_start=$SECONDS
        while true; do
            local elapsed=$((SECONDS - review_start))
            local reviewer_status
            reviewer_status="$(get_agent_status "reviewer" "$peer_sync")"

            # Accept review-done or done
            if [[ "$reviewer_status" =~ ^(done|review-done)$ ]]; then
                break
            fi

            # Check timeout
            if [ "$elapsed" -ge "$review_timeout" ]; then
                warn "Review phase timeout (${review_timeout}s)"
                interrupt_agent "reviewer" "$reviewer_session" "$peer_sync"
                break
            fi

            # Check for API errors and retry if needed
            check_and_retry_on_error "reviewer" "$reviewer_session" "$peer_sync"

            printf "\r  Waiting for reviewer... status=%s (%ds/%ds)  " "$reviewer_status" "$elapsed" "$review_timeout"
            sleep "$poll_interval"
        done
        echo ""

        # Check review verdict
        local review_file="$peer_sync/reviews/round-${round}-review.md"
        if [ -f "$review_file" ]; then
            if grep -qi "APPROVE" "$review_file" 2>/dev/null; then
                success "Reviewer approved! Creating PR..."
                if ( lib_create_pr "$feature" "coder" "$worktree" "$root" "$peer_sync" "$feature" "solo" "Solution for $feature" \
                     && persist_workflow_feedback "$peer_sync" "$feature" "solo" \
                     && echo "complete" > "$peer_sync/session" ); then
                    success "PR created!"
                else
                    warn "PR creation failed — create manually with: agent-solo pr"
                fi
                break
            else
                info "Reviewer requested changes. Proceeding to next round."
            fi
        fi

        # Check for escalations before transitioning to next work round
        # If user chooses to defer, escalations remain but we continue to next round
        # They'll be checked again at the next phase boundary
        if has_pending_escalations "$peer_sync" >/dev/null; then
            handle_escalation_block "$peer_sync" "$feature" "solo" || true
        fi

        round=$((round + 1))
    done

    if [ "$round" -gt "$max_rounds" ]; then
        warn "Reached max rounds ($max_rounds)"
    fi

    # PR Comment Watch Phase
    # After PR is created and approved, monitor for new comments/reviews
    # This also works for backward compatibility: running on old sessions with PRs
    if has_pr "coder" "$peer_sync"; then
        local pr_url
        pr_url="$(cat "$peer_sync/coder.pr")"

        # Check if PR is already closed/merged before entering watch phase
        if ! is_pr_open "$pr_url"; then
            info "PR is already closed/merged. Skipping PR watch phase."
        else
            echo ""
            info "=== PR Comment Watch Phase ==="
            echo "pr-comments" > "$peer_sync/phase"

            echo "Monitoring PR for new comments..."
            echo "  PR: $pr_url"
            echo ""
            echo "Press Ctrl-C to stop watching."
            echo ""

            # Check if this is first entry to PR comment phase (no hash file yet)
            # If so, assume existing comments/reviews need to be processed
            local first_entry=false
            if [ ! -f "$peer_sync/coder.pr-hash" ]; then
                first_entry=true
                get_pr_comment_hash "$pr_url" > "$peer_sync/coder.pr-hash" 2>/dev/null || true
            fi

            # Auto-finish timeout tracking (resets on any activity)
            local auto_finish_last_activity=$SECONDS

            while true; do
                # Check if PR is closed/merged
                if ! is_pr_open "$pr_url"; then
                    # Distinguish between merged and closed-without-merge
                    if is_pr_merged "$pr_url"; then
                        success "PR accepted and merged to main. Session complete!"
                        echo "accepted" > "$peer_sync/session"
                        run_suggest_refactor_solo "$peer_sync" "$coder_session" "$feature"
                    else
                        info "PR closed without merging. Session complete."
                        echo "closed" > "$peer_sync/session"
                    fi
                    break
                fi

                # Check if main has advanced (another feature was merged)
                # and our branch needs rebasing
                if main_has_advanced "$peer_sync"; then
                    info "Main branch has advanced - checking if rebase needed..."

                    local coder_branch="${feature}"

                    if branch_needs_rebase "$coder_branch" "$peer_sync"; then
                        info "Branch needs rebasing onto updated main"
                        echo "integrate" > "$peer_sync/phase"

                        # Trigger integrate skill for coder
                        check_tui_health "$coder" "$coder_session" "$peer_sync" "$tui_exit_behavior"
                        atomic_write "$peer_sync/coder.status" "working|$(date +%s)|integrating (rebasing onto main)"
                        info "Triggering solo-integrate for coder..."
                        send_to_agent "coder" "$coder_session" "$peer_sync" "skill" "solo-integrate"

                        # Wait for integration to complete
                        local integrate_start=$SECONDS
                        while true; do
                            local elapsed=$((SECONDS - integrate_start))
                            local coder_status
                            coder_status="$(get_agent_status "coder" "$peer_sync")"

                            # Check for completion
                            if [[ "$coder_status" =~ ^(integrate-done|done)$ ]]; then
                                info "Coder completed integration"
                                break
                            fi

                            # Check timeout
                            if [ "$elapsed" -ge "$DEFAULT_INTEGRATE_TIMEOUT" ]; then
                                warn "Integration timeout (${DEFAULT_INTEGRATE_TIMEOUT}s)"
                                break
                            fi

                            # Check for API errors and retry if needed
                            check_and_retry_on_error "coder" "$coder_session" "$peer_sync"

                            printf "\r  Integrating... coder=%s (%ds)  " "$coder_status" "$elapsed"
                            sleep "$poll_interval"
                        done
                        echo ""

                        # Resume pr-comments phase
                        echo "pr-comments" > "$peer_sync/phase"
                        info "Integration complete, resuming PR comment watch"
                        # Reset auto-finish timeout after integration activity
                        auto_finish_last_activity=$SECONDS
                    fi
                fi

                # Check for "Proceed to merge" trigger (consistent with duo mode)
                if pr_has_merge_trigger "$pr_url"; then
                    echo ""
                    success "Merge trigger detected ('Proceed to merge' comment found)!"
                    info "Triggering final merge..."
                    trigger_solo_final_merge "$coder" "$coder_session" "$peer_sync" "$tui_exit_behavior"
                    if is_pr_merged "$pr_url"; then
                        success "PR merged successfully!"
                        echo "accepted" > "$peer_sync/session"
                        run_suggest_refactor_solo "$peer_sync" "$coder_session" "$feature"
                    fi
                    break
                fi

                # Check for new comments
                # On first entry, trigger if PR has any reviews to process
                local needs_attention=false
                if $first_entry; then
                    # First entry: check if PR has any reviews to process
                    local pr_hash
                    pr_hash="$(cat "$peer_sync/coder.pr-hash" 2>/dev/null)" || pr_hash=""
                    local review_count="${pr_hash#*|}"  # remove comment count
                    review_count="${review_count%%|*}"  # extract review count
                    if [ -n "$review_count" ] && [ "$review_count" != "0" ]; then
                        needs_attention=true
                        info "PR has $review_count review(s) to process"
                    fi
                    first_entry=false
                elif pr_has_new_comments "coder" "$peer_sync"; then
                    needs_attention=true
                    info "New comments on PR!"
                    send_pr_comment_notification "coder" "$feature" "$pr_url" "solo"
                fi

                if $needs_attention; then

                    # Trigger pr-comment skill for coder
                    check_tui_health "$coder" "$coder_session" "$peer_sync" "$tui_exit_behavior"
                    atomic_write "$peer_sync/coder.status" "working|$(date +%s)|addressing PR comments"
                    info "Triggering solo-pr-comment for coder..."
                    send_to_agent "coder" "$coder_session" "$peer_sync" "skill" "solo-pr-comment"

                    # Wait for coder to finish
                    local pr_watch_start=$SECONDS
                    while true; do
                        local elapsed=$((SECONDS - pr_watch_start))
                        local coder_status
                        coder_status="$(get_agent_status "coder" "$peer_sync")"

                        # Check for completion
                        if [[ "$coder_status" =~ ^(done|pr-created)$ ]]; then
                            break
                        fi

                        # Check timeout
                        if [ "$elapsed" -ge "$DEFAULT_PR_WATCH_TIMEOUT" ]; then
                            warn "PR comment response timeout (${DEFAULT_PR_WATCH_TIMEOUT}s)"
                            break
                        fi

                        # Check for API errors and retry if needed
                        check_and_retry_on_error "coder" "$coder_session" "$peer_sync"

                        printf "\r  Waiting for coder... status=%s (%ds)  " "$coder_status" "$elapsed"
                        sleep "$poll_interval"
                    done
                    echo ""
                    # Reset auto-finish timeout after agent activity
                    auto_finish_last_activity=$SECONDS
                fi

                # Auto-finish timeout check
                if [ "$auto_finish" = "true" ]; then
                    local inactivity_elapsed=$((SECONDS - auto_finish_last_activity))
                    if [ "$inactivity_elapsed" -ge "$auto_finish_timeout" ]; then
                        info "Auto-finish timeout reached (${auto_finish_timeout}s inactivity)"
                        info "Triggering final merge..."
                        trigger_solo_final_merge "$coder" "$coder_session" "$peer_sync" "$tui_exit_behavior"
                        # Check if merge succeeded
                        if is_pr_merged "$pr_url"; then
                            success "PR merged successfully!"
                            echo "accepted" > "$peer_sync/session"
                            run_suggest_refactor_solo "$peer_sync" "$coder_session" "$feature"
                        fi
                        break
                    fi
                fi

                # Poll interval before next check
                if [ "$auto_finish" = "true" ]; then
                    local inactivity_elapsed=$((SECONDS - auto_finish_last_activity))
                    local remaining=$((auto_finish_timeout - inactivity_elapsed))
                    printf "\r  Watching for PR comments... (auto-finish in %ds)  " "$remaining"
                else
                    printf "\r  Watching for PR comments... (Ctrl-C to stop)  "
                fi
                sleep "$poll_interval"
            done
        fi
    fi

    echo ""
    info "=== Final Status ==="
    cmd_status
}

#------------------------------------------------------------------------------
# Command: pr
#------------------------------------------------------------------------------

cmd_pr() {
    local feature_arg=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --feature) feature_arg="$2"; shift 2 ;;
            -*) die "Unknown option: $1" ;;
            *) shift ;;
        esac
    done

    # Resolve session
    if [ -n "$feature_arg" ]; then
        resolve_session --feature "$feature_arg"
    else
        if ! resolve_session 2>/dev/null; then
            die "No active session found. Use --feature <name> or cd to a session worktree."
        fi
    fi

    local root="$RESOLVED_ROOT"
    local peer_sync="$RESOLVED_PEER_SYNC"
    local feature="$RESOLVED_FEATURE"

    # Determine worktree - get main project root for path calculation
    local main_root
    main_root="$(get_main_project_root)"
    local project_name
    project_name="$(basename "$main_root")"
    local parent_dir
    parent_dir="$(dirname "$main_root")"
    local worktree="$parent_dir/${project_name}-${feature}"
    local pr_name="${feature}"

    lib_create_pr "$pr_name" "coder" "$worktree" "$root" "$peer_sync" "$feature" "solo" "Solution for $feature" || return 1

    # Persist workflow feedback and mark session complete
    persist_workflow_feedback "$peer_sync" "$feature" "solo"
    echo "complete" > "$peer_sync/session"
    success "Session complete!"
}

#------------------------------------------------------------------------------
# Command: cleanup
#------------------------------------------------------------------------------

cmd_cleanup() {
    local full=false
    local feature_arg=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --full) full=true; shift ;;
            --feature) feature_arg="$2"; shift 2 ;;
            *) shift ;;
        esac
    done

    local main_root
    main_root="$(get_main_project_root 2>/dev/null)" || die "Not in a git repository"

    # If feature specified, clean just that one
    if [ -n "$feature_arg" ]; then
        cleanup_single_solo_session "$feature_arg" "$main_root" "$full"
        return
    fi

    # Try to resolve session from current directory
    if resolve_session 2>/dev/null; then
        cleanup_single_solo_session "$RESOLVED_FEATURE" "$main_root" "$full"
        return
    fi

    # In main project - clean all sessions from registry
    local sessions
    sessions="$(list_active_sessions "$main_root")"

    if [ -z "$sessions" ]; then
        die "No active sessions found."
    fi

    local count=0
    while IFS=: read -r feat root state; do
        [ -z "$feat" ] && continue
        count=$((count + 1))
    done <<< "$sessions"

    info "Cleaning up $count session(s)..."

    while IFS=: read -r feat root state; do
        [ -z "$feat" ] && continue
        echo ""
        info "=== Cleaning up: $feat ==="
        cleanup_single_solo_session "$feat" "$main_root" "$full"
    done <<< "$sessions"

    success "All sessions cleaned up"
}

# Cleanup a single solo session
cleanup_single_solo_session() {
    local feature="$1"
    local main_root="$2"
    local full="$3"

    local project_name
    project_name="$(basename "$main_root")"
    local parent_dir
    parent_dir="$(dirname "$main_root")"
    local sessions_dir="$main_root/.agent-sessions"

    # Get worktree path (solo uses single worktree)
    local worktree="$parent_dir/${project_name}-${feature}"
    local peer_sync="$worktree/.peer-sync"

    info "Cleaning up session: $feature"

    # Stop any running processes first
    if [ -d "$peer_sync" ]; then
        stop_single_solo_session "$feature" "$worktree" "$peer_sync"
    fi

    # Accumulate workflow feedback before cleanup
    persist_workflow_feedback "$peer_sync" "$feature" "solo"

    # Remove session from registry
    if [ -L "$sessions_dir/solo-${feature}.session" ]; then
        rm -f "$sessions_dir/solo-${feature}.session"
        info "Removed from registry"
    fi

    # Remove .peer-sync
    if [ -d "$peer_sync" ]; then
        rm -rf "$peer_sync"
        info "Removed .peer-sync"
    fi

    if [ "$full" = "true" ]; then
        cd "$main_root"  # Make sure we're in main repo for git operations

        if [ -d "$worktree" ]; then
            git worktree remove --force "$worktree" 2>/dev/null || rm -rf "$worktree"
            info "Removed worktree: $worktree"
        fi

        git worktree prune
        git branch -D "${feature}" 2>/dev/null && info "Deleted local branch: ${feature}" || true
        git push origin --delete "${feature}" 2>/dev/null && info "Deleted remote branch: origin/${feature}" || true
    fi

    success "Cleanup complete for $feature"
}

#------------------------------------------------------------------------------
# Command: confirm
#------------------------------------------------------------------------------

cmd_confirm() {
    local root
    root="$(get_project_root)"
    local peer_sync="$root/.peer-sync"

    local phase
    phase="$(cat "$peer_sync/phase" 2>/dev/null)" || die "No active session"

    if [ "$phase" != "clarify" ]; then
        if [ -f "$peer_sync/clarify-confirmed" ]; then
            info "Clarify phase already confirmed."
        else
            die "Not in clarify phase (current phase: $phase)"
        fi
        return 0
    fi

    echo "confirmed" > "$peer_sync/clarify-confirmed"
    echo "work" > "$peer_sync/phase"

    success "Clarify phase confirmed! Transitioning to work phase."
    echo "Note: If orchestrator is waiting for input, press Enter there to continue."
}

#------------------------------------------------------------------------------
# Command: escalate (for agents to flag issues needing user input)
#------------------------------------------------------------------------------

cmd_escalate() {
    lib_cmd_escalate "$@"
}

#------------------------------------------------------------------------------
# Command: escalate-resolve (user resolves an escalation)
#------------------------------------------------------------------------------

cmd_escalate_resolve() {
    local root
    root="$(get_project_root)"
    local peer_sync="$root/.peer-sync"

    # Find pending escalations
    local escalations=()
    for f in "$peer_sync"/escalation-*.md; do
        [ -f "$f" ] && escalations+=("$f")
    done

    if [ ${#escalations[@]} -eq 0 ]; then
        info "No pending escalations."
        return 0
    fi

    # Display all escalations
    echo ""
    info "=== Pending Escalations ==="
    echo ""
    for f in "${escalations[@]}"; do
        cat "$f"
        echo ""
        echo "---"
        echo ""
    done

    # Prompt for resolution
    echo "Options:"
    echo "  1. Resolve all escalations (agents will continue normally)"
    echo "  2. Cancel (keep escalations pending)"
    echo ""
    read -r -p "Choice [1/2]: " choice

    case "$choice" in
        1)
            # Remove escalation files
            for f in "${escalations[@]}"; do
                rm -f "$f"
            done

            # Mark escalations as resolved
            echo "resolved|$(date +%s)" > "$peer_sync/escalation-resolved"

            success "Escalations resolved. Orchestrator will continue."
            echo "Note: If orchestrator is waiting, press Enter there to continue."
            ;;
        2|*)
            info "Escalations remain pending."
            ;;
    esac
}

#------------------------------------------------------------------------------
# Command: signal (for agents)
#------------------------------------------------------------------------------

cmd_signal() {
    lib_cmd_signal "$@"
}

#------------------------------------------------------------------------------
# Command: peer-status (for agents)
#------------------------------------------------------------------------------

cmd_peer_status() {
    lib_cmd_peer_status
}

#------------------------------------------------------------------------------
# Command: phase (for agents)
#------------------------------------------------------------------------------

cmd_phase() {
    lib_cmd_phase
}

#------------------------------------------------------------------------------
# Command: nudge
#------------------------------------------------------------------------------

cmd_nudge() {
    local agent="$1"
    local message="${2:-Continue.}"

    [ -z "$agent" ] && die "Usage: agent-solo nudge <agent> [message]"
    [[ "$agent" =~ ^(coder|reviewer)$ ]] || die "Agent must be 'coder' or 'reviewer'"

    local root
    root="$(get_project_root)"
    local feature
    feature="$(get_feature)"
    local session_name="solo-${feature}"

    # Determine session target
    local session
    if tmux has-session -t "$session_name" 2>/dev/null; then
        session="${session_name}:${agent}"
    elif tmux has-session -t "${session_name}-${agent}" 2>/dev/null; then
        session="${session_name}-${agent}"
    else
        die "No tmux session found for $agent. Run 'agent-solo restart' first."
    fi

    nudge_agent "$agent" "$session" "$message"
    success "Nudged $agent"
}

#------------------------------------------------------------------------------
# Command: interrupt
#------------------------------------------------------------------------------

cmd_interrupt() {
    local agent="$1"

    [ -z "$agent" ] && die "Usage: agent-solo interrupt <agent>"
    [[ "$agent" =~ ^(coder|reviewer)$ ]] || die "Agent must be 'coder' or 'reviewer'"

    local root
    root="$(get_project_root)"
    local peer_sync="$root/.peer-sync"
    local feature
    feature="$(get_feature)"
    local session_name="solo-${feature}"

    # Determine session target
    local session
    if tmux has-session -t "$session_name" 2>/dev/null; then
        session="${session_name}:${agent}"
    elif tmux has-session -t "${session_name}-${agent}" 2>/dev/null; then
        session="${session_name}-${agent}"
    else
        die "No tmux session found for $agent. Run 'agent-solo restart' first."
    fi

    interrupt_agent "$agent" "$session" "$peer_sync"
    success "Interrupted $agent"
}

#------------------------------------------------------------------------------
# Command: help
#------------------------------------------------------------------------------

cmd_help() {
    cat << 'EOF'
Agent Solo - Coder/Reviewer AI Workflow

USAGE
    agent-solo <command> [options]

SESSION COMMANDS
    start <feature> [<feature2> ...] [options]
        Start a new session for the given feature(s).
        Creates one shared worktree, two tmux sessions (coder + reviewer), and ttyd web terminals.

        Options:
          --coder <agent>        Agent for coding (default: claude)
          --reviewer <agent>     Agent for reviewing (default: codex)
          --auto-run             Start orchestrator immediately
          --no-ttyd              Use single tmux session instead of web terminals
          --gather               Enable gather stage (reviewer collects task context)
          --clarify              Enable clarify stage before work starts
          --pushback             Enable pushback stage (reviewer proposes task improvements)
          --plan                 Enable plan stage (after pushback if both enabled)
          --work-timeout <secs>  Work phase timeout (default: 1200)
          --review-timeout <secs> Review phase timeout (default: 600)
          --gather-timeout <secs> Gather stage timeout (default: 600)
          --clarify-timeout <secs> Clarify stage timeout (default: 600)
          --pushback-timeout <secs> Pushback stage timeout (default: 600)
          --plan-timeout <secs>  Plan phase timeout (default: 600)
          --max-rounds <n>       Maximum rounds (default: 10)
          --codex-thinking <level> Codex reasoning effort: low, medium, high (default: high)
          --codex-model <model>  GPT model for Codex (e.g., o3, gpt-4.1)
          --claude-model <model> Claude model (e.g., opus, sonnet)
          --port <port>          Base port for web terminals (uses 3 consecutive ports)
                                 If not specified, finds first available consecutive ports.
                                 Fails if any of the 3 ports are occupied.

    run [options]
        Run the orchestrator loop (coder work -> reviewer review -> repeat).

        Options:
          --gather               Enable gather stage (reviewer collects task context)
          --clarify              Enable clarify stage
          --pushback             Enable pushback stage (reviewer proposes task improvements)
          --plan                 Enable plan stage (after pushback if both enabled)
          --work-timeout <secs>  Work phase timeout (default: 1200)
          --review-timeout <secs> Review phase timeout (default: 600)
          --gather-timeout <secs> Gather stage timeout (default: 600)
          --clarify-timeout <secs> Clarify stage timeout (default: 600)
          --pushback-timeout <secs> Pushback stage timeout (default: 600)
          --plan-timeout <secs>  Plan phase timeout (default: 600)
          --poll <secs>          Status poll interval (default: 10)
          --max-rounds <n>       Maximum rounds (default: 10)
          --auto-start           Auto-launch agent CLIs and send task

    stop
        Stop ttyd servers and tmux sessions, keep worktree.

    restart [options]
        Restart a session after a system restart or if terminals crash.
        Checks and recreates tmux sessions, ttyd servers (if applicable), and agent TUIs.

        Options:
          --auto-run             Restart the orchestrator loop automatically
          --no-ttyd              Force tmux-only mode (override recorded setting)
          --work-timeout <secs>  Work phase timeout (default: 1200)
          --review-timeout <secs> Review phase timeout (default: 600)
          --gather-timeout <secs> Gather stage timeout (default: 600)
          --clarify-timeout <secs> Clarify stage timeout (default: 600)
          --pushback-timeout <secs> Pushback stage timeout (default: 600)
          --max-rounds <n>       Maximum rounds (default: 10)

    status
        Show current session state and agent statuses.

    confirm
        Confirm the clarify phase is complete and proceed to work phase.

    escalate-resolve
        Review and resolve pending escalations from agents.
        Escalations block phase transitions until resolved.

    pr
        Create a PR for the coder's solution.
        Auto-commits uncommitted changes and pushes.

    cleanup [--full]
        Remove session state (.peer-sync). With --full, also removes
        worktree and deletes the feature branch.

    setup
        Install agent-solo to ~/.local/bin and skills to agent dirs.

CONTROL COMMANDS
    nudge <agent> [message]
        Send a message to an agent's terminal (coder or reviewer).
        Default message: "Continue."

    interrupt <agent>
        Send Escape to interrupt an agent.

AGENT COMMANDS (used by AI agents)
    signal <agent> <status> [message]
        Signal a status change. Agent is 'coder' or 'reviewer'.
        Status values: gathering, gather-done, clarifying, clarify-done,
        pushing-back, pushback-done, planning, plan-done, plan-reviewing,
        plan-review-done, needs-clarify, working, done, reviewing, review-done,
        interrupted, error, pr-created, escalated

    peer-status
        Read peer's current status (requires PEER_NAME env var).

    phase
        Read current phase (gather, clarify, pushback, plan, plan-review, work, or review).

    escalate <reason> [message]
        Escalate an issue requiring user input. Does not interrupt the agent.
        The orchestrator will block phase transitions until user resolves.

        Reasons:
          ambiguity     - Requirements are unclear
          inconsistency - Conflicting requirements or code/docs mismatch
          misguided     - Evidence the task approach is wrong

WORKFLOW
    Solo mode uses a sequential workflow:

    GATHER PHASE (if --gather):
      1. Reviewer explores codebase and collects relevant context
      2. Reviewer writes task-context.md with file links and notes
      3. Coder reads context before starting work

    CLARIFY PHASE (if --clarify):
      1. Coder proposes approach and questions
      2. Reviewer reviews approach and adds comments
      3. User responds, then confirms

    WORK/REVIEW LOOP:
      1. Coder implements solution
      2. Coder signals "done"
      3. Reviewer examines code (git diff, etc.)
      4. Reviewer writes review with verdict (APPROVE or REQUEST_CHANGES)
      5. If approved: coder creates PR
      6. If changes requested: loop back to step 1

EXAMPLES
    # Start with auto-run (opens 3 web terminals, starts everything)
    agent-solo start auth --auto-run

    # With gather phase (reviewer collects context first)
    agent-solo start auth --auto-run --gather

    # With clarify phase
    agent-solo start auth --auto-run --clarify

    # With all optional phases (gather -> clarify -> pushback -> work)
    agent-solo start auth --auto-run --gather --clarify --pushback

    # Swap agent roles (codex codes, claude reviews)
    agent-solo start auth --coder codex --reviewer claude

    # Check status
    agent-solo status

    # Create PR when reviewer approves
    agent-solo pr

    # Clean up
    agent-solo cleanup --full
EOF
}

#------------------------------------------------------------------------------
# Main
#------------------------------------------------------------------------------

main() {
    local cmd="${1:-help}"
    shift || true

    case "$cmd" in
        start)       cmd_start "$@" ;;
        run)         cmd_run "$@" ;;
        stop)        cmd_stop "$@" ;;
        restart)     cmd_restart "$@" ;;
        status)      cmd_status "$@" ;;
        confirm)     cmd_confirm "$@" ;;
        escalate)    cmd_escalate "$@" ;;
        escalate-resolve) cmd_escalate_resolve "$@" ;;
        pr)          cmd_pr "$@" ;;
        cleanup)     cmd_cleanup "$@" ;;
        setup)       cmd_setup "$@" ;;
        nudge)       cmd_nudge "$@" ;;
        interrupt)   cmd_interrupt "$@" ;;
        signal)      cmd_signal "$@" ;;
        peer-status) cmd_peer_status "$@" ;;
        phase)       cmd_phase "$@" ;;
        help|--help|-h) cmd_help ;;
        *)           die "Unknown command: $cmd (try 'agent-solo help')" ;;
    esac
}

main "$@"
