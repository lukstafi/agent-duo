#!/usr/bin/env bash
# agent-solo - Coordinate a coder/reviewer AI workflow in a single worktree
#
# Requires Bash 4.0+ (for associative arrays, regex matching, etc.)
# macOS users: install modern bash via Homebrew: brew install bash
#
# Usage: agent-solo <command> [options]
#
# Session Commands:
#   start <feature> [--auto-run] [--no-ttyd] [--clarify]  Start session
#   run [options]        Run orchestrator loop with timeouts
#   stop                 Stop ttyd servers, keep worktree
#   restart [--auto-run] Restart session after system restart/crash
#   status               Show session state
#   confirm              Confirm clarify phase completion (proceed to work)
#   pr                   Create PR for coder's solution
#   cleanup [--full]     Remove session state (--full: also worktree/branch)
#   setup                Install agent-solo to PATH and skills
#
# Control Commands:
#   nudge <agent> [msg]  Send message to agent terminal (coder or reviewer)
#   interrupt <agent>    Interrupt agent (Esc)
#
# Agent Commands:
#   signal <agent> <status> [message]   Signal status change
#   peer-status                         Read peer's status
#   phase                               Read current phase

set -e

# Determine script location (resolves symlinks)
SCRIPT_PATH="${BASH_SOURCE[0]}"
while [ -L "$SCRIPT_PATH" ]; do
    SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
    SCRIPT_PATH="$(readlink "$SCRIPT_PATH")"
    [[ $SCRIPT_PATH != /* ]] && SCRIPT_PATH="$SCRIPT_DIR/$SCRIPT_PATH"
done
SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"

# Source shared library
if [ -f "$SCRIPT_DIR/agent-lib.sh" ]; then
    # shellcheck source=agent-lib.sh
    source "$SCRIPT_DIR/agent-lib.sh"
elif [ -f "$HOME/.local/bin/agent-lib.sh" ]; then
    # shellcheck source=agent-lib.sh
    source "$HOME/.local/bin/agent-lib.sh"
else
    echo "Error: agent-lib.sh not found" >&2
    exit 1
fi

# Default agents for solo mode (coder does implementation, reviewer reviews)
DEFAULT_CODER="claude"
DEFAULT_REVIEWER="codex"

# Allocate ports for a solo session (3 ports: orchestrator, coder, reviewer)
# Args: peer_sync [base_port]
# If base_port is provided, uses consecutive ports starting from it (fails if any occupied)
# Otherwise, dynamically finds 3 consecutive available ports starting from DEFAULT_BASE_PORT
allocate_ports_solo() {
    local peer_sync="$1"
    local base_port="${2:-}"
    local ports_file="$peer_sync/ports"

    # If ports already allocated, return
    if [ -f "$ports_file" ]; then
        return 0
    fi

    local orchestrator_port coder_port reviewer_port

    if [ -n "$base_port" ]; then
        # User specified a port: use consecutive ports, fail if any occupied
        orchestrator_port="$base_port"
        coder_port=$((base_port + 1))
        reviewer_port=$((base_port + 2))

        if ! is_port_available "$orchestrator_port"; then
            die "Port $orchestrator_port (orchestrator) is already in use"
        fi
        if ! is_port_available "$coder_port"; then
            die "Port $coder_port (coder) is already in use"
        fi
        if ! is_port_available "$reviewer_port"; then
            die "Port $reviewer_port (reviewer) is already in use"
        fi
    else
        # Dynamic allocation: find 3 consecutive available ports
        orchestrator_port="$(find_consecutive_ports "$DEFAULT_BASE_PORT" 3)" || die "Could not find 3 consecutive available ports"
        coder_port=$((orchestrator_port + 1))
        reviewer_port=$((orchestrator_port + 2))
    fi

    cat > "$ports_file" << EOF
ORCHESTRATOR_PORT=$orchestrator_port
CODER_PORT=$coder_port
REVIEWER_PORT=$reviewer_port
EOF
}

#------------------------------------------------------------------------------
# Command: setup
#------------------------------------------------------------------------------

cmd_setup() {
    info "Installing agent-solo..."

    local templates_dir="$SCRIPT_DIR/skills/templates"

    if [ ! -d "$templates_dir" ]; then
        die "Skills templates not found at $templates_dir"
    fi

    # Install CLI to ~/.local/bin
    local install_dir="$HOME/.local/bin"
    mkdir -p "$install_dir"

    local install_path="$install_dir/agent-solo"
    if [ "$SCRIPT_DIR/agent-solo" != "$install_path" ]; then
        cp "$SCRIPT_DIR/agent-solo" "$install_path"
        chmod +x "$install_path"
        success "Installed agent-solo to $install_path"
    else
        success "agent-solo already installed at $install_path"
    fi

    # Install shared library
    local lib_path="$install_dir/agent-lib.sh"
    if [ -f "$SCRIPT_DIR/agent-lib.sh" ]; then
        cp "$SCRIPT_DIR/agent-lib.sh" "$lib_path"
        success "Installed agent-lib.sh to $lib_path"
    fi

    # Copy skills/templates to install dir so setup works from installed location
    local installed_templates="$install_dir/skills/templates"
    if [ "$templates_dir" != "$installed_templates" ]; then
        mkdir -p "$installed_templates"
        cp -r "$templates_dir"/* "$installed_templates/"
        success "Installed skill templates to $installed_templates"
    fi

    # Install shared helper scripts
    local shared_dir="$HOME/.local/share/agent-duo"
    mkdir -p "$shared_dir"
    local shared_templates="$templates_dir/shared"
    if [ -d "$shared_templates" ]; then
        cp "$shared_templates"/*.sh "$shared_dir/" 2>/dev/null || true
        chmod +x "$shared_dir"/*.sh 2>/dev/null || true
        success "Installed shared scripts to $shared_dir"
    fi

    # Check if ~/.local/bin is in PATH
    if [[ ":$PATH:" != *":$install_dir:"* ]]; then
        warn "Add $install_dir to your PATH:"
        echo "  export PATH=\"\$HOME/.local/bin:\$PATH\""
    fi

    # Install Claude skills (uses /command syntax)
    local claude_skills="$HOME/.claude/commands"
    mkdir -p "$claude_skills"

    install_skill "$templates_dir/solo-coder-work.md" "$claude_skills/solo-coder-work.md" "/solo-coder-work"
    install_skill "$templates_dir/solo-coder-clarify.md" "$claude_skills/solo-coder-clarify.md" "/solo-coder-clarify"
    install_skill "$templates_dir/solo-reviewer-work.md" "$claude_skills/solo-reviewer-work.md" "/solo-reviewer-work"
    install_skill "$templates_dir/solo-reviewer-clarify.md" "$claude_skills/solo-reviewer-clarify.md" "/solo-reviewer-clarify"
    install_skill "$templates_dir/solo-reviewer-pushback.md" "$claude_skills/solo-reviewer-pushback.md" "/solo-reviewer-pushback"
    install_skill "$templates_dir/solo-pr-comment.md" "$claude_skills/solo-pr-comment.md" "/solo-pr-comment"
    success "Installed Claude solo skills to $claude_skills"

    # Install Codex skills (uses $command syntax)
    local codex_skills="$HOME/.codex/skills"
    mkdir -p "$codex_skills/solo-coder-work" "$codex_skills/solo-coder-clarify"
    mkdir -p "$codex_skills/solo-reviewer-work" "$codex_skills/solo-reviewer-clarify" "$codex_skills/solo-reviewer-pushback"
    mkdir -p "$codex_skills/solo-pr-comment"

    install_skill "$templates_dir/solo-coder-work.md" "$codex_skills/solo-coder-work/SKILL.md" "\$solo-coder-work"
    install_skill "$templates_dir/solo-coder-clarify.md" "$codex_skills/solo-coder-clarify/SKILL.md" "\$solo-coder-clarify"
    install_skill "$templates_dir/solo-reviewer-work.md" "$codex_skills/solo-reviewer-work/SKILL.md" "\$solo-reviewer-work"
    install_skill "$templates_dir/solo-reviewer-clarify.md" "$codex_skills/solo-reviewer-clarify/SKILL.md" "\$solo-reviewer-clarify"
    install_skill "$templates_dir/solo-reviewer-pushback.md" "$codex_skills/solo-reviewer-pushback/SKILL.md" "\$solo-reviewer-pushback"
    install_skill "$templates_dir/solo-pr-comment.md" "$codex_skills/solo-pr-comment/SKILL.md" "\$solo-pr-comment"
    success "Installed Codex solo skills to $codex_skills"

    # Install unified notify hook script and configure agent hooks
    local notify_script
    notify_script="$(install_notify_hook "$install_dir")"
    success "Installed unified notify hook script to $notify_script"

    configure_codex_notify "$notify_script"
    configure_claude_notify "$notify_script"

    success "Setup complete!"
}

#------------------------------------------------------------------------------
# Command: start
#------------------------------------------------------------------------------

cmd_start() {
    local feature=""
    local ttyd_mode=true
    local auto_run=false
    local clarify_mode=false
    local pushback_mode=false
    local work_timeout=$DEFAULT_WORK_TIMEOUT
    local review_timeout=$DEFAULT_REVIEW_TIMEOUT
    local clarify_timeout=$DEFAULT_CLARIFY_TIMEOUT
    local pushback_timeout=$DEFAULT_PUSHBACK_TIMEOUT
    local max_rounds=10
    local codex_thinking=$DEFAULT_CODEX_THINKING
    local coder=$DEFAULT_CODER
    local reviewer=$DEFAULT_REVIEWER
    local codex_model=""
    local claude_model=""
    local base_port=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --no-ttyd) ttyd_mode=false; shift ;;
            --auto-run) auto_run=true; shift ;;
            --clarify) clarify_mode=true; shift ;;
            --pushback) pushback_mode=true; shift ;;
            --work-timeout) work_timeout="$2"; shift 2 ;;
            --review-timeout) review_timeout="$2"; shift 2 ;;
            --clarify-timeout) clarify_timeout="$2"; shift 2 ;;
            --pushback-timeout) pushback_timeout="$2"; shift 2 ;;
            --max-rounds) max_rounds="$2"; shift 2 ;;
            --codex-thinking) codex_thinking="$2"; shift 2 ;;
            --codex-model) codex_model="$2"; shift 2 ;;
            --claude-model) claude_model="$2"; shift 2 ;;
            --coder) coder="$2"; shift 2 ;;
            --reviewer) reviewer="$2"; shift 2 ;;
            --port) base_port="$2"; shift 2 ;;
            -*) die "Unknown option: $1" ;;
            *) feature="$1"; shift ;;
        esac
    done

    # Export model overrides if specified (used by get_agent_cmd)
    [ -n "$codex_model" ] && export AGENT_DUO_CODEX_MODEL="$codex_model"
    [ -n "$claude_model" ] && export AGENT_DUO_CLAUDE_MODEL="$claude_model"

    [ -z "$feature" ] && die "Usage: agent-solo start <feature> [--no-ttyd] [--auto-run] [--clarify] [--coder <agent>] [--reviewer <agent>]"

    # Validate codex thinking effort
    case "$codex_thinking" in
        low|medium|high) ;;
        *) die "Invalid --codex-thinking value: $codex_thinking (valid: low, medium, high)" ;;
    esac

    # Ensure we're in a git repo
    git rev-parse --is-inside-work-tree >/dev/null 2>&1 || die "Not a git repository"

    # Ensure repo has at least one commit
    git rev-parse HEAD >/dev/null 2>&1 || die "Repository has no commits. Create an initial commit first."

    local project_root
    project_root="$(git rev-parse --show-toplevel)"
    local project_name
    project_name="$(basename "$project_root")"

    # Check for existing session
    if [ -d "$project_root/.peer-sync" ]; then
        die "Session already exists (.peer-sync found).
To continue an existing session: agent-solo run
To start fresh: agent-solo cleanup && agent-solo start $feature"
    fi

    # Check for task file
    local task_file
    if task_file="$(find_task_file "$project_root" "$feature")"; then
        info "Found task file: $task_file"
    else
        warn "Task file not found: $feature.md"
        warn "Searched: $feature.md, doc/$feature.md, docs/$feature.md, **/$feature.md"
        warn "Create it with the task description, or the agents won't know what to do."
    fi

    info "Starting Agent Solo session: $feature"
    info "Project: $project_name"
    info "Coder: $coder, Reviewer: $reviewer"

    # Set up worktree path (single worktree, sibling of project root)
    local parent_dir
    parent_dir="$(dirname "$project_root")"
    local worktree="$parent_dir/${project_name}-${feature}"

    # Create branch and worktree
    cd "$project_root"

    # Detect main branch
    local main_branch
    main_branch="$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@')" || true
    if [ -z "$main_branch" ]; then
        for candidate in main master; do
            if git rev-parse --verify "$candidate" >/dev/null 2>&1; then
                main_branch="$candidate"
                break
            fi
        done
    fi
    if [ -z "$main_branch" ]; then
        main_branch="$(git rev-parse --abbrev-ref HEAD)"
    fi

    if [ ! -d "$worktree" ]; then
        info "Creating worktree..."
        git worktree add -b "${feature}" "$worktree" "$main_branch" 2>/dev/null || \
            git worktree add "$worktree" "${feature}"
    else
        warn "Worktree already exists: $worktree"
    fi

    # Initialize .peer-sync
    local peer_sync="$project_root/.peer-sync"
    mkdir -p "$peer_sync/reviews"
    mkdir -p "$peer_sync/pids"

    echo "active" > "$peer_sync/session"
    echo "solo" > "$peer_sync/mode"
    echo "$coder" > "$peer_sync/coder-agent"
    echo "$reviewer" > "$peer_sync/reviewer-agent"
    # Determine initial phase: clarify -> pushback -> work
    if $clarify_mode; then
        echo "clarify" > "$peer_sync/phase"
        echo "clarifying|$(date +%s)|starting" > "$peer_sync/coder.status"
        echo "waiting|$(date +%s)|waiting for coder" > "$peer_sync/reviewer.status"
    elif $pushback_mode; then
        echo "pushback" > "$peer_sync/phase"
        echo "waiting|$(date +%s)|waiting for reviewer pushback" > "$peer_sync/coder.status"
        echo "pushing-back|$(date +%s)|starting" > "$peer_sync/reviewer.status"
    else
        echo "work" > "$peer_sync/phase"
        echo "working|$(date +%s)|starting" > "$peer_sync/coder.status"
        echo "waiting|$(date +%s)|waiting for coder" > "$peer_sync/reviewer.status"
    fi
    echo "$clarify_mode" > "$peer_sync/clarify-mode"
    echo "$pushback_mode" > "$peer_sync/pushback-mode"
    echo "1" > "$peer_sync/round"
    echo "$feature" > "$peer_sync/feature"
    echo "$codex_thinking" > "$peer_sync/codex-thinking"

    # Create symlink in worktree
    ln -sfn "$peer_sync" "$worktree/.peer-sync"

    # Ensure .peer-sync is excluded from git
    local git_exclude="$project_root/.git/info/exclude"
    if [ -f "$git_exclude" ]; then
        if ! grep -qxF ".peer-sync" "$git_exclude"; then
            echo ".peer-sync" >> "$git_exclude"
        fi
    else
        mkdir -p "$(dirname "$git_exclude")"
        echo ".peer-sync" > "$git_exclude"
    fi

    # Copy task file to worktree if it exists
    if [ -f "$task_file" ]; then
        cp "$task_file" "$worktree/"
    fi

    if $ttyd_mode; then
        start_ttyd_mode_solo "$feature" "$project_root" "$worktree" "$peer_sync" \
            "$auto_run" "$work_timeout" "$review_timeout" "$max_rounds" "$codex_thinking" "$clarify_mode" "$clarify_timeout" "$coder" "$reviewer" "$pushback_mode" "$pushback_timeout"
    else
        start_tmux_mode_solo "$feature" "$project_root" "$worktree" "$peer_sync" "$codex_thinking" "$clarify_mode" "$coder" "$reviewer" "$pushback_mode"
    fi
}

start_tmux_mode_solo() {
    local feature="$1"
    local project_root="$2"
    local worktree="$3"
    local peer_sync="$4"
    local codex_thinking="${5:-$DEFAULT_CODEX_THINKING}"
    local clarify_mode="${6:-false}"
    local coder="${7:-$DEFAULT_CODER}"
    local reviewer="${8:-$DEFAULT_REVIEWER}"
    local pushback_mode="${9:-false}"

    local session_name="solo-${feature}"

    # Kill existing session if any
    tmux kill-session -t "$session_name" 2>/dev/null || true

    # Create new tmux session with orchestrator window
    tmux new-session -d -s "$session_name" -n "orchestrator" -c "$project_root"

    # Create coder window (in shared worktree)
    tmux new-window -t "$session_name" -n "coder" -c "$worktree"
    tmux send-keys -t "$session_name:coder" "export PEER_SYNC='$peer_sync'"
    tmux send-keys -t "$session_name:coder" C-m
    tmux send-keys -t "$session_name:coder" "export MY_NAME='coder'"
    tmux send-keys -t "$session_name:coder" C-m
    tmux send-keys -t "$session_name:coder" "export MY_ROLE='coder'"
    tmux send-keys -t "$session_name:coder" C-m
    tmux send-keys -t "$session_name:coder" "export PEER_NAME='reviewer'"
    tmux send-keys -t "$session_name:coder" C-m
    tmux send-keys -t "$session_name:coder" "export FEATURE='$feature'"
    tmux send-keys -t "$session_name:coder" C-m
    tmux send-keys -t "$session_name:coder" "export WORKTREE='$worktree'"
    tmux send-keys -t "$session_name:coder" C-m

    # Create reviewer window (in same shared worktree)
    tmux new-window -t "$session_name" -n "reviewer" -c "$worktree"
    tmux send-keys -t "$session_name:reviewer" "export PEER_SYNC='$peer_sync'"
    tmux send-keys -t "$session_name:reviewer" C-m
    tmux send-keys -t "$session_name:reviewer" "export MY_NAME='reviewer'"
    tmux send-keys -t "$session_name:reviewer" C-m
    tmux send-keys -t "$session_name:reviewer" "export MY_ROLE='reviewer'"
    tmux send-keys -t "$session_name:reviewer" C-m
    tmux send-keys -t "$session_name:reviewer" "export PEER_NAME='coder'"
    tmux send-keys -t "$session_name:reviewer" C-m
    tmux send-keys -t "$session_name:reviewer" "export FEATURE='$feature'"
    tmux send-keys -t "$session_name:reviewer" C-m
    tmux send-keys -t "$session_name:reviewer" "export WORKTREE='$worktree'"
    tmux send-keys -t "$session_name:reviewer" C-m

    success "Created tmux session: $session_name"
    echo ""
    echo "Windows:"
    echo "  0: orchestrator  - Main project root"
    echo "  1: coder         - $worktree (coder: $coder)"
    echo "  2: reviewer      - $worktree (reviewer: $reviewer)"
    echo ""
    echo "Attach with: tmux attach -t $session_name"
    echo ""
    echo "To start agents, in each window run their CLI:"
    echo "  coder window:    $(get_agent_cmd "$coder" "$codex_thinking")"
    echo "  reviewer window: $(get_agent_cmd "$reviewer" "$codex_thinking")"
    if [ "$clarify_mode" = "true" ]; then
        echo ""
        echo "Clarify stage enabled. After coder submits approach and reviewer comments:"
        echo "  1. Review in .peer-sync/clarify-coder.md and clarify-reviewer.md"
        echo "  2. Respond to agents in their terminals (back-and-forth OK)"
        echo "  3. Press Enter in the orchestrator to proceed"
    fi
    if [ "$pushback_mode" = "true" ]; then
        echo ""
        echo "Pushback stage enabled. After clarify (if enabled), the reviewer will:"
        echo "  1. Propose improvements to the task file"
        echo "  2. You can accept, reject, or modify the pushback"
    fi
}

start_ttyd_mode_solo() {
    local feature="$1"
    local project_root="$2"
    local worktree="$3"
    local peer_sync="$4"
    local auto_run="${5:-false}"
    local work_timeout="${6:-$DEFAULT_WORK_TIMEOUT}"
    local review_timeout="${7:-$DEFAULT_REVIEW_TIMEOUT}"
    local max_rounds="${8:-10}"
    local codex_thinking="${9:-$DEFAULT_CODEX_THINKING}"
    local clarify_mode="${10:-false}"
    local clarify_timeout="${11:-$DEFAULT_CLARIFY_TIMEOUT}"
    local coder="${12:-$DEFAULT_CODER}"
    local reviewer="${13:-$DEFAULT_REVIEWER}"
    local pushback_mode="${14:-false}"
    local pushback_timeout="${15:-$DEFAULT_PUSHBACK_TIMEOUT}"

    local session_name="solo-${feature}"

    # Check ttyd is installed
    command -v ttyd >/dev/null 2>&1 || die "ttyd not found. Install with: brew install ttyd"

    # Kill existing sessions if any
    tmux kill-session -t "${session_name}-orchestrator" 2>/dev/null || true
    tmux kill-session -t "${session_name}-coder" 2>/dev/null || true
    tmux kill-session -t "${session_name}-reviewer" 2>/dev/null || true

    # Create tmux sessions for orchestrator and each agent (both in same worktree)
    tmux new-session -d -s "${session_name}-orchestrator" -c "$project_root"
    tmux new-session -d -s "${session_name}-coder" -c "$worktree"
    tmux new-session -d -s "${session_name}-reviewer" -c "$worktree"

    # Set environment variables for orchestrator
    for var in "PEER_SYNC='$peer_sync'" "FEATURE='$feature'"; do
        tmux send-keys -t "${session_name}-orchestrator" "export $var"
        tmux send-keys -t "${session_name}-orchestrator" C-m
    done

    # Set environment variables for coder
    for var in "PEER_SYNC='$peer_sync'" "MY_NAME='coder'" "MY_ROLE='coder'" "PEER_NAME='reviewer'" "FEATURE='$feature'" "WORKTREE='$worktree'"; do
        tmux send-keys -t "${session_name}-coder" "export $var"
        tmux send-keys -t "${session_name}-coder" C-m
    done

    # Set environment variables for reviewer
    for var in "PEER_SYNC='$peer_sync'" "MY_NAME='reviewer'" "MY_ROLE='reviewer'" "PEER_NAME='coder'" "FEATURE='$feature'" "WORKTREE='$worktree'"; do
        tmux send-keys -t "${session_name}-reviewer" "export $var"
        tmux send-keys -t "${session_name}-reviewer" C-m
    done

    # Allocate and load ports
    allocate_ports_solo "$peer_sync" "$base_port"
    get_ports "$peer_sync"
    local orchestrator_port=$ORCHESTRATOR_PORT
    local coder_port=$CODER_PORT
    local reviewer_port=$REVIEWER_PORT

    ttyd -p "$orchestrator_port" -W tmux attach -t "${session_name}-orchestrator" &
    echo $! > "$peer_sync/pids/ttyd-orchestrator.pid"

    ttyd -p "$coder_port" -W tmux attach -t "${session_name}-coder" &
    echo $! > "$peer_sync/pids/ttyd-coder.pid"

    ttyd -p "$reviewer_port" -W tmux attach -t "${session_name}-reviewer" &
    echo $! > "$peer_sync/pids/ttyd-reviewer.pid"

    success "Started ttyd servers"
    echo ""
    echo "Web terminals:"
    echo "  Orchestrator: http://localhost:$orchestrator_port"
    echo "  Coder ($coder):       http://localhost:$coder_port"
    echo "  Reviewer ($reviewer): http://localhost:$reviewer_port"
    echo ""

    # If auto-run, start the orchestrator loop in the orchestrator session
    if [ "$auto_run" = "true" ]; then
        info "Starting orchestrator with --auto-start..."
        local run_cmd="agent-solo run --auto-start --work-timeout $work_timeout --review-timeout $review_timeout --max-rounds $max_rounds"
        if [ "$clarify_mode" = "true" ]; then
            run_cmd="$run_cmd --clarify-timeout $clarify_timeout"
        fi
        if [ "$pushback_mode" = "true" ]; then
            run_cmd="$run_cmd --pushback-timeout $pushback_timeout"
        fi
        tmux send-keys -t "${session_name}-orchestrator" "$run_cmd"
        tmux send-keys -t "${session_name}-orchestrator" C-m
    else
        echo "Start orchestrator with: agent-solo run --auto-start"
    fi
    echo "Stop with: agent-solo stop"
    if [ "$clarify_mode" = "true" ]; then
        echo ""
        echo "Clarify stage enabled. Coder proposes approach, reviewer comments."
        echo "  1. Review in orchestrator or read .peer-sync/clarify-*.md"
        echo "  2. Respond to agents in their terminals (back-and-forth OK)"
        echo "  3. Press Enter in the orchestrator to proceed"
    fi
    if [ "$pushback_mode" = "true" ]; then
        echo ""
        echo "Pushback stage enabled. After clarify (if enabled), the reviewer will:"
        echo "  1. Propose improvements to the task file"
        echo "  2. You can accept, reject, or modify the pushback"
    fi
}

#------------------------------------------------------------------------------
# Command: stop
#------------------------------------------------------------------------------

cmd_stop() {
    local root
    root="$(get_project_root)"
    local peer_sync="$root/.peer-sync"

    info "Stopping Agent Solo..."

    # Kill ttyd processes from PID files
    if [ -d "$peer_sync/pids" ]; then
        for pidfile in "$peer_sync/pids"/*.pid; do
            [ -f "$pidfile" ] || continue
            local pid
            pid="$(cat "$pidfile")"
            if kill -0 "$pid" 2>/dev/null; then
                kill "$pid" 2>/dev/null || true
                info "Killed process $pid ($(basename "$pidfile" .pid))"
            fi
            rm -f "$pidfile"
        done
    fi

    # Get feature name for session-specific cleanup
    local feature
    feature="$(get_feature 2>/dev/null)" || true

    # Kill tmux sessions for this feature
    if [ -n "$feature" ]; then
        pkill -f "ttyd.*solo-${feature}-" 2>/dev/null && info "Killed remaining ttyd processes for solo-${feature}" || true
        tmux kill-session -t "solo-${feature}" 2>/dev/null && info "Killed tmux session: solo-${feature}" || true
        tmux kill-session -t "solo-${feature}-orchestrator" 2>/dev/null && info "Killed tmux session: solo-${feature}-orchestrator" || true
        tmux kill-session -t "solo-${feature}-coder" 2>/dev/null && info "Killed tmux session: solo-${feature}-coder" || true
        tmux kill-session -t "solo-${feature}-reviewer" 2>/dev/null && info "Killed tmux session: solo-${feature}-reviewer" || true
    fi

    success "Stopped"
}

#------------------------------------------------------------------------------
# Command: restart
#------------------------------------------------------------------------------

cmd_restart() {
    local auto_run=false
    local work_timeout=$DEFAULT_WORK_TIMEOUT
    local review_timeout=$DEFAULT_REVIEW_TIMEOUT
    local clarify_timeout=$DEFAULT_CLARIFY_TIMEOUT
    local pushback_timeout=$DEFAULT_PUSHBACK_TIMEOUT
    local max_rounds=10

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --auto-run) auto_run=true; shift ;;
            --work-timeout) work_timeout="$2"; shift 2 ;;
            --review-timeout) review_timeout="$2"; shift 2 ;;
            --clarify-timeout) clarify_timeout="$2"; shift 2 ;;
            --pushback-timeout) pushback_timeout="$2"; shift 2 ;;
            --max-rounds) max_rounds="$2"; shift 2 ;;
            -*) die "Unknown option: $1" ;;
            *) die "Unknown argument: $1" ;;
        esac
    done

    local root
    root="$(get_project_root 2>/dev/null)" || die "Not in an agent-solo session (no .peer-sync found)"
    local peer_sync="$root/.peer-sync"

    # Check we have an active session
    [ -f "$peer_sync/feature" ] || die "No active session (missing .peer-sync/feature)"
    [ -f "$peer_sync/ports" ] || die "No port allocations found. Was this a ttyd session? Use 'agent-solo run' for tmux mode."

    local feature
    feature="$(get_feature)"
    local project_name
    project_name="$(basename "$root")"
    local parent_dir
    parent_dir="$(dirname "$root")"

    # Calculate worktree path (single shared worktree in solo mode)
    local worktree="$parent_dir/${project_name}-${feature}"
    local session_name="solo-${feature}"

    # Load ports
    get_ports "$peer_sync"
    local orchestrator_port=$ORCHESTRATOR_PORT
    local coder_port=$CODER_PORT
    local reviewer_port=$REVIEWER_PORT

    # Load agent assignments
    local coder_agent reviewer_agent
    coder_agent="$(cat "$peer_sync/coder-agent" 2>/dev/null)" || coder_agent="$DEFAULT_CODER"
    reviewer_agent="$(cat "$peer_sync/reviewer-agent" 2>/dev/null)" || reviewer_agent="$DEFAULT_REVIEWER"

    # Load codex thinking effort
    local codex_thinking
    codex_thinking="$(cat "$peer_sync/codex-thinking" 2>/dev/null)" || codex_thinking="$DEFAULT_CODEX_THINKING"

    echo ""
    echo "=== Agent Solo Restart ==="
    echo ""
    echo "Feature:  $feature"
    echo "Project:  $project_name"
    echo "Coder:    $coder_agent"
    echo "Reviewer: $reviewer_agent"
    echo ""

    # Ensure pids directory exists
    mkdir -p "$peer_sync/pids"

    local errors=0
    local restarted=0

    #---------------------------------------------------------------------------
    # Phase 1: Check and restart tmux sessions
    #---------------------------------------------------------------------------
    info "Checking tmux sessions..."

    # Check orchestrator tmux session
    if ! tmux_session_exists "${session_name}-orchestrator"; then
        info "Creating tmux session: ${session_name}-orchestrator"
        tmux new-session -d -s "${session_name}-orchestrator" -c "$root"
        for var in "PEER_SYNC='$peer_sync'" "FEATURE='$feature'"; do
            tmux send-keys -t "${session_name}-orchestrator" "export $var"
            tmux send-keys -t "${session_name}-orchestrator" C-m
        done
        restarted=$((restarted + 1))
    else
        success "  orchestrator tmux session: OK"
    fi

    # Check coder tmux session
    if ! tmux_session_exists "${session_name}-coder"; then
        if [ ! -d "$worktree" ]; then
            warn "  worktree missing: $worktree"
            errors=$((errors + 1))
        else
            info "Creating tmux session: ${session_name}-coder"
            tmux new-session -d -s "${session_name}-coder" -c "$worktree"
            for var in "PEER_SYNC='$peer_sync'" "MY_NAME='coder'" "MY_ROLE='coder'" "PEER_NAME='reviewer'" "FEATURE='$feature'" "WORKTREE='$worktree'"; do
                tmux send-keys -t "${session_name}-coder" "export $var"
                tmux send-keys -t "${session_name}-coder" C-m
            done
            restarted=$((restarted + 1))
        fi
    else
        success "  coder tmux session: OK"
    fi

    # Check reviewer tmux session
    if ! tmux_session_exists "${session_name}-reviewer"; then
        if [ ! -d "$worktree" ]; then
            warn "  worktree missing: $worktree"
            errors=$((errors + 1))
        else
            info "Creating tmux session: ${session_name}-reviewer"
            tmux new-session -d -s "${session_name}-reviewer" -c "$worktree"
            for var in "PEER_SYNC='$peer_sync'" "MY_NAME='reviewer'" "MY_ROLE='reviewer'" "PEER_NAME='coder'" "FEATURE='$feature'" "WORKTREE='$worktree'"; do
                tmux send-keys -t "${session_name}-reviewer" "export $var"
                tmux send-keys -t "${session_name}-reviewer" C-m
            done
            restarted=$((restarted + 1))
        fi
    else
        success "  reviewer tmux session: OK"
    fi

    #---------------------------------------------------------------------------
    # Phase 2: Check and restart ttyd servers
    #---------------------------------------------------------------------------
    echo ""
    info "Checking ttyd servers..."

    # Check orchestrator ttyd
    if ! restart_ttyd_for_session "orchestrator" "$orchestrator_port" \
            "${session_name}-orchestrator" "$peer_sync/pids/ttyd-orchestrator.pid"; then
        errors=$((errors + 1))
    fi

    # Check coder ttyd
    if ! restart_ttyd_for_session "coder" "$coder_port" \
            "${session_name}-coder" "$peer_sync/pids/ttyd-coder.pid"; then
        errors=$((errors + 1))
    fi

    # Check reviewer ttyd
    if ! restart_ttyd_for_session "reviewer" "$reviewer_port" \
            "${session_name}-reviewer" "$peer_sync/pids/ttyd-reviewer.pid"; then
        errors=$((errors + 1))
    fi

    #---------------------------------------------------------------------------
    # Phase 3: Check and restart agent TUIs
    #---------------------------------------------------------------------------
    echo ""
    info "Checking agent TUIs..."

    # Determine thinking effort for each agent
    local coder_thinking="" reviewer_thinking=""
    [ "$coder_agent" = "codex" ] && coder_thinking="$codex_thinking"
    [ "$reviewer_agent" = "codex" ] && reviewer_thinking="$codex_thinking"

    # Check coder TUI
    if ! restart_agent_tui "$coder_agent" "${session_name}-coder" "$coder_thinking" "coder ($coder_agent)"; then
        errors=$((errors + 1))
    fi

    # Check reviewer TUI
    if ! restart_agent_tui "$reviewer_agent" "${session_name}-reviewer" "$reviewer_thinking" "reviewer ($reviewer_agent)"; then
        errors=$((errors + 1))
    fi

    #---------------------------------------------------------------------------
    # Phase 4: Check orchestration state and optionally restart orchestrator
    #---------------------------------------------------------------------------
    echo ""
    info "Checking orchestration state..."

    local session_state
    session_state="$(cat "$peer_sync/session" 2>/dev/null)" || session_state="unknown"
    local phase
    phase="$(cat "$peer_sync/phase" 2>/dev/null)" || phase="unknown"
    local round
    round="$(cat "$peer_sync/round" 2>/dev/null)" || round="1"

    echo "  Session: $session_state"
    echo "  Phase:   $phase"
    echo "  Round:   $round"

    # Check if PR has been created (terminal state for solo mode)
    local has_pr=false
    [ -f "$peer_sync/coder.pr" ] && has_pr=true

    if [ "$session_state" = "complete" ] || $has_pr; then
        echo ""
        if [ -f "$peer_sync/coder.pr" ]; then
            echo "  PR: $(cat "$peer_sync/coder.pr")"
        fi
        if [ "$auto_run" = "true" ]; then
            info "PR created. Transitioning to pr-comments phase for monitoring..."
            echo "pr-comments" > "$peer_sync/phase"
            echo "active" > "$peer_sync/session"
            local run_cmd="agent-solo run --auto-start --work-timeout $work_timeout --review-timeout $review_timeout --max-rounds $max_rounds"
            run_cmd="$run_cmd --clarify-timeout $clarify_timeout --pushback-timeout $pushback_timeout"
            tmux send-keys -t "${session_name}-orchestrator" "$run_cmd"
            tmux send-keys -t "${session_name}-orchestrator" C-m
            success "Started PR comment monitoring"
        else
            info "PR created. To monitor for PR comments:"
            echo "  agent-solo restart --auto-run"
        fi
    elif [ "$auto_run" = "true" ]; then
        echo ""
        info "Restarting orchestrator loop..."

        # Determine if orchestrator is already running
        local orchestrator_running=false
        if agent_tui_is_running "${session_name}-orchestrator" "orchestrator"; then
            orchestrator_running=true
        fi

        if ! $orchestrator_running; then
            local run_cmd="agent-solo run --auto-start --work-timeout $work_timeout --review-timeout $review_timeout --max-rounds $max_rounds"
            run_cmd="$run_cmd --clarify-timeout $clarify_timeout --pushback-timeout $pushback_timeout"
            tmux send-keys -t "${session_name}-orchestrator" "$run_cmd"
            tmux send-keys -t "${session_name}-orchestrator" C-m
            success "Started orchestrator loop"
        else
            info "Orchestrator appears to already be running"
        fi
    else
        echo ""
        info "Session is not complete. To restart the orchestrator loop:"
        echo "  agent-solo restart --auto-run"
        echo "Or manually in the orchestrator terminal:"
        echo "  agent-solo run --auto-start"
    fi

    #---------------------------------------------------------------------------
    # Summary
    #---------------------------------------------------------------------------
    echo ""
    echo "--- Web Terminals ---"
    echo "Orchestrator: http://localhost:$orchestrator_port"
    echo "Coder ($coder_agent):       http://localhost:$coder_port"
    echo "Reviewer ($reviewer_agent): http://localhost:$reviewer_port"
    echo ""

    if [ "$errors" -gt 0 ]; then
        warn "Restart completed with $errors error(s)"
        return 1
    else
        success "Restart complete!"
        return 0
    fi
}

#------------------------------------------------------------------------------
# Command: status
#------------------------------------------------------------------------------

cmd_status() {
    local root
    root="$(get_project_root 2>/dev/null)" || die "Not in an agent-solo session"
    local peer_sync="$root/.peer-sync"

    echo ""
    echo "=== Agent Solo Status ==="
    echo ""

    if [ -f "$peer_sync/feature" ]; then
        echo "Feature:  $(cat "$peer_sync/feature")"
    fi

    if [ -f "$peer_sync/session" ]; then
        echo "Session:  $(cat "$peer_sync/session")"
    fi

    if [ -f "$peer_sync/phase" ]; then
        echo "Phase:    $(cat "$peer_sync/phase")"
    fi

    if [ -f "$peer_sync/round" ]; then
        echo "Round:    $(cat "$peer_sync/round")"
    fi

    # Show coder/reviewer assignments
    if [ -f "$peer_sync/coder-agent" ]; then
        echo "Coder:    $(cat "$peer_sync/coder-agent")"
    fi
    if [ -f "$peer_sync/reviewer-agent" ]; then
        echo "Reviewer: $(cat "$peer_sync/reviewer-agent")"
    fi

    # Show allocated ports if available
    if [ -f "$peer_sync/ports" ]; then
        # shellcheck source=/dev/null
        source "$peer_sync/ports"
        echo ""
        echo "--- Web Terminals ---"
        echo "Orchestrator: http://localhost:$ORCHESTRATOR_PORT"
        echo "Coder:        http://localhost:$CODER_PORT"
        echo "Reviewer:     http://localhost:$REVIEWER_PORT"
    fi

    echo ""
    echo "--- Agent Status ---"

    for agent in coder reviewer; do
        local status_file="$peer_sync/${agent}.status"
        if [ -f "$status_file" ]; then
            local line
            line="$(cat "$status_file")"
            local status msg timestamp
            status="$(echo "$line" | cut -d'|' -f1)"
            timestamp="$(echo "$line" | cut -d'|' -f2)"
            msg="$(echo "$line" | cut -d'|' -f3-)"

            local time_str=""
            if [ -n "$timestamp" ] && [ "$timestamp" != "$status" ]; then
                time_str=" ($(date -r "$timestamp" '+%H:%M:%S' 2>/dev/null || echo "$timestamp"))"
            fi

            printf "%-10s: %s%s" "$agent" "$status" "$time_str"
            [ -n "$msg" ] && [ "$msg" != "$status" ] && printf " - %s" "$msg"
            echo ""
        else
            echo "$agent:     (no status)"
        fi
    done

    # Check for PR
    echo ""
    echo "--- Pull Request ---"
    if [ -f "$peer_sync/coder.pr" ]; then
        echo "PR: $(cat "$peer_sync/coder.pr")"
    else
        echo "PR: (none)"
    fi

    # List reviews
    if [ -d "$peer_sync/reviews" ] && [ "$(ls -A "$peer_sync/reviews" 2>/dev/null)" ]; then
        echo ""
        echo "--- Reviews ---"
        ls -1 "$peer_sync/reviews"
    fi

    echo ""
}

#------------------------------------------------------------------------------
# Command: run (orchestrator)
#------------------------------------------------------------------------------

# Generate clarify message for coder
generate_coder_clarify_message() {
    local feature="$1"
    local task_content="$2"
    local peer_sync="$3"

    cat <<EOF
# Task: $feature

$task_content

---
## Agent-Solo Context - CLARIFY PHASE (Coder)

You are the **CODER** in a solo workflow. A reviewer will review your code.

**PHASE: CLARIFY** - Before starting implementation, propose your high-level approach and ask clarifying questions.

### Your Task

Produce TWO outputs:

1. **High-level approach** - Not a detailed plan, but a sketch: the key idea, first steps to explore, or general direction
2. **Clarifying questions** - Questions for the user that would help you start more effectively

### Write Your Approach and Questions

\`\`\`bash
cat > "$peer_sync/clarify-coder.md" << 'CLARIFY_EOF'
# Coder's Proposed Approach

## High-Level Approach

[Write 3-5 sentences describing your high-level approach.]

## Questions for the User

1. [Question 1]
2. [Question 2]
3. [Question 3 - optional]

CLARIFY_EOF
\`\`\`

Edit the file with actual content, then signal completion:

\`\`\`bash
agent-solo signal coder clarify-done "approach and questions submitted"
\`\`\`

Then **STOP and wait**. The reviewer will also provide comments, then the user will respond.
Do NOT start implementing until the work phase begins.
EOF
}

# Generate clarify message for reviewer (reviews coder's approach)
generate_reviewer_clarify_message() {
    local feature="$1"
    local task_content="$2"
    local peer_sync="$3"

    cat <<EOF
# Task: $feature

$task_content

---
## Agent-Solo Context - CLARIFY PHASE (Reviewer)

You are the **REVIEWER** in a solo workflow. The coder has proposed an approach.

**PHASE: CLARIFY** - Review the coder's proposed approach and add your own questions or comments.

### Your Task

1. **Read the coder's proposed approach**:
   \`\`\`bash
   cat "$peer_sync/clarify-coder.md"
   \`\`\`

2. **Write your comments and additional questions**:
   \`\`\`bash
   cat > "$peer_sync/clarify-reviewer.md" << 'CLARIFY_EOF'
# Reviewer's Comments

## Comments on Coder's Approach

[What do you think of the proposed approach? Any concerns or suggestions?]

## Additional Questions

1. [Any additional questions you have for the user?]

CLARIFY_EOF
   \`\`\`

Edit the file with actual content, then signal completion:

\`\`\`bash
agent-solo signal reviewer clarify-done "comments submitted"
\`\`\`

Then **STOP and wait**. The user will review both and respond.
EOF
}

# Generate work message for coder (round 1)
generate_coder_work_message() {
    local feature="$1"
    local task_content="$2"
    local peer_sync="$3"
    local round="$4"

    cat <<EOF
# Task: $feature

$task_content

---
## Agent-Solo Context - WORK PHASE (Coder)

You are the **CODER** in a solo workflow. A reviewer will review your code.

- **Phase**: Work (Round $round)
- **Worktree**: Current directory (read/write)
- **Sync directory**: $peer_sync

### Your Goal

Implement the solution. The reviewer will examine your work after you signal done.

### Guidelines

1. Implement your solution following best practices
2. Make sure the code works (run tests if available)
3. If round > 1, check the reviewer's feedback from the previous round:
   \`\`\`bash
   cat "$peer_sync/reviews/round-$((round - 1))-review.md" 2>/dev/null
   \`\`\`

### If You Discover a Blocking Issue

If you find ambiguity, inconsistency, or evidence the task is misguided â€” escalate:
\`\`\`bash
agent-solo escalate ambiguity "requirements unclear: what should happen when X?"
agent-solo escalate inconsistency "docs say X but code does Y"
agent-solo escalate misguided "this feature already exists in module Z"
\`\`\`
This notifies the user without interrupting your work. Continue with your best interpretation.

### When Done

Signal completion and **STOP**:
\`\`\`bash
agent-solo signal coder done "brief summary of what you did"
\`\`\`

The reviewer will then examine your work.

### When Ready for Final PR

When the reviewer approves your solution:
\`\`\`bash
agent-solo pr   # handles commit, push, and PR creation
\`\`\`
EOF
}

# Generate pushback message for reviewer (only reviewer pushes back in solo mode)
generate_solo_pushback_message() {
    local feature="$1"
    local task_content="$2"
    local peer_sync="$3"

    cat <<EOF
# Task: $feature

$task_content

---
## Agent-Solo Context - PUSHBACK STAGE (Reviewer)

You are the **REVIEWER** in a solo workflow. Before the coder starts implementing, you may propose improvements to the task specification.

- **Sync directory**: $peer_sync

### Purpose

The task file may specify both a goal and a plan. Sometimes the plan is suboptimal or could be improved. This is your opportunity to suggest modifications that would lead to a better solution.

### Your Task

Consider:
1. Is the stated plan the best approach to achieve the core goal?
2. Are there better alternatives or optimizations?
3. Are there missing requirements or edge cases?

### Modify the Task File Directly

If you believe the task could be improved, edit \`$feature.md\` directly. The user will compare your version with the original using diff.

If the task is well-specified and needs no changes, skip to writing your rationale.

### Write Your Rationale

\`\`\`bash
cat > "$peer_sync/pushback-reviewer.md" << 'PUSHBACK_EOF'
# Pushback from Reviewer

## Summary of Proposed Changes

[1-3 sentences explaining what you changed and why, or "No changes proposed - the task is well-specified."]

## Reasoning

[Explain why your changes would improve the solution quality, or why the original is already good]

PUSHBACK_EOF
\`\`\`

Edit the file with actual content, then signal completion:

\`\`\`bash
agent-solo signal reviewer pushback-done "proposed task modifications submitted"
\`\`\`

Then **STOP and wait**. The user will review task file changes (via diff) and your rationale, then decide whether to accept or reject.
Do NOT provide implementation guidance yet - wait for the work phase.
EOF
}

cmd_run() {
    local work_timeout=$DEFAULT_WORK_TIMEOUT
    local review_timeout=$DEFAULT_REVIEW_TIMEOUT
    local clarify_timeout=$DEFAULT_CLARIFY_TIMEOUT
    local pushback_timeout=$DEFAULT_PUSHBACK_TIMEOUT
    local poll_interval=$DEFAULT_POLL_INTERVAL
    local max_rounds=10
    local auto_start=false
    local enable_clarify=""
    local enable_pushback=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --work-timeout) work_timeout="$2"; shift 2 ;;
            --review-timeout) review_timeout="$2"; shift 2 ;;
            --clarify-timeout) clarify_timeout="$2"; shift 2 ;;
            --pushback-timeout) pushback_timeout="$2"; shift 2 ;;
            --clarify) enable_clarify="true"; shift ;;
            --pushback) enable_pushback="true"; shift ;;
            --poll) poll_interval="$2"; shift 2 ;;
            --max-rounds) max_rounds="$2"; shift 2 ;;
            --auto-start) auto_start=true; shift ;;
            -*) die "Unknown option: $1" ;;
            *) die "Unknown argument: $1" ;;
        esac
    done

    local root
    root="$(get_project_root)"
    local peer_sync="$root/.peer-sync"
    local feature
    feature="$(get_feature)"

    # Get coder/reviewer agent assignments
    local coder reviewer
    coder="$(cat "$peer_sync/coder-agent" 2>/dev/null)" || coder="$DEFAULT_CODER"
    reviewer="$(cat "$peer_sync/reviewer-agent" 2>/dev/null)" || reviewer="$DEFAULT_REVIEWER"

    # Determine tmux session name
    local session_name="solo-${feature}"

    # Check tmux session exists
    local coder_session reviewer_session
    if tmux has-session -t "${session_name}-coder" 2>/dev/null; then
        coder_session="${session_name}-coder"
        reviewer_session="${session_name}-reviewer"
    elif tmux has-session -t "$session_name" 2>/dev/null; then
        coder_session="${session_name}:coder"
        reviewer_session="${session_name}:reviewer"
    else
        die "No tmux session found. Run 'agent-solo restart' to resume, or 'agent-solo start $feature' to start fresh."
    fi

    echo ""
    echo "=== Agent Solo Orchestrator ==="
    echo "Feature:        $feature"
    echo "Coder:          $coder"
    echo "Reviewer:       $reviewer"
    echo "Work timeout:   ${work_timeout}s"
    echo "Review timeout: ${review_timeout}s"
    echo "Max rounds:     $max_rounds"
    echo ""

    # Calculate worktree path
    local project_name
    project_name="$(basename "$root")"
    local parent_dir
    parent_dir="$(dirname "$root")"
    local worktree="$parent_dir/${project_name}-${feature}"

    # Load codex thinking effort from session
    local codex_thinking
    codex_thinking="$(cat "$peer_sync/codex-thinking" 2>/dev/null)" || codex_thinking="$DEFAULT_CODEX_THINKING"

    # Optionally auto-start agents
    if $auto_start; then
        info "Starting agents..."
        tmux send-keys -t "$coder_session" "$(get_agent_cmd "$coder" "$codex_thinking")"
        tmux send-keys -t "$coder_session" C-m
        tmux send-keys -t "$reviewer_session" "$(get_agent_cmd "$reviewer" "$codex_thinking")"
        tmux send-keys -t "$reviewer_session" C-m
        sleep 3
    fi

    # Check if clarify mode is enabled
    local clarify_mode
    if [ -n "$enable_clarify" ]; then
        clarify_mode="$enable_clarify"
        echo "$enable_clarify" > "$peer_sync/clarify-mode"
    else
        clarify_mode="$(cat "$peer_sync/clarify-mode" 2>/dev/null)" || clarify_mode="false"
    fi

    # Handle clarify phase if enabled and not already confirmed
    if [ "$clarify_mode" = "true" ] && [ ! -f "$peer_sync/clarify-confirmed" ]; then
        info "=== Clarify Phase ==="
        echo "clarify" > "$peer_sync/phase"

        # Read task content
        local task_file
        local task_content=""
        if task_file="$(find_task_file "$root" "$feature")"; then
            task_content="$(cat "$task_file" | head -c 4000)"
        fi

        # Step 1: Coder proposes approach
        atomic_write "$peer_sync/coder.status" "clarifying|$(date +%s)|clarify phase"
        info "Coder: propose your approach..."
        local coder_clarify_msg
        coder_clarify_msg="$(generate_coder_clarify_message "$feature" "$task_content" "$peer_sync")"
        tmux send-keys -t "$coder_session" "$coder_clarify_msg"
        sleep 0.5
        tmux send-keys -t "$coder_session" C-m

        # Wait for coder to complete clarify
        local clarify_start=$SECONDS
        while true; do
            local elapsed=$((SECONDS - clarify_start))
            local coder_status
            coder_status="$(get_agent_status "coder" "$peer_sync")"

            if [ "$coder_status" = "clarify-done" ]; then
                break
            fi

            if [ "$elapsed" -ge "$clarify_timeout" ]; then
                warn "Coder clarify timeout (${clarify_timeout}s)"
                break
            fi

            printf "\r  Waiting for coder... status=%s (%ds/%ds)  " "$coder_status" "$elapsed" "$clarify_timeout"
            sleep "$poll_interval"
        done
        echo ""

        # Step 2: Reviewer reviews coder's approach and adds comments
        atomic_write "$peer_sync/reviewer.status" "clarifying|$(date +%s)|reviewing approach"
        info "Reviewer: review approach and add comments..."
        local reviewer_clarify_msg
        reviewer_clarify_msg="$(generate_reviewer_clarify_message "$feature" "$task_content" "$peer_sync")"
        tmux send-keys -t "$reviewer_session" "$reviewer_clarify_msg"
        sleep 0.5
        tmux send-keys -t "$reviewer_session" C-m

        # Wait for reviewer to complete clarify
        clarify_start=$SECONDS
        while true; do
            local elapsed=$((SECONDS - clarify_start))
            local reviewer_status
            reviewer_status="$(get_agent_status "reviewer" "$peer_sync")"

            if [ "$reviewer_status" = "clarify-done" ]; then
                break
            fi

            if [ "$elapsed" -ge "$clarify_timeout" ]; then
                warn "Reviewer clarify timeout (${clarify_timeout}s)"
                break
            fi

            printf "\r  Waiting for reviewer... status=%s (%ds/%ds)  " "$reviewer_status" "$elapsed" "$clarify_timeout"
            sleep "$poll_interval"
        done
        echo ""

        # Send notification (ntfy and/or email)
        send_clarify_notification "$peer_sync" "$feature" "solo"

        # Display clarify results
        echo ""
        info "=== Clarify Phase Results ==="
        echo ""

        if [ -f "$peer_sync/clarify-coder.md" ]; then
            echo "--- Coder's Approach ---"
            cat "$peer_sync/clarify-coder.md"
            echo ""
        else
            warn "Coder did not submit a clarification"
        fi

        if [ -f "$peer_sync/clarify-reviewer.md" ]; then
            echo "--- Reviewer's Comments ---"
            cat "$peer_sync/clarify-reviewer.md"
            echo ""
        else
            warn "Reviewer did not submit comments"
        fi

        echo ""
        echo "=================================="
        echo ""
        info "Respond to agents in their terminals if needed."
        echo ""
        read -r -p "Press Enter when ready to proceed... "

        # Mark clarify as confirmed
        echo "confirmed" > "$peer_sync/clarify-confirmed"

        success "Clarify stage confirmed!"
        echo ""
    fi

    # Check if pushback mode is enabled (command line overrides session setting)
    local pushback_mode
    if [ -n "$enable_pushback" ]; then
        pushback_mode="$enable_pushback"
        echo "$enable_pushback" > "$peer_sync/pushback-mode"
    else
        pushback_mode="$(cat "$peer_sync/pushback-mode" 2>/dev/null)" || pushback_mode="false"
    fi

    # Handle pushback stage if enabled and not already confirmed
    # In solo mode, only the reviewer pushes back
    if [ "$pushback_mode" = "true" ] && [ ! -f "$peer_sync/pushback-confirmed" ]; then
        info "=== Pushback Stage ==="
        echo "pushback" > "$peer_sync/phase"

        # Find task file
        local task_file
        local task_content=""
        if task_file="$(find_task_file "$root" "$feature")"; then
            task_content="$(cat "$task_file" | head -c 4000)"
        fi
        local task_basename="${feature}.md"

        # Only reviewer pushes back in solo mode
        atomic_write "$peer_sync/coder.status" "waiting|$(date +%s)|waiting for reviewer pushback"
        atomic_write "$peer_sync/reviewer.status" "pushing-back|$(date +%s)|pushback stage"
        info "Sending pushback task to reviewer..."
        local reviewer_pushback_msg
        reviewer_pushback_msg="$(generate_solo_pushback_message "$feature" "$task_content" "$peer_sync")"
        tmux send-keys -t "$reviewer_session" "$reviewer_pushback_msg"
        sleep 0.5
        tmux send-keys -t "$reviewer_session" C-m

        # Wait for reviewer to complete pushback stage
        local pushback_start=$SECONDS
        local reviewer_pushback_done=false

        while ! $reviewer_pushback_done; do
            local elapsed=$((SECONDS - pushback_start))

            # Check for completion
            local reviewer_status
            reviewer_status="$(get_agent_status "reviewer" "$peer_sync")"

            [ "$reviewer_status" = "pushback-done" ] && reviewer_pushback_done=true

            if $reviewer_pushback_done; then
                break
            fi

            # Check timeout
            if [ "$elapsed" -ge "$pushback_timeout" ]; then
                warn "Pushback stage timeout (${pushback_timeout}s)"
                break
            fi

            printf "\r  Waiting... reviewer=%s (%ds/%ds)  " "$reviewer_status" "$elapsed" "$pushback_timeout"
            sleep "$poll_interval"
        done
        echo ""

        # Send notification with pushback results
        send_pushback_notification "$peer_sync" "$feature" "solo"

        # Display pushback results
        echo ""
        info "=== Pushback Stage Results ==="
        echo ""

        if [ -f "$peer_sync/pushback-reviewer.md" ]; then
            echo "--- Reviewer's Pushback ---"
            cat "$peer_sync/pushback-reviewer.md"
            echo ""
        else
            warn "Reviewer did not submit a pushback"
        fi

        echo ""
        echo "=================================="
        echo ""
        info "Options:"
        echo "  [Enter] - Reject pushback, proceed with original task"
        echo "  [a]     - Accept the pushback"
        echo ""
        read -r -p "Your choice: " pushback_choice

        case "$pushback_choice" in
            a|A)
                # Accept: keep the modified task file as-is
                info "Accepting reviewer's pushback (keeping modified task file)..."
                echo "reviewer" > "$peer_sync/pushback-accepted"
                ;;
            *)
                # Reject: restore original task file from project root
                info "Rejecting pushback, restoring original task..."
                if [ -f "$root/$task_basename" ]; then
                    cp "$root/$task_basename" "$worktree/$task_basename"
                    success "Restored original task file"
                else
                    warn "Original task file not found in project root"
                fi
                echo "rejected" > "$peer_sync/pushback-accepted"
                ;;
        esac

        # Mark pushback as confirmed
        echo "confirmed" > "$peer_sync/pushback-confirmed"
        echo "work" > "$peer_sync/phase"

        success "Pushback stage complete! Proceeding to work phase..."
        echo ""
    fi

    # Set phase to work if not already set
    if [ "$(cat "$peer_sync/phase" 2>/dev/null)" != "work" ]; then
        echo "work" > "$peer_sync/phase"
    fi

    # Main loop: Sequential work/review
    local round=1

    while [ "$round" -le "$max_rounds" ]; do
        # Check if session is complete
        if [ "$(cat "$peer_sync/session" 2>/dev/null)" = "complete" ]; then
            success "Session complete!"
            break
        fi

        # Check if PR was created
        if has_pr "coder" "$peer_sync"; then
            echo "complete" > "$peer_sync/session"
            success "PR created - session complete!"
            echo ""
            echo "PR: $(cat "$peer_sync/coder.pr")"
            break
        fi

        echo ""
        info "=== Round $round: Coder Work Phase ==="
        echo "$round" > "$peer_sync/round"
        echo "work" > "$peer_sync/phase"

        # Trigger work phase for coder
        atomic_write "$peer_sync/coder.status" "working|$(date +%s)|round $round work phase"
        atomic_write "$peer_sync/reviewer.status" "waiting|$(date +%s)|waiting for coder"

        if [ "$round" -eq 1 ]; then
            # Round 1: Send full context message
            local task_file
            local task_content=""
            if task_file="$(find_task_file "$root" "$feature")"; then
                task_content="$(cat "$task_file" | head -c 4000)"
            fi

            info "Sending task to coder..."
            local coder_msg
            coder_msg="$(generate_coder_work_message "$feature" "$task_content" "$peer_sync" "$round")"
            tmux send-keys -t "$coder_session" "$coder_msg"
            sleep 0.5
            tmux send-keys -t "$coder_session" C-m
        else
            # Round 2+: Trigger skill
            info "Triggering solo-coder-work for coder..."
            trigger_skill "$coder" "$coder_session" "solo-coder-work"
        fi

        # Wait for coder to complete work
        local work_start=$SECONDS
        while true; do
            local elapsed=$((SECONDS - work_start))
            local coder_status
            coder_status="$(get_agent_status "coder" "$peer_sync")"

            # Accept done or pr-created
            if [[ "$coder_status" =~ ^(done|pr-created)$ ]]; then
                break
            fi

            # Check for PR created mid-phase
            if has_pr "coder" "$peer_sync"; then
                break
            fi

            # Check timeout
            if [ "$elapsed" -ge "$work_timeout" ]; then
                warn "Work phase timeout (${work_timeout}s)"
                interrupt_agent "coder" "$coder_session" "$peer_sync"
                break
            fi

            printf "\r  Waiting for coder... status=%s (%ds/%ds)  " "$coder_status" "$elapsed" "$work_timeout"
            sleep "$poll_interval"
        done
        echo ""

        # Check if PR was created during work
        if has_pr "coder" "$peer_sync"; then
            echo "complete" > "$peer_sync/session"
            success "PR created - session complete!"
            echo ""
            echo "PR: $(cat "$peer_sync/coder.pr")"
            break
        fi

        # Check for escalations before transitioning to review phase
        # If user chooses to defer, escalations remain but we continue to review phase
        # They'll be checked again at the next phase boundary
        if has_pending_escalations "$peer_sync" >/dev/null; then
            handle_escalation_block "$peer_sync" "$feature" "solo" || true
        fi

        # Review phase
        info "=== Round $round: Review Phase ==="
        echo "review" > "$peer_sync/phase"

        atomic_write "$peer_sync/reviewer.status" "reviewing|$(date +%s)|round $round review phase"
        atomic_write "$peer_sync/coder.status" "waiting|$(date +%s)|waiting for review"

        info "Triggering solo-reviewer-work for reviewer..."
        trigger_skill "$reviewer" "$reviewer_session" "solo-reviewer-work"

        # Wait for reviewer to complete review
        local review_start=$SECONDS
        while true; do
            local elapsed=$((SECONDS - review_start))
            local reviewer_status
            reviewer_status="$(get_agent_status "reviewer" "$peer_sync")"

            # Accept review-done or done
            if [[ "$reviewer_status" =~ ^(done|review-done)$ ]]; then
                break
            fi

            # Check timeout
            if [ "$elapsed" -ge "$review_timeout" ]; then
                warn "Review phase timeout (${review_timeout}s)"
                interrupt_agent "reviewer" "$reviewer_session" "$peer_sync"
                break
            fi

            printf "\r  Waiting for reviewer... status=%s (%ds/%ds)  " "$reviewer_status" "$elapsed" "$review_timeout"
            sleep "$poll_interval"
        done
        echo ""

        # Check review verdict
        local review_file="$peer_sync/reviews/round-${round}-review.md"
        if [ -f "$review_file" ]; then
            if grep -qi "APPROVE" "$review_file" 2>/dev/null; then
                success "Reviewer approved! Ready for PR."
                info "Coder can now create PR with: agent-solo pr"
                # Continue loop to let coder create PR
            else
                info "Reviewer requested changes. Proceeding to next round."
            fi
        fi

        # Check for escalations before transitioning to next work round
        # If user chooses to defer, escalations remain but we continue to next round
        # They'll be checked again at the next phase boundary
        if has_pending_escalations "$peer_sync" >/dev/null; then
            handle_escalation_block "$peer_sync" "$feature" "solo" || true
        fi

        round=$((round + 1))
    done

    if [ "$round" -gt "$max_rounds" ]; then
        warn "Reached max rounds ($max_rounds)"
    fi

    # PR Comment Watch Phase
    # After PR is created and approved, monitor for new comments/reviews
    # This also works for backward compatibility: running on old sessions with PRs
    if has_pr "coder" "$peer_sync"; then
        local pr_url
        pr_url="$(cat "$peer_sync/coder.pr")"

        # Check if PR is already closed/merged before entering watch phase
        if ! is_pr_open "$pr_url"; then
            info "PR is already closed/merged. Skipping PR watch phase."
        else
            echo ""
            info "=== PR Comment Watch Phase ==="
            echo "pr-comments" > "$peer_sync/phase"

            echo "Monitoring PR for new comments..."
            echo "  PR: $pr_url"
            echo ""
            echo "Press Ctrl-C to stop watching."
            echo ""

            # Check if this is first entry to PR comment phase (no hash file yet)
            # If so, assume existing comments/reviews need to be processed
            local first_entry=false
            if [ ! -f "$peer_sync/coder.pr-hash" ]; then
                first_entry=true
                get_pr_comment_hash "$pr_url" > "$peer_sync/coder.pr-hash" 2>/dev/null || true
            fi

            while true; do
                # Check if PR is closed/merged
                if ! is_pr_open "$pr_url"; then
                    success "PR is closed/merged. Session complete!"
                    break
                fi

                # Check for new comments
                # On first entry, trigger if PR has any reviews to process
                local needs_attention=false
                if $first_entry; then
                    # First entry: check if PR has any reviews to process
                    local pr_hash
                    pr_hash="$(cat "$peer_sync/coder.pr-hash" 2>/dev/null)" || pr_hash=""
                    local review_count="${pr_hash#*|}"  # remove comment count
                    review_count="${review_count%%|*}"  # extract review count
                    if [ -n "$review_count" ] && [ "$review_count" != "0" ]; then
                        needs_attention=true
                        info "PR has $review_count review(s) to process"
                    fi
                    first_entry=false
                elif pr_has_new_comments "coder" "$peer_sync"; then
                    needs_attention=true
                    info "New comments on PR!"
                    send_pr_comment_notification "coder" "$feature" "$pr_url" "solo"
                fi

                if $needs_attention; then

                    # Trigger pr-comment skill for coder
                    check_tui_health "$coder" "$coder_session" "$peer_sync" "$tui_exit_behavior"
                    atomic_write "$peer_sync/coder.status" "working|$(date +%s)|addressing PR comments"
                    info "Triggering solo-pr-comment for coder..."
                    trigger_skill "$coder" "$coder_session" "solo-pr-comment"

                    # Wait for coder to finish
                    local pr_watch_start=$SECONDS
                    while true; do
                        local elapsed=$((SECONDS - pr_watch_start))
                        local coder_status
                        coder_status="$(get_agent_status "coder" "$peer_sync")"

                        # Check for completion
                        if [[ "$coder_status" =~ ^(done|pr-created)$ ]]; then
                            break
                        fi

                        # Check timeout
                        if [ "$elapsed" -ge "$DEFAULT_PR_WATCH_TIMEOUT" ]; then
                            warn "PR comment response timeout (${DEFAULT_PR_WATCH_TIMEOUT}s)"
                            break
                        fi

                        printf "\r  Waiting for coder... status=%s (%ds)  " "$coder_status" "$elapsed"
                        sleep "$poll_interval"
                    done
                    echo ""
                fi

                # Poll interval before next check
                printf "\r  Watching for PR comments... (Ctrl-C to stop)  "
                sleep "$poll_interval"
            done
        fi
    fi

    echo ""
    info "=== Final Status ==="
    cmd_status
}

#------------------------------------------------------------------------------
# Command: pr
#------------------------------------------------------------------------------

cmd_pr() {
    local root
    root="$(get_project_root)"
    local peer_sync="$root/.peer-sync"
    local feature
    feature="$(get_feature)"

    # Determine worktree
    local project_name
    project_name="$(basename "$root")"
    local parent_dir
    parent_dir="$(dirname "$root")"
    local worktree="$parent_dir/${project_name}-${feature}"

    [ -d "$worktree" ] || die "Worktree not found: $worktree"

    info "Creating PR for coder's solution..."

    cd "$worktree"

    # Check if feature file exists and was NOT modified (should be deleted)
    local feature_file="$worktree/${feature}.md"
    if [ -f "$feature_file" ]; then
        local main_branch
        main_branch="$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@')" || true
        if [ -z "$main_branch" ]; then
            for candidate in main master; do
                if git rev-parse --verify "$candidate" >/dev/null 2>&1; then
                    main_branch="$candidate"
                    break
                fi
            done
        fi
        if [ -z "$main_branch" ]; then
            main_branch="HEAD~1"
        fi

        local file_modified=false
        if git show "${main_branch}:${feature}.md" >/dev/null 2>&1; then
            if ! git diff --quiet "${main_branch}" -- "${feature}.md" 2>/dev/null; then
                file_modified=true
            fi
        else
            local original_task_file
            if original_task_file="$(find_task_file "$root" "$feature")"; then
                if ! diff -q "$feature_file" "$original_task_file" >/dev/null 2>&1; then
                    file_modified=true
                fi
            fi
        fi

        if [ "$file_modified" = "false" ]; then
            info "Feature file ${feature}.md was not modified - removing it"
            git rm "${feature}.md"
            git commit -m "Remove unmodified feature file ${feature}.md"
        fi
    fi

    # Check for changes
    if [ -z "$(git status --porcelain)" ]; then
        warn "No changes to commit"
    else
        # Auto-commit changes
        git add -A
        git commit -m "Solution for $feature" || true
    fi

    # Push branch
    local branch="${feature}"
    git push -u origin "$branch" 2>/dev/null || git push origin "$branch"

    # Look for PR body file
    local pr_body=""
    local pr_body_file="$root/${feature}-PR.md"
    if [ -f "$pr_body_file" ]; then
        pr_body="$(cat "$pr_body_file")"
    else
        pr_body="Solution for feature: $feature"
    fi

    # Create PR
    local pr_url
    pr_url="$(gh pr create --title "Solution for $feature" --body "$pr_body" --head "$branch" 2>/dev/null)" || \
        pr_url="$(gh pr view --json url -q '.url' 2>/dev/null)" || \
        die "Failed to create PR. Is gh installed and authenticated?"

    # Record PR
    echo "$pr_url" > "$peer_sync/coder.pr"
    atomic_write "$peer_sync/coder.status" "pr-created|$(date +%s)|$pr_url"

    success "PR created: $pr_url"

    # Send notification
    send_pr_notification "coder" "$feature" "$pr_url" "solo"

    # Mark session complete
    echo "complete" > "$peer_sync/session"
    success "Session complete!"
}

#------------------------------------------------------------------------------
# Command: cleanup
#------------------------------------------------------------------------------

cmd_cleanup() {
    local full=false
    [ "$1" = "--full" ] && full=true

    local root
    root="$(get_project_root)"
    local peer_sync="$root/.peer-sync"
    local feature
    feature="$(get_feature)"
    local project_name
    project_name="$(basename "$root")"
    local parent_dir
    parent_dir="$(dirname "$root")"

    info "Cleaning up session: $feature"

    # Stop any running processes first
    cmd_stop

    # Always remove session state (.peer-sync)
    rm -rf "$peer_sync"
    info "Removed .peer-sync"

    if $full; then
        # Remove worktree
        local worktree="$parent_dir/${project_name}-${feature}"

        cd "$root"  # Make sure we're not in a worktree

        if [ -d "$worktree" ]; then
            git worktree remove --force "$worktree" 2>/dev/null || rm -rf "$worktree"
            info "Removed worktree: $worktree"
        fi

        # Prune worktree references
        git worktree prune

        # Delete branch
        git branch -D "${feature}" 2>/dev/null && info "Deleted branch: ${feature}" || true
    fi

    success "Cleanup complete"
}

#------------------------------------------------------------------------------
# Command: confirm
#------------------------------------------------------------------------------

cmd_confirm() {
    local root
    root="$(get_project_root)"
    local peer_sync="$root/.peer-sync"

    local phase
    phase="$(cat "$peer_sync/phase" 2>/dev/null)" || die "No active session"

    if [ "$phase" != "clarify" ]; then
        if [ -f "$peer_sync/clarify-confirmed" ]; then
            info "Clarify phase already confirmed."
        else
            die "Not in clarify phase (current phase: $phase)"
        fi
        return 0
    fi

    echo "confirmed" > "$peer_sync/clarify-confirmed"
    echo "work" > "$peer_sync/phase"

    success "Clarify phase confirmed! Transitioning to work phase."
    echo "Note: If orchestrator is waiting for input, press Enter there to continue."
}

#------------------------------------------------------------------------------
# Command: escalate (for agents to flag issues needing user input)
#------------------------------------------------------------------------------

cmd_escalate() {
    lib_cmd_escalate "$@"
}

#------------------------------------------------------------------------------
# Command: escalate-resolve (user resolves an escalation)
#------------------------------------------------------------------------------

cmd_escalate_resolve() {
    local root
    root="$(get_project_root)"
    local peer_sync="$root/.peer-sync"

    # Find pending escalations
    local escalations=()
    for f in "$peer_sync"/escalation-*.md; do
        [ -f "$f" ] && escalations+=("$f")
    done

    if [ ${#escalations[@]} -eq 0 ]; then
        info "No pending escalations."
        return 0
    fi

    # Display all escalations
    echo ""
    info "=== Pending Escalations ==="
    echo ""
    for f in "${escalations[@]}"; do
        cat "$f"
        echo ""
        echo "---"
        echo ""
    done

    # Prompt for resolution
    echo "Options:"
    echo "  1. Resolve all escalations (agents will continue normally)"
    echo "  2. Cancel (keep escalations pending)"
    echo ""
    read -r -p "Choice [1/2]: " choice

    case "$choice" in
        1)
            # Remove escalation files
            for f in "${escalations[@]}"; do
                rm -f "$f"
            done

            # Mark escalations as resolved
            echo "resolved|$(date +%s)" > "$peer_sync/escalation-resolved"

            success "Escalations resolved. Orchestrator will continue."
            echo "Note: If orchestrator is waiting, press Enter there to continue."
            ;;
        2|*)
            info "Escalations remain pending."
            ;;
    esac
}

#------------------------------------------------------------------------------
# Command: signal (for agents)
#------------------------------------------------------------------------------

cmd_signal() {
    lib_cmd_signal "$@"
}

#------------------------------------------------------------------------------
# Command: peer-status (for agents)
#------------------------------------------------------------------------------

cmd_peer_status() {
    lib_cmd_peer_status
}

#------------------------------------------------------------------------------
# Command: phase (for agents)
#------------------------------------------------------------------------------

cmd_phase() {
    lib_cmd_phase
}

#------------------------------------------------------------------------------
# Command: nudge
#------------------------------------------------------------------------------

cmd_nudge() {
    local agent="$1"
    local message="${2:-Continue.}"

    [ -z "$agent" ] && die "Usage: agent-solo nudge <agent> [message]"
    [[ "$agent" =~ ^(coder|reviewer)$ ]] || die "Agent must be 'coder' or 'reviewer'"

    local root
    root="$(get_project_root)"
    local feature
    feature="$(get_feature)"
    local session_name="solo-${feature}"

    # Determine session target
    local session
    if tmux has-session -t "$session_name" 2>/dev/null; then
        session="${session_name}:${agent}"
    elif tmux has-session -t "${session_name}-${agent}" 2>/dev/null; then
        session="${session_name}-${agent}"
    else
        die "No tmux session found for $agent. Run 'agent-solo restart' first."
    fi

    nudge_agent "$agent" "$session" "$message"
    success "Nudged $agent"
}

#------------------------------------------------------------------------------
# Command: interrupt
#------------------------------------------------------------------------------

cmd_interrupt() {
    local agent="$1"

    [ -z "$agent" ] && die "Usage: agent-solo interrupt <agent>"
    [[ "$agent" =~ ^(coder|reviewer)$ ]] || die "Agent must be 'coder' or 'reviewer'"

    local root
    root="$(get_project_root)"
    local peer_sync="$root/.peer-sync"
    local feature
    feature="$(get_feature)"
    local session_name="solo-${feature}"

    # Determine session target
    local session
    if tmux has-session -t "$session_name" 2>/dev/null; then
        session="${session_name}:${agent}"
    elif tmux has-session -t "${session_name}-${agent}" 2>/dev/null; then
        session="${session_name}-${agent}"
    else
        die "No tmux session found for $agent. Run 'agent-solo restart' first."
    fi

    interrupt_agent "$agent" "$session" "$peer_sync"
    success "Interrupted $agent"
}

#------------------------------------------------------------------------------
# Command: help
#------------------------------------------------------------------------------

cmd_help() {
    cat << 'EOF'
Agent Solo - Coder/Reviewer AI Workflow

USAGE
    agent-solo <command> [options]

SESSION COMMANDS
    start <feature> [options]
        Start a new session for the given feature.
        Creates one shared worktree, two tmux sessions (coder + reviewer), and ttyd web terminals.

        Options:
          --coder <agent>        Agent for coding (default: claude)
          --reviewer <agent>     Agent for reviewing (default: codex)
          --auto-run             Start orchestrator immediately
          --no-ttyd              Use single tmux session instead of web terminals
          --clarify              Enable clarify stage before work starts
          --pushback             Enable pushback stage (reviewer proposes task improvements)
          --work-timeout <secs>  Work phase timeout (default: 1200)
          --review-timeout <secs> Review phase timeout (default: 600)
          --clarify-timeout <secs> Clarify stage timeout (default: 600)
          --pushback-timeout <secs> Pushback stage timeout (default: 600)
          --max-rounds <n>       Maximum rounds (default: 10)
          --codex-thinking <level> Codex reasoning effort: low, medium, high (default: high)
          --codex-model <model>  GPT model for Codex (e.g., o3, gpt-4.1)
          --claude-model <model> Claude model (e.g., opus, sonnet)
          --port <port>          Base port for web terminals (uses 3 consecutive ports)
                                 If not specified, finds first available consecutive ports.
                                 Fails if any of the 3 ports are occupied.

    run [options]
        Run the orchestrator loop (coder work -> reviewer review -> repeat).

        Options:
          --clarify              Enable clarify stage
          --pushback             Enable pushback stage (reviewer proposes task improvements)
          --work-timeout <secs>  Work phase timeout (default: 1200)
          --review-timeout <secs> Review phase timeout (default: 600)
          --clarify-timeout <secs> Clarify stage timeout (default: 600)
          --pushback-timeout <secs> Pushback stage timeout (default: 600)
          --poll <secs>          Status poll interval (default: 10)
          --max-rounds <n>       Maximum rounds (default: 10)
          --auto-start           Auto-launch agent CLIs and send task

    stop
        Stop ttyd servers and tmux sessions, keep worktree.

    restart [options]
        Restart a ttyd session after a system restart or if terminals crash.
        Checks and recreates tmux sessions, ttyd servers, and agent TUIs.

        Options:
          --auto-run             Restart the orchestrator loop automatically
          --work-timeout <secs>  Work phase timeout (default: 1200)
          --review-timeout <secs> Review phase timeout (default: 600)
          --clarify-timeout <secs> Clarify stage timeout (default: 600)
          --pushback-timeout <secs> Pushback stage timeout (default: 600)
          --max-rounds <n>       Maximum rounds (default: 10)

    status
        Show current session state and agent statuses.

    confirm
        Confirm the clarify phase is complete and proceed to work phase.

    escalate-resolve
        Review and resolve pending escalations from agents.
        Escalations block phase transitions until resolved.

    pr
        Create a PR for the coder's solution.
        Auto-commits uncommitted changes and pushes.

    cleanup [--full]
        Remove session state (.peer-sync). With --full, also removes
        worktree and deletes the feature branch.

    setup
        Install agent-solo to ~/.local/bin and skills to agent dirs.

CONTROL COMMANDS
    nudge <agent> [message]
        Send a message to an agent's terminal (coder or reviewer).
        Default message: "Continue."

    interrupt <agent>
        Send Escape to interrupt an agent.

AGENT COMMANDS (used by AI agents)
    signal <agent> <status> [message]
        Signal a status change. Agent is 'coder' or 'reviewer'.
        Status values: clarifying, clarify-done, working, done,
        reviewing, review-done, interrupted, error, pr-created, escalated

    peer-status
        Read peer's current status (requires PEER_NAME env var).

    phase
        Read current phase (clarify, work, or review).

    escalate <reason> [message]
        Escalate an issue requiring user input. Does not interrupt the agent.
        The orchestrator will block phase transitions until user resolves.

        Reasons:
          ambiguity     - Requirements are unclear
          inconsistency - Conflicting requirements or code/docs mismatch
          misguided     - Evidence the task approach is wrong

WORKFLOW
    Solo mode uses a sequential workflow:

    CLARIFY PHASE (if --clarify):
      1. Coder proposes approach and questions
      2. Reviewer reviews approach and adds comments
      3. User responds, then confirms

    WORK/REVIEW LOOP:
      1. Coder implements solution
      2. Coder signals "done"
      3. Reviewer examines code (git diff, etc.)
      4. Reviewer writes review with verdict (APPROVE or REQUEST_CHANGES)
      5. If approved: coder creates PR
      6. If changes requested: loop back to step 1

EXAMPLES
    # Start with auto-run (opens 3 web terminals, starts everything)
    agent-solo start auth --auto-run

    # With clarify phase
    agent-solo start auth --auto-run --clarify

    # Swap agent roles (codex codes, claude reviews)
    agent-solo start auth --coder codex --reviewer claude

    # Check status
    agent-solo status

    # Create PR when reviewer approves
    agent-solo pr

    # Clean up
    agent-solo cleanup --full
EOF
}

#------------------------------------------------------------------------------
# Main
#------------------------------------------------------------------------------

main() {
    local cmd="${1:-help}"
    shift || true

    case "$cmd" in
        start)       cmd_start "$@" ;;
        run)         cmd_run "$@" ;;
        stop)        cmd_stop "$@" ;;
        restart)     cmd_restart "$@" ;;
        status)      cmd_status "$@" ;;
        confirm)     cmd_confirm "$@" ;;
        escalate)    cmd_escalate "$@" ;;
        escalate-resolve) cmd_escalate_resolve "$@" ;;
        pr)          cmd_pr "$@" ;;
        cleanup)     cmd_cleanup "$@" ;;
        setup)       cmd_setup "$@" ;;
        nudge)       cmd_nudge "$@" ;;
        interrupt)   cmd_interrupt "$@" ;;
        signal)      cmd_signal "$@" ;;
        peer-status) cmd_peer_status "$@" ;;
        phase)       cmd_phase "$@" ;;
        help|--help|-h) cmd_help ;;
        *)           die "Unknown command: $cmd (try 'agent-solo help')" ;;
    esac
}

main "$@"
