#!/usr/bin/env bash
# agent-duo - Unified CLI for coordinating two AI agents
# Usage: agent-duo <command> [options]
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PEER_SYNC="$SCRIPT_DIR/.peer-sync"

# Configuration
CLAUDE_BRANCH="claude-work"
CODEX_BRANCH="codex-work"
TTYD_PORT_CLAUDE=7681
TTYD_PORT_CODEX=7682
MAX_TURNS=3
WORK_TIMEOUT=600
REVIEW_TIMEOUT=300
POLL_INTERVAL=5

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

log_info() { echo -e "${GREEN}[agent-duo]${NC} $1"; }
log_warn() { echo -e "${YELLOW}[agent-duo]${NC} $1"; }
log_error() { echo -e "${RED}[agent-duo]${NC} $1"; }
log_phase() { echo -e "${CYAN}[agent-duo]${NC} ========== $1 =========="; }

# ============================================================================
# Atomic locking (adopted from Codex's approach)
# ============================================================================
LOCK_DIR="$PEER_SYNC/.lock"

acquire_lock() {
    local max_attempts=100
    local attempt=0
    while ! mkdir "$LOCK_DIR" 2>/dev/null; do
        attempt=$((attempt + 1))
        if [[ $attempt -ge $max_attempts ]]; then
            log_error "Failed to acquire lock after $max_attempts attempts"
            return 1
        fi
        sleep 0.05
    done
}

release_lock() {
    rmdir "$LOCK_DIR" 2>/dev/null || true
}

with_lock() {
    acquire_lock
    "$@"
    local rc=$?
    release_lock
    return $rc
}

# ============================================================================
# Status management (improved with epoch timestamps)
# ============================================================================
# Status format: STATE|EPOCH|MESSAGE
# Example: WORKING|1705847123|implementing feature X

write_status() {
    local agent="$1"
    local state="$2"
    local message="${3:-}"
    local epoch=$(date +%s)

    with_lock echo "${state}|${epoch}|${message}" > "$PEER_SYNC/${agent}.status"
    log_info "$agent: $state${message:+ ($message)}"
}

read_status() {
    local agent="$1"
    local status_file="$PEER_SYNC/${agent}.status"
    if [[ -f "$status_file" ]]; then
        cat "$status_file"
    else
        echo "UNKNOWN|0|"
    fi
}

get_state() {
    local agent="$1"
    read_status "$agent" | cut -d'|' -f1
}

get_epoch() {
    local agent="$1"
    read_status "$agent" | cut -d'|' -f2
}

# ============================================================================
# Worktree management
# ============================================================================
get_worktree_path() {
    local agent="$1"
    echo "$SCRIPT_DIR/../agent-duo-${agent}"
}

cmd_setup() {
    log_info "Setting up worktrees..."
    cd "$SCRIPT_DIR"

    local claude_wt=$(get_worktree_path "claude")
    local codex_wt=$(get_worktree_path "codex")

    # Remove existing worktrees
    for wt in "$claude_wt" "$codex_wt"; do
        if [[ -d "$wt" ]]; then
            git worktree remove --force "$wt" 2>/dev/null || rm -rf "$wt"
        fi
    done

    # Ensure branches exist
    git branch "$CLAUDE_BRANCH" 2>/dev/null || true
    git branch "$CODEX_BRANCH" 2>/dev/null || true

    # Create worktrees
    git worktree add "$claude_wt" "$CLAUDE_BRANCH"
    git worktree add "$codex_wt" "$CODEX_BRANCH"

    # Initialize peer-sync (remove stale lock directory if present)
    mkdir -p "$PEER_SYNC/rounds"
    rm -f "$PEER_SYNC"/*.status 2>/dev/null || true
    rm -rf "$PEER_SYNC/.lock" 2>/dev/null || true

    # Symlink .peer-sync to worktrees
    ln -sf "$PEER_SYNC" "$claude_wt/.peer-sync"
    ln -sf "$PEER_SYNC" "$codex_wt/.peer-sync"

    # Store paths
    echo "$claude_wt" > "$PEER_SYNC/claude.path"
    echo "$codex_wt" > "$PEER_SYNC/codex.path"

    # Initialize state
    echo "0" > "$PEER_SYNC/round"
    echo "setup" > "$PEER_SYNC/phase"
    write_status "claude" "INITIALIZING"
    write_status "codex" "INITIALIZING"

    log_info "Worktrees created:"
    log_info "  Claude: $claude_wt"
    log_info "  Codex:  $codex_wt"
}

cmd_cleanup() {
    local full="${1:-}"
    log_info "Cleaning up..."

    # Kill tmux session
    tmux kill-session -t agent-duo 2>/dev/null || true

    # Kill ttyd
    pkill -f "ttyd.*768[12]" 2>/dev/null || true

    # Remove worktrees
    cd "$SCRIPT_DIR"
    for agent in claude codex; do
        local wt=$(get_worktree_path "$agent")
        if [[ -d "$wt" ]]; then
            git worktree remove --force "$wt" 2>/dev/null || rm -rf "$wt"
        fi
    done
    git worktree prune

    # Clean state files if --full
    if [[ "$full" == "--full" ]]; then
        rm -rf "$PEER_SYNC/rounds" "$PEER_SYNC"/*.status "$PEER_SYNC"/*.path
        rm -f "$PEER_SYNC/round" "$PEER_SYNC/phase" "$PEER_SYNC/task.md"
        log_info "State files cleaned"
    fi

    log_info "Cleanup complete"
}

# ============================================================================
# Signal command (for agents to use)
# ============================================================================
cmd_signal() {
    local agent="$1"
    local state="$2"
    shift 2
    local message="$*"

    if [[ ! "$agent" =~ ^(claude|codex)$ ]]; then
        log_error "Invalid agent: $agent (must be 'claude' or 'codex')"
        exit 1
    fi

    write_status "$agent" "$state" "$message"
}

# ============================================================================
# Snapshot command (round-based organization)
# ============================================================================
cmd_snapshot() {
    local agent="$1"
    local round=$(cat "$PEER_SYNC/round" 2>/dev/null || echo "0")
    local round_dir="$PEER_SYNC/rounds/$round"
    local wt_path=$(cat "$PEER_SYNC/${agent}.path" 2>/dev/null)

    if [[ -z "$wt_path" ]] || [[ ! -d "$wt_path" ]]; then
        log_error "Cannot find worktree for $agent"
        exit 1
    fi

    mkdir -p "$round_dir"
    cd "$wt_path"

    local snapshot_file="$round_dir/${agent}-snapshot.txt"
    local patch_file="$round_dir/${agent}.patch"

    {
        echo "=== Snapshot: $agent | Round: $round | $(date -Iseconds) ==="
        echo ""
        echo "--- Git Status ---"
        git status --short 2>/dev/null || echo "(no changes)"
        echo ""
        echo "--- Changed Files ---"
        git diff --stat HEAD 2>/dev/null || echo "(none)"
        echo ""
        echo "--- Staged Diff ---"
        git diff --cached 2>/dev/null || echo "(none)"
        echo ""
        echo "--- Unstaged Diff ---"
        git diff 2>/dev/null || echo "(none)"
        echo ""
        echo "--- Untracked Files ---"
        for f in $(git ls-files --others --exclude-standard 2>/dev/null); do
            echo ">>> $f"
            head -100 "$f" 2>/dev/null || true
            echo ""
        done
    } > "$snapshot_file"

    # Generate patch file
    {
        git diff --cached 2>/dev/null
        git diff 2>/dev/null
    } > "$patch_file"

    log_info "Snapshot saved: $snapshot_file"
    cd "$SCRIPT_DIR"
}

# ============================================================================
# Start command (launches the session)
# ============================================================================
cmd_start() {
    local task_file=""
    local mode="tmux"

    # Parse arguments (--ttyd can appear in any position)
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --ttyd) mode="--ttyd"; shift ;;
            --tmux) mode="tmux"; shift ;;
            -h|--help) cmd_help; exit 0 ;;
            -*) log_error "Unknown option: $1"; exit 1 ;;
            *) task_file="$1"; shift ;;
        esac
    done

    log_phase "AGENT DUO SESSION"

    # Check prerequisites
    for cmd in git tmux; do
        command -v $cmd >/dev/null 2>&1 || { log_error "Missing: $cmd"; exit 1; }
    done

    # Setup worktrees
    cmd_setup

    # Copy task file if provided
    if [[ -n "$task_file" ]] && [[ -f "$task_file" ]]; then
        cp "$task_file" "$PEER_SYNC/task.md"
        log_info "Task: $task_file"
    elif [[ -n "$task_file" ]]; then
        log_warn "Task file not found: $task_file"
    fi

    local claude_wt=$(get_worktree_path "claude")
    local codex_wt=$(get_worktree_path "codex")

    if [[ "$mode" == "--ttyd" ]]; then
        # Launch ttyd servers
        command -v ttyd >/dev/null 2>&1 || { log_error "Missing: ttyd"; exit 1; }

        tmux kill-session -t agent-duo 2>/dev/null || true
        tmux new-session -d -s agent-duo -n orchestrator
        tmux new-window -t agent-duo -n claude
        tmux new-window -t agent-duo -n codex

        tmux send-keys -t agent-duo:claude "cd '$claude_wt' && ttyd -p $TTYD_PORT_CLAUDE -W bash" Enter
        tmux send-keys -t agent-duo:codex "cd '$codex_wt' && ttyd -p $TTYD_PORT_CODEX -W bash" Enter
        tmux send-keys -t agent-duo:orchestrator "cd '$SCRIPT_DIR' && ./agent-duo orchestrate" Enter

        log_info "ttyd servers:"
        log_info "  Claude: http://localhost:$TTYD_PORT_CLAUDE"
        log_info "  Codex:  http://localhost:$TTYD_PORT_CODEX"

        tmux attach-session -t agent-duo
    else
        # Standard tmux mode
        tmux kill-session -t agent-duo 2>/dev/null || true
        tmux new-session -d -s agent-duo -n orchestrator -c "$SCRIPT_DIR"
        tmux new-window -t agent-duo -n claude -c "$claude_wt"
        tmux new-window -t agent-duo -n codex -c "$codex_wt"

        tmux send-keys -t agent-duo:orchestrator "./agent-duo orchestrate" Enter

        log_info "tmux session 'agent-duo' created"
        log_info "  Window 0: orchestrator"
        log_info "  Window 1: claude ($claude_wt)"
        log_info "  Window 2: codex ($codex_wt)"

        tmux attach-session -t agent-duo
    fi
}

# ============================================================================
# Orchestrate command (the coordination loop)
# ============================================================================
wait_for_agents() {
    local target_state="$1"
    local timeout="$2"
    local start=$(date +%s)

    while true; do
        local cs=$(get_state "claude")
        local xs=$(get_state "codex")

        if [[ "$cs" == "ERROR" ]] || [[ "$xs" == "ERROR" ]]; then
            log_error "Agent error: Claude=$cs, Codex=$xs"
            return 1
        fi

        if [[ "$cs" == "$target_state" ]] && [[ "$xs" == "$target_state" ]]; then
            return 0
        fi

        local elapsed=$(($(date +%s) - start))
        if [[ $elapsed -ge $timeout ]]; then
            log_warn "Timeout after ${elapsed}s (Claude=$cs, Codex=$xs)"
            return 2
        fi

        printf "\r${BLUE}[agent-duo]${NC} Claude: %-15s Codex: %-15s [%ds/%ds]" "$cs" "$xs" "$elapsed" "$timeout"
        sleep $POLL_INTERVAL
    done
}

cmd_orchestrate() {
    log_phase "ORCHESTRATOR STARTING"

    log_info "Waiting for agents to initialize..."
    log_info "Start agents with: ./agent-duo signal <agent> WORKING"
    sleep 3

    local round=0
    while [[ $round -lt $MAX_TURNS ]]; do
        round=$((round + 1))
        echo "$round" > "$PEER_SYNC/round"

        log_phase "ROUND $round / $MAX_TURNS"

        # Work phase
        echo "work" > "$PEER_SYNC/phase"
        write_status "claude" "WORKING" "round $round"
        write_status "codex" "WORKING" "round $round"

        log_info "Work phase started (timeout: ${WORK_TIMEOUT}s)"
        wait_for_agents "READY" $WORK_TIMEOUT || true
        echo ""

        # Generate snapshots
        log_info "Generating snapshots..."
        cmd_snapshot "claude"
        cmd_snapshot "codex"

        # Review phase
        echo "review" > "$PEER_SYNC/phase"
        write_status "claude" "REVIEWING" "round $round"
        write_status "codex" "REVIEWING" "round $round"

        log_info "Review phase started (timeout: ${REVIEW_TIMEOUT}s)"
        wait_for_agents "READY" $REVIEW_TIMEOUT || true
        echo ""
    done

    # Done
    echo "done" > "$PEER_SYNC/phase"
    write_status "claude" "DONE"
    write_status "codex" "DONE"

    log_phase "SESSION COMPLETE"
    log_info "Create PRs with: ./agent-duo pr claude && ./agent-duo pr codex"
}

# ============================================================================
# PR command
# ============================================================================
cmd_pr() {
    local agent="$1"
    local wt_path=$(cat "$PEER_SYNC/${agent}.path" 2>/dev/null)

    if [[ -z "$wt_path" ]] || [[ ! -d "$wt_path" ]]; then
        log_error "Cannot find worktree for $agent"
        exit 1
    fi

    command -v gh >/dev/null 2>&1 || { log_error "gh CLI required"; exit 1; }

    cd "$wt_path"

    # Commit any uncommitted changes
    if [[ -n "$(git status --porcelain)" ]]; then
        git add -A
        git commit -m "Final changes from $agent

Co-Authored-By: ${agent^} <noreply@anthropic.com>"
    fi

    # Push and create PR
    local branch=$(git branch --show-current)
    git push -u origin "$branch" 2>/dev/null || true

    local task_title="Agent Duo Solution"
    if [[ -f "$PEER_SYNC/task.md" ]]; then
        task_title=$(head -1 "$PEER_SYNC/task.md" | sed 's/^#* *//')
    fi

    gh pr create \
        --title "[${agent^}] $task_title" \
        --body "$(cat <<EOF
## ${agent^}'s Implementation

This PR contains ${agent^}'s approach to the task.

### Rounds
$(ls "$PEER_SYNC/rounds" 2>/dev/null | wc -l | xargs) rounds completed

### Reviews Received
$(cat "$PEER_SYNC/rounds"/*/${agent}-review.md 2>/dev/null || echo "(none)")

---
Generated by agent-duo
EOF
)" \
        --base main 2>/dev/null || log_warn "PR may already exist"

    cd "$SCRIPT_DIR"
    log_info "PR created for $agent"
}

# ============================================================================
# Status command (show current state)
# ============================================================================
cmd_status() {
    echo "=== Agent Duo Status ==="
    echo ""
    echo "Phase: $(cat "$PEER_SYNC/phase" 2>/dev/null || echo 'not started')"
    echo "Round: $(cat "$PEER_SYNC/round" 2>/dev/null || echo '0')"
    echo ""
    echo "Claude: $(read_status claude)"
    echo "Codex:  $(read_status codex)"
    echo ""
    if [[ -d "$PEER_SYNC/rounds" ]]; then
        echo "Snapshots:"
        ls -la "$PEER_SYNC/rounds"/*/* 2>/dev/null || echo "  (none)"
    fi
}

# ============================================================================
# Help
# ============================================================================
cmd_help() {
    cat <<'EOF'
agent-duo - Coordinate two AI agents on parallel implementations

USAGE:
    agent-duo <command> [options]

COMMANDS:
    start [task.md] [--ttyd]   Start a new session (default: tmux mode)
    setup                      Create worktrees without launching
    cleanup [--full]           Remove worktrees and processes

    signal <agent> <state> [msg]   Signal agent state change
    snapshot <agent>               Generate snapshot for review

    orchestrate                Run the coordination loop
    status                     Show current session state
    pr <agent>                 Create PR for agent's work

    help                       Show this help

AGENTS:
    claude, codex

STATES:
    INITIALIZING, WORKING, READY, REVIEWING, DONE, ERROR

EXAMPLES:
    # Start a session with a task
    agent-duo start task.md

    # Agent signals completion of work phase
    agent-duo signal claude READY "implemented API"

    # Check status
    agent-duo status

    # Create PRs
    agent-duo pr claude
    agent-duo pr codex
EOF
}

# ============================================================================
# Main dispatch
# ============================================================================
main() {
    local cmd="${1:-help}"
    shift || true

    case "$cmd" in
        start)      cmd_start "$@" ;;
        setup)      cmd_setup "$@" ;;
        cleanup)    cmd_cleanup "$@" ;;
        signal)     cmd_signal "$@" ;;
        snapshot)   cmd_snapshot "$@" ;;
        orchestrate) cmd_orchestrate "$@" ;;
        status)     cmd_status "$@" ;;
        pr)         cmd_pr "$@" ;;
        help|--help|-h) cmd_help ;;
        *)
            log_error "Unknown command: $cmd"
            cmd_help
            exit 1
            ;;
    esac
}

main "$@"
