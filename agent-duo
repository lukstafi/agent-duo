#!/usr/bin/env bash
# agent-duo - Coordinate two AI coding agents working in parallel
#
# Requires Bash 4.0+ (for associative arrays, regex matching, etc.)
# macOS users: install modern bash via Homebrew: brew install bash
#
# Usage: agent-duo <command> [options]
#
# Session Commands:
#   start <feature> [<feature2> ...] [options]  Start session(s)
#   run [options]        Run orchestrator loop with timeouts
#                        --on-tui-exit=pause|quit|ignore  TUI exit behavior
#   stop                 Stop ttyd servers, keep worktrees
#   restart [--auto-run] Restart session after system restart/crash
#   status               Show session state
#   confirm              Confirm clarify phase completion (proceed to work)
#   pr <agent>           Create PR for agent's solution
#   feedback             View/manage accumulated workflow feedback
#   cleanup [--full]     Remove session state (--full: also worktrees/branches)
#   setup                Install agent-duo to PATH and skills
#   doctor [--send-email|--send-ntfy]  Check system health and configuration
#   config <key> [value] Get/set configuration (e.g., ntfy_topic)
#
# Control Commands:
#   nudge <agent> [msg]  Send message to agent terminal
#   interrupt <agent>    Interrupt agent (Esc)
#
# Agent Commands:
#   signal <agent> <status> [message]   Signal status change
#   peer-status                         Read peer's status
#   phase                               Read current phase

set -e

# Determine script location (resolves symlinks)
SCRIPT_PATH="${BASH_SOURCE[0]}"
while [ -L "$SCRIPT_PATH" ]; do
    SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
    SCRIPT_PATH="$(readlink "$SCRIPT_PATH")"
    [[ $SCRIPT_PATH != /* ]] && SCRIPT_PATH="$SCRIPT_DIR/$SCRIPT_PATH"
done
SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"

# Source shared library
if [ -f "$SCRIPT_DIR/agent-lib.sh" ]; then
    # shellcheck source=agent-lib.sh
    source "$SCRIPT_DIR/agent-lib.sh"
elif [ -f "$HOME/.local/bin/agent-lib.sh" ]; then
    # shellcheck source=agent-lib.sh
    source "$HOME/.local/bin/agent-lib.sh"
else
    echo "Error: agent-lib.sh not found" >&2
    exit 1
fi

# Default agents for duo mode
DEFAULT_AGENT_A="claude"
DEFAULT_AGENT_B="codex"

# Session registry prefix for .agent-sessions/ namespace isolation
SESSION_REGISTRY_PREFIX="duo"

# Allocate ports for a session and store in .peer-sync/ports
# Args: peer_sync [base_port]
# If base_port is provided, uses consecutive ports starting from it (fails if any occupied)
# Otherwise, dynamically finds available ports starting from DEFAULT_BASE_PORT
allocate_ports() {
    local peer_sync="$1"
    local base_port="${2:-}"
    local ports_file="$peer_sync/ports"

    # If ports already allocated, return
    if [ -f "$ports_file" ]; then
        return 0
    fi

    local orchestrator_port claude_port codex_port

    if [ -n "$base_port" ]; then
        # User specified a port: use consecutive ports, fail if any occupied
        orchestrator_port="$base_port"
        claude_port=$((base_port + 1))
        codex_port=$((base_port + 2))

        if ! is_port_available "$orchestrator_port"; then
            die "Port $orchestrator_port (orchestrator) is already in use"
        fi
        if ! is_port_available "$claude_port"; then
            die "Port $claude_port (claude) is already in use"
        fi
        if ! is_port_available "$codex_port"; then
            die "Port $codex_port (codex) is already in use"
        fi
    else
        # Dynamic allocation: find 3 consecutive available ports
        orchestrator_port="$(find_consecutive_ports "$DEFAULT_BASE_PORT" 3)" || die "Could not find 3 consecutive available ports"
        claude_port=$((orchestrator_port + 1))
        codex_port=$((orchestrator_port + 2))
    fi

    cat > "$ports_file" << EOF
ORCHESTRATOR_PORT=$orchestrator_port
CLAUDE_PORT=$claude_port
CODEX_PORT=$codex_port
EOF
}

# Note: get_ports, tmux_session_exists, ttyd_is_running, is_port_in_use,
# agent_tui_is_running, restart_ttyd_for_session, restart_agent_tui, and
# find_task_file are all provided by agent-lib.sh

#------------------------------------------------------------------------------
# Command: setup
#------------------------------------------------------------------------------

cmd_setup() {
    # Detect if user meant to run ./agent-duo setup from a repo checkout
    local install_dir="$HOME/.local/bin"

    if [ "$SCRIPT_DIR" = "$install_dir" ] && [ -x "./agent-duo" ]; then
        die "Found ./agent-duo in current directory - did you mean to run:
  ./agent-duo setup"
    fi

    info "Installing agent-duo..."

    local templates_dir="$SCRIPT_DIR/skills/templates"

    if [ ! -d "$templates_dir" ]; then
        die "Skills templates not found at $templates_dir"
    fi

    # Install CLI to ~/.local/bin
    mkdir -p "$install_dir"

    local install_path="$install_dir/agent-duo"
    if [ "$SCRIPT_DIR/agent-duo" != "$install_path" ]; then
        cp "$SCRIPT_DIR/agent-duo" "$install_path"
        chmod +x "$install_path"
        success "Installed agent-duo to $install_path"
    else
        success "agent-duo already installed at $install_path"
    fi

    # Install shared library
    local lib_path="$install_dir/agent-lib.sh"
    if [ -f "$SCRIPT_DIR/agent-lib.sh" ]; then
        cp "$SCRIPT_DIR/agent-lib.sh" "$lib_path"
        success "Installed agent-lib.sh to $lib_path"
    fi

    # Install agent-launch (standalone agent launcher)
    if [ -f "$SCRIPT_DIR/agent-launch" ]; then
        cp "$SCRIPT_DIR/agent-launch" "$install_dir/agent-launch"
        chmod +x "$install_dir/agent-launch"
        ln -sf agent-launch "$install_dir/agent-claude"
        ln -sf agent-launch "$install_dir/agent-codex"
        success "Installed agent-claude and agent-codex to $install_dir"
    fi

    # Copy skills/templates to install dir so setup works from installed location
    local installed_templates="$install_dir/skills/templates"
    if [ "$templates_dir" != "$installed_templates" ]; then
        mkdir -p "$installed_templates"
        cp -r "$templates_dir"/* "$installed_templates/"
        success "Installed skill templates to $installed_templates"
    fi

    # Install shared helper scripts
    local shared_dir="$HOME/.local/share/agent-duo"
    mkdir -p "$shared_dir"
    local shared_templates="$templates_dir/shared"
    if [ -d "$shared_templates" ]; then
        cp "$shared_templates"/*.sh "$shared_dir/" 2>/dev/null || true
        chmod +x "$shared_dir"/*.sh 2>/dev/null || true
        success "Installed shared scripts to $shared_dir"
    fi

    # Check if ~/.local/bin is in PATH
    if [[ ":$PATH:" != *":$install_dir:"* ]]; then
        warn "Add $install_dir to your PATH:"
        echo "  export PATH=\"\$HOME/.local/bin:\$PATH\""
    fi

    # Skills are now installed per-session into worktrees, not globally
    # Check for and warn about legacy global skill installations
    warn_legacy_global_skills DUO_SKILLS

    # Install unified notify hook script and configure agent hooks
    local notify_script
    notify_script="$(install_notify_hook "$install_dir")"
    success "Installed unified notify hook script to $notify_script"

    configure_codex_notify "$notify_script"
    configure_claude_notify "$notify_script"

    success "Setup complete!"

    # Hint about VS Code terminal title
    echo ""
    info "VS Code tip: To show agent names in terminal tabs, add to VS Code settings:"
    echo '  "terminal.integrated.tabs.title": "${sequence}"'

    # Prominent message about agent-solo
    echo ""
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    info "To install agent-solo (single-agent mode), run: ./agent-solo setup"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
}

#------------------------------------------------------------------------------
# Command: doctor
#------------------------------------------------------------------------------

cmd_doctor() {
    local all_ok=true
    local send_test_email=false
    local send_test_ntfy=false

    # Parse arguments
    while [ $# -gt 0 ]; do
        case "$1" in
            --send-email) send_test_email=true ;;
            --send-ntfy) send_test_ntfy=true ;;
            *) die "Unknown option: $1" ;;
        esac
        shift
    done

    info "Running health checks..."
    echo ""

    # --- Required Tools ---
    echo "=== Required Tools ==="

    # git
    if command -v git >/dev/null 2>&1; then
        success "git: $(git --version | head -1)"
    else
        warn "git: NOT FOUND (required)"
        all_ok=false
    fi

    # tmux
    if command -v tmux >/dev/null 2>&1; then
        success "tmux: $(tmux -V)"
    else
        warn "tmux: NOT FOUND (required)"
        all_ok=false
    fi

    # ttyd (optional but recommended)
    if command -v ttyd >/dev/null 2>&1; then
        success "ttyd: $(ttyd --version 2>&1 | head -1)"
    else
        warn "ttyd: NOT FOUND (optional - use --no-ttyd flag without it)"
    fi

    # jq (optional but helpful)
    if command -v jq >/dev/null 2>&1; then
        success "jq: $(jq --version)"
    else
        warn "jq: NOT FOUND (optional - used for JSON config manipulation)"
    fi

    echo ""

    # --- AI Agent CLIs ---
    echo "=== AI Agent CLIs ==="

    # claude
    if command -v claude >/dev/null 2>&1; then
        success "claude: found at $(command -v claude)"
    else
        warn "claude: NOT FOUND"
        warn "  Install: npm install -g @anthropic-ai/claude-code"
        all_ok=false
    fi

    # codex
    if command -v codex >/dev/null 2>&1; then
        success "codex: found at $(command -v codex)"
    else
        warn "codex: NOT FOUND"
        warn "  Install: npm install -g @openai/codex"
        all_ok=false
    fi

    echo ""

    # --- Git Configuration ---
    echo "=== Git Configuration ==="

    local git_name git_email
    git_name="$(git config user.name 2>/dev/null || true)"
    git_email="$(git config user.email 2>/dev/null || true)"

    if [ -n "$git_name" ]; then
        success "git user.name: $git_name"
    else
        warn "git user.name: NOT SET"
        warn "  Run: git config --global user.name \"Your Name\""
        all_ok=false
    fi

    if [ -n "$git_email" ]; then
        success "git user.email: $git_email"
    else
        warn "git user.email: NOT SET (required for email notifications)"
        warn "  Run: git config --global user.email \"you@example.com\""
        all_ok=false
    fi

    echo ""

    # --- Email Setup ---
    echo "=== Email Notifications ==="

    local email_likely_works=false

    if command -v mail >/dev/null 2>&1; then
        success "mail command: found at $(command -v mail)"

        # Check if email delivery is likely to work
        local mail_warning=""

        # Check for running mail daemon (postfix, sendmail, etc.)
        if ! pgrep -x "master" >/dev/null 2>&1 && ! pgrep -x "sendmail" >/dev/null 2>&1; then
            # No mail daemon running - check if msmtp is configured as sendmail
            if command -v msmtp >/dev/null 2>&1; then
                # msmtp found - check if it's linked as sendmail
                local sendmail_path
                sendmail_path="$(command -v sendmail 2>/dev/null || true)"
                if [ -n "$sendmail_path" ] && readlink "$sendmail_path" 2>/dev/null | grep -q msmtp; then
                    success "msmtp: configured as sendmail relay"
                    email_likely_works=true
                elif [ -f "$HOME/.msmtprc" ]; then
                    success "msmtp: found with config"
                    info "  Tip: link msmtp as sendmail for mail command to use it"
                    email_likely_works=true
                else
                    warn "msmtp: found but not configured (~/.msmtprc missing)"
                fi
            else
                mail_warning="no mail daemon running"
            fi
        else
            success "Mail daemon: running"
            email_likely_works=true
        fi

        # On macOS, warn about common postfix issue
        if [ "$(uname)" = "Darwin" ] && [ "$email_likely_works" = false ]; then
            warn "macOS mail issue: $mail_warning"
            warn "  The 'mail' command will appear to succeed but emails won't deliver."
            warn "  Fix options:"
            warn "    1. Install msmtp: brew install msmtp"
            warn "       Configure ~/.msmtprc with SMTP relay (e.g., Gmail app password)"
            warn "    2. Start postfix: sudo postfix start (temporary)"
            warn "    3. Use a webhook notification service instead"
        elif [ "$email_likely_works" = false ]; then
            warn "Mail delivery issue: $mail_warning"
            warn "  Emails may not be delivered. Check your MTA configuration."
        fi

        if [ "$send_test_email" = true ]; then
            if [ -n "$git_email" ]; then
                info "Sending test email to $git_email..."
                local test_body="This is a test email from agent-duo doctor.

If you received this, your email configuration is working correctly.

Sent: $(date)"
                if echo "$test_body" | mail -s "[agent-duo] Test email from doctor" "$git_email" 2>/dev/null; then
                    if [ "$email_likely_works" = true ]; then
                        success "Test email sent to $git_email"
                        info "  Check your inbox (and spam folder)"
                    else
                        warn "Test email queued to $git_email (but delivery unlikely)"
                        warn "  The mail command succeeded, but without a working MTA,"
                        warn "  the email is probably sitting in a local queue."
                    fi
                else
                    warn "Failed to send test email"
                    warn "  Your mail system may not be configured correctly"
                fi
            else
                warn "Cannot send test email: git user.email not configured"
            fi
        else
            info "  Use --send-email to send a test email"
        fi
    else
        warn "mail command: NOT FOUND"
        warn "  Email notifications will not work"
        warn "  Install: mailutils (Linux) or configure msmtp (macOS)"
    fi

    echo ""

    # --- ntfy.sh Setup ---
    echo "=== ntfy.sh Notifications ==="

    local ntfy_topic
    ntfy_topic="$(get_ntfy_topic 2>/dev/null || true)"

    if [ -n "$ntfy_topic" ]; then
        success "ntfy topic: $ntfy_topic"
        local ntfy_server
        ntfy_server="$(get_ntfy_server)"
        info "  Server: $ntfy_server"

        # Check for token
        local ntfy_token
        if ntfy_token="$(get_ntfy_token 2>/dev/null)"; then
            success "ntfy token: ${ntfy_token:0:6}...${ntfy_token: -4} (authenticated)"
        else
            info "  Token: not set (using anonymous access)"
        fi

        if [ "$send_test_ntfy" = true ]; then
            info "Sending test notification..."
            if send_ntfy "agent-duo test" "This is a test notification from agent-duo doctor. Sent: $(date)" "default" "white_check_mark"; then
                success "Test notification sent to $ntfy_server/$ntfy_topic"
            else
                warn "Failed to send test notification"
                warn "  Check your internet connection, topic name, and token"
            fi
        else
            info "  Use --send-ntfy to send a test notification"
        fi
    else
        info "ntfy: not configured (optional)"
        info "  Configure with: agent-duo config ntfy_topic <your-topic>"
        info "  ntfy.sh is a free push notification service"
        info "  Subscribe at: https://ntfy.sh/<your-topic>"
    fi

    echo ""

    # --- Skills Templates ---
    echo "=== Skills Templates ==="

    # Skills are now installed per-session into worktrees, not globally
    # Check that templates are installed (used during session start)
    local templates_dir="$HOME/.local/bin/skills/templates"
    if [ -d "$templates_dir" ]; then
        local template_count
        template_count=$(find "$templates_dir" -name "*.md" -type f 2>/dev/null | wc -l | tr -d ' ')
        if [ "$template_count" -gt 0 ]; then
            success "Skill templates: $template_count templates in $templates_dir"
        else
            warn "Skill templates: directory exists but no templates found"
            warn "  Run: agent-duo setup"
            all_ok=false
        fi
    else
        warn "Skill templates: NOT FOUND at $templates_dir"
        warn "  Run: agent-duo setup"
        all_ok=false
    fi

    # Check for legacy global skills and warn
    local claude_global="$HOME/.claude/commands"
    local codex_global="$HOME/.codex/skills"
    local legacy_found=false
    for skill in duo-work duo-review duo-clarify duo-pushback duo-amend duo-update-docs; do
        if [ -f "$claude_global/$skill.md" ] || [ -d "$codex_global/$skill" ]; then
            legacy_found=true
            break
        fi
    done
    if [ "$legacy_found" = true ]; then
        warn "Legacy global skills detected (now installed per-session)"
        warn "  Run: agent-duo setup (for cleanup instructions)"
    fi

    echo ""

    # --- Hook Configuration ---
    echo "=== Hook Configuration ==="

    local notify_script="$HOME/.local/bin/agent-duo-notify"
    if [ -x "$notify_script" ]; then
        success "Notify script: $notify_script"
    else
        warn "Notify script: NOT FOUND or not executable"
        warn "  Run: agent-duo setup"
        all_ok=false
    fi

    # Check Claude hooks
    local claude_settings="$HOME/.claude/settings.json"
    if [ -f "$claude_settings" ]; then
        if grep -q "agent-duo-notify" "$claude_settings" 2>/dev/null; then
            success "Claude hooks: configured"
        else
            warn "Claude hooks: not configured for agent-duo"
            warn "  Run: agent-duo setup"
        fi
    else
        warn "Claude settings: $claude_settings not found"
    fi

    # Check Codex hooks
    local codex_config="$HOME/.codex/config.toml"
    if [ -f "$codex_config" ]; then
        if grep -q "agent-duo-notify" "$codex_config" 2>/dev/null; then
            success "Codex hooks: configured"
        else
            warn "Codex hooks: not configured for agent-duo"
            warn "  Run: agent-duo setup"
        fi
    else
        warn "Codex config: $codex_config not found"
    fi

    echo ""

    # --- PATH Check ---
    echo "=== PATH Configuration ==="

    local install_dir="$HOME/.local/bin"
    if [[ ":$PATH:" == *":$install_dir:"* ]]; then
        success "~/.local/bin is in PATH"
    else
        warn "~/.local/bin is NOT in PATH"
        warn "  Add to your shell profile:"
        warn "  export PATH=\"\$HOME/.local/bin:\$PATH\""
        all_ok=false
    fi

    # Check if agent-duo is accessible
    if command -v agent-duo >/dev/null 2>&1; then
        success "agent-duo: found at $(command -v agent-duo)"
    else
        warn "agent-duo: not found in PATH"
        warn "  Run: agent-duo setup"
        all_ok=false
    fi

    echo ""

    # --- Summary ---
    echo "=== Summary ==="
    if [ "$all_ok" = true ]; then
        success "All checks passed!"
    else
        warn "Some issues found - see above for details"
        return 1
    fi
}

#------------------------------------------------------------------------------
# Command: config
#------------------------------------------------------------------------------

cmd_config() {
    local config_dir="$HOME/.config/agent-duo"
    local config_file="$config_dir/config"

    # List all config if no arguments
    if [ $# -eq 0 ]; then
        info "Configuration file: $config_file"
        echo ""
        if [ -f "$config_file" ]; then
            # Display config with token masked
            while IFS= read -r line; do
                if [[ "$line" =~ ^ntfy_token= ]]; then
                    local token="${line#ntfy_token=}"
                    echo "ntfy_token=${token:0:6}...${token: -4}"
                else
                    echo "$line"
                fi
            done < "$config_file"
        else
            info "No configuration set"
        fi
        echo ""
        info "Available settings:"
        echo "  codex_model  - GPT model for Codex (e.g., o3, gpt-4.1)"
        echo "  claude_model - Claude model (e.g., opus, sonnet)"
        echo "  ntfy_topic   - ntfy.sh topic for push notifications"
        echo "  ntfy_token   - ntfy.sh access token (for reserved topics)"
        echo "  ntfy_server  - ntfy server URL (default: https://ntfy.sh)"
        echo "  feedback_repo - GitHub repo for feedback issues (e.g., owner/repo)"
        echo "  auto_digest  - Auto-run feedback digest on session end (true/false)"
        echo ""
        info "Usage: agent-duo config <key> [value]"
        return 0
    fi

    local key="$1"
    local value="${2:-}"

    # Validate key
    case "$key" in
        codex_model|claude_model|ntfy_topic|ntfy_token|ntfy_server|feedback_repo|auto_digest)
            ;;
        *)
            die "Unknown config key: $key (valid: codex_model, claude_model, ntfy_topic, ntfy_token, ntfy_server, feedback_repo, auto_digest)"
            ;;
    esac

    # Get value if not setting
    if [ -z "$value" ]; then
        if [ -f "$config_file" ]; then
            local current
            current="$(grep -E "^${key}=" "$config_file" 2>/dev/null | cut -d= -f2-)"
            if [ -n "$current" ]; then
                # Mask token for security
                if [ "$key" = "ntfy_token" ]; then
                    echo "${current:0:6}...${current: -4}"
                else
                    echo "$current"
                fi
            else
                info "$key is not set"
                return 1
            fi
        else
            info "$key is not set"
            return 1
        fi
        return 0
    fi

    # Set value
    mkdir -p "$config_dir"

    if [ -f "$config_file" ]; then
        # Remove existing key if present
        grep -v "^${key}=" "$config_file" > "$config_file.tmp" 2>/dev/null || true
        mv "$config_file.tmp" "$config_file"
    fi

    # Add new value
    echo "${key}=${value}" >> "$config_file"

    # Mask token in success message
    if [ "$key" = "ntfy_token" ]; then
        success "Set $key=${value:0:6}...${value: -4}"
    else
        success "Set $key=$value"
    fi

    # Show helpful info based on key
    case "$key" in
        codex_model)
            echo ""
            info "Codex will use model: $value"
            echo "  Common models: o3, o4-mini, gpt-4.1"
            ;;
        claude_model)
            echo ""
            info "Claude will use model: $value"
            echo "  Common models: opus, sonnet, haiku"
            ;;
        ntfy_topic)
            local server
            server="$(get_ntfy_server)"
            echo ""
            info "To receive notifications:"
            echo "  1. Install ntfy app on your phone (iOS/Android)"
            echo "  2. Subscribe to topic: $value"
            echo "  3. Or open in browser: $server/$value"
            echo ""
            info "Test with: agent-duo doctor --send-ntfy"
            ;;
        ntfy_token)
            echo ""
            info "Token configured for authenticated access."
            info "Test with: agent-duo doctor --send-ntfy"
            ;;
    esac
}

#------------------------------------------------------------------------------
# Command: start
#------------------------------------------------------------------------------

cmd_start() {
    local features=()
    local ttyd_mode=true
    local auto_run=false
    local clarify_mode=false
    local pushback_mode=false
    local plan_mode=false
    local docs_update_mode=true
    local auto_finish=false
    local auto_finish_timeout=$DEFAULT_AUTO_FINISH_TIMEOUT
    local work_timeout=$DEFAULT_WORK_TIMEOUT
    local review_timeout=$DEFAULT_REVIEW_TIMEOUT
    local clarify_timeout=$DEFAULT_CLARIFY_TIMEOUT
    local pushback_timeout=$DEFAULT_PUSHBACK_TIMEOUT
    local plan_timeout=$DEFAULT_PLAN_TIMEOUT
    local max_rounds=10
    local codex_thinking=$DEFAULT_CODEX_THINKING
    local codex_model=""
    local claude_model=""
    local base_port=""
    local followup_pr=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --no-ttyd) ttyd_mode=false; shift ;;
            --auto-run) auto_run=true; shift ;;
            --clarify) clarify_mode=true; shift ;;
            --pushback) pushback_mode=true; shift ;;
            --plan) plan_mode=true; shift ;;
            --skip-docs-update) docs_update_mode=false; shift ;;
            --auto-finish) auto_finish=true; shift ;;
            --auto-finish-timeout) auto_finish_timeout="$2"; shift 2 ;;
            --work-timeout) work_timeout="$2"; shift 2 ;;
            --review-timeout) review_timeout="$2"; shift 2 ;;
            --clarify-timeout) clarify_timeout="$2"; shift 2 ;;
            --pushback-timeout) pushback_timeout="$2"; shift 2 ;;
            --plan-timeout) plan_timeout="$2"; shift 2 ;;
            --max-rounds) max_rounds="$2"; shift 2 ;;
            --codex-thinking) codex_thinking="$2"; shift 2 ;;
            --codex-model) codex_model="$2"; shift 2 ;;
            --claude-model) claude_model="$2"; shift 2 ;;
            --port) base_port="$2"; shift 2 ;;
            --followup) followup_pr="$2"; shift 2 ;;
            -*) die "Unknown option: $1" ;;
            *) features+=("$1"); shift ;;
        esac
    done

    # Export model overrides if specified (used by get_agent_cmd)
    [ -n "$codex_model" ] && export AGENT_DUO_CODEX_MODEL="$codex_model"
    [ -n "$claude_model" ] && export AGENT_DUO_CLAUDE_MODEL="$claude_model"

    # Generate task from PR if --followup was specified
    if [ -n "$followup_pr" ]; then
        git rev-parse --is-inside-work-tree >/dev/null 2>&1 || die "Not a git repository"
        local main_root
        main_root="$(get_main_project_root)"
        local followup_feature
        followup_feature="$(generate_followup_task "$main_root" "$followup_pr")"
        info "Generated follow-up task: ${followup_feature}.md"
        features+=("$followup_feature")
    fi

    [ ${#features[@]} -eq 0 ] && die "Usage: agent-duo start <feature> [feature2 ...] [--followup <PR-number>] [--no-ttyd] [--auto-run] [--clarify] [--pushback] [--plan]"

    # Validate codex thinking effort
    case "$codex_thinking" in
        low|medium|high) ;;
        *) die "Invalid --codex-thinking value: $codex_thinking (valid: low, medium, high)" ;;
    esac

    # Ensure we're in a git repo
    git rev-parse --is-inside-work-tree >/dev/null 2>&1 || die "Not a git repository"

    # Ensure repo has at least one commit
    git rev-parse HEAD >/dev/null 2>&1 || die "Repository has no commits. Create an initial commit first."

    # Push current branch to avoid PRs incorporating unpushed commits
    info "Pushing current branch to remote..."
    git push || die "Failed to push current branch. Push manually and retry."

    local main_project_root
    main_project_root="$(get_main_project_root)"
    local project_name
    project_name="$(basename "$main_project_root")"

    # Multiple features: start each one
    if [ ${#features[@]} -gt 1 ]; then
        info "Starting ${#features[@]} parallel sessions..."
        local started=0 failed=0
        for feature in "${features[@]}"; do
            echo ""
            info "=== Starting session: $feature ==="
            if start_single_session "$feature" "$main_project_root" "$project_name" \
                "$ttyd_mode" "$auto_run" "$clarify_mode" "$pushback_mode" "$plan_mode" \
                "$docs_update_mode" "$auto_finish" "$auto_finish_timeout" \
                "$work_timeout" "$review_timeout" "$clarify_timeout" "$pushback_timeout" "$plan_timeout" \
                "$max_rounds" "$codex_thinking" "$base_port" "$followup_pr"; then
                started=$((started + 1))
            else
                failed=$((failed + 1))
            fi
        done
        echo ""
        echo "=== Summary ==="
        success "Started: $started"
        [ $failed -gt 0 ] && warn "Failed: $failed"
        if [ $started -gt 0 ]; then
            echo ""
            echo "View all sessions: agent-duo status"
        fi
        return 0
    fi

    # Single feature
    local feature="${features[0]}"
    start_single_session "$feature" "$main_project_root" "$project_name" \
        "$ttyd_mode" "$auto_run" "$clarify_mode" "$pushback_mode" "$plan_mode" \
        "$docs_update_mode" "$auto_finish" "$auto_finish_timeout" \
        "$work_timeout" "$review_timeout" "$clarify_timeout" "$pushback_timeout" "$plan_timeout" \
        "$max_rounds" "$codex_thinking" "$base_port" "$followup_pr"
}

# Start a single session for one feature
# Called by cmd_start for each feature
start_single_session() {
    local feature="$1"
    local main_project_root="$2"
    local project_name="$3"
    local ttyd_mode="$4"
    local auto_run="$5"
    local clarify_mode="$6"
    local pushback_mode="$7"
    local plan_mode="$8"
    local docs_update_mode="$9"
    local auto_finish="${10}"
    local auto_finish_timeout="${11}"
    local work_timeout="${12}"
    local review_timeout="${13}"
    local clarify_timeout="${14}"
    local pushback_timeout="${15}"
    local plan_timeout="${16}"
    local max_rounds="${17}"
    local codex_thinking="${18}"
    local base_port="${19}"
    local followup_pr="${20}"

    # Check for existing session for THIS feature
    local sessions_dir="$main_project_root/.agent-sessions"
    if [ -L "$sessions_dir/duo-${feature}.session" ]; then
        warn "Session already exists for feature '$feature'."
        warn "To continue: agent-duo run --feature $feature"
        warn "To start fresh: agent-duo cleanup --feature $feature && agent-duo start $feature"
        return 1
    fi

    # Check for task file in main project
    local task_file
    if task_file="$(find_task_file "$main_project_root" "$feature")"; then
        info "Found task file: $task_file"
    else
        warn "Task file not found: $feature.md"
        warn "Searched: $feature.md, doc/$feature.md, docs/$feature.md, **/$feature.md"
        warn "Create it with the task description, or the agents won't know what to do."
    fi

    info "Starting Agent Duo session: $feature"
    info "Project: $project_name"

    local parent_dir
    parent_dir="$(dirname "$main_project_root")"

    # Detect main branch
    cd "$main_project_root"
    local main_branch
    main_branch="$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@')" || true
    if [ -z "$main_branch" ]; then
        for candidate in main master; do
            if git rev-parse --verify "$candidate" >/dev/null 2>&1; then
                main_branch="$candidate"
                break
            fi
        done
    fi
    if [ -z "$main_branch" ]; then
        main_branch="$(git rev-parse --abbrev-ref HEAD)"
    fi

    # Create root worktree for this feature (orchestrator runs here)
    local root_worktree="$parent_dir/${project_name}-${feature}"
    if [ ! -d "$root_worktree" ]; then
        info "Creating root worktree for feature..."
        git worktree add -b "${feature}" "$root_worktree" "$main_branch" 2>/dev/null || \
            git worktree add "$root_worktree" "${feature}"
    else
        warn "Root worktree already exists: $root_worktree"
    fi

    # Create agent worktrees branching from root worktree's branch
    local worktree_claude="$parent_dir/${project_name}-${feature}-claude"
    local worktree_codex="$parent_dir/${project_name}-${feature}-codex"

    if [ ! -d "$worktree_claude" ]; then
        info "Creating worktree for claude..."
        git worktree add -b "${feature}-claude" "$worktree_claude" "${feature}" 2>/dev/null || \
            git worktree add "$worktree_claude" "${feature}-claude"
    else
        warn "Worktree already exists: $worktree_claude"
    fi

    if [ ! -d "$worktree_codex" ]; then
        info "Creating worktree for codex..."
        git worktree add -b "${feature}-codex" "$worktree_codex" "${feature}" 2>/dev/null || \
            git worktree add "$worktree_codex" "${feature}-codex"
    else
        warn "Worktree already exists: $worktree_codex"
    fi

    # Initialize .peer-sync in ROOT WORKTREE (not main project)
    local peer_sync="$root_worktree/.peer-sync"
    mkdir -p "$peer_sync/reviews"
    mkdir -p "$peer_sync/pids"

    echo "active" > "$peer_sync/session"
    # Determine initial phase: clarify -> pushback -> plan -> work
    if [ "$clarify_mode" = "true" ]; then
        echo "clarify" > "$peer_sync/phase"
        echo "true" > "$peer_sync/clarify-mode"
        echo "clarifying|$(date +%s)|starting" > "$peer_sync/claude.status"
        echo "clarifying|$(date +%s)|starting" > "$peer_sync/codex.status"
    elif [ "$pushback_mode" = "true" ]; then
        echo "pushback" > "$peer_sync/phase"
        echo "pushing-back|$(date +%s)|starting" > "$peer_sync/claude.status"
        echo "pushing-back|$(date +%s)|starting" > "$peer_sync/codex.status"
    elif [ "$plan_mode" = "true" ]; then
        echo "plan" > "$peer_sync/phase"
        echo "planning|$(date +%s)|starting" > "$peer_sync/claude.status"
        echo "planning|$(date +%s)|starting" > "$peer_sync/codex.status"
    else
        echo "work" > "$peer_sync/phase"
        echo "working|$(date +%s)|starting" > "$peer_sync/claude.status"
        echo "working|$(date +%s)|starting" > "$peer_sync/codex.status"
    fi
    echo "$clarify_mode" > "$peer_sync/clarify-mode"
    echo "$pushback_mode" > "$peer_sync/pushback-mode"
    echo "$plan_mode" > "$peer_sync/plan-mode"
    echo "$docs_update_mode" > "$peer_sync/docs-update-mode"
    echo "$auto_finish" > "$peer_sync/auto-finish"
    echo "$auto_finish_timeout" > "$peer_sync/auto-finish-timeout"
    echo "1" > "$peer_sync/round"
    echo "$feature" > "$peer_sync/feature"
    [ -n "$followup_pr" ] && echo "$followup_pr" > "$peer_sync/followup-pr"
    echo "$codex_thinking" > "$peer_sync/codex-thinking"
    echo "duo" > "$peer_sync/mode"

    # Create symlinks in agent worktrees pointing to root worktree's .peer-sync
    ln -sfn "$peer_sync" "$worktree_claude/.peer-sync"
    ln -sfn "$peer_sync" "$worktree_codex/.peer-sync"

    # Register session in main project's .agent-sessions directory
    mkdir -p "$sessions_dir"
    ln -sfn "$peer_sync" "$sessions_dir/duo-${feature}.session"

    # Ensure .peer-sync, .agent-sessions, .claude, and .agents are excluded from git
    local git_exclude="$main_project_root/.git/info/exclude"
    if [ -f "$git_exclude" ]; then
        grep -qxF ".peer-sync" "$git_exclude" || echo ".peer-sync" >> "$git_exclude"
        grep -qxF ".agent-sessions" "$git_exclude" || echo ".agent-sessions" >> "$git_exclude"
        grep -qxF ".claude" "$git_exclude" || echo ".claude" >> "$git_exclude"
        grep -qxF ".agents" "$git_exclude" || echo ".agents" >> "$git_exclude"
    else
        mkdir -p "$(dirname "$git_exclude")"
        printf '%s\n' ".peer-sync" ".agent-sessions" ".claude" ".agents" > "$git_exclude"
    fi

    # Install skills to agent worktrees (per-session, not global)
    local templates_dir
    templates_dir="$(get_templates_dir)"
    install_duo_skills_to_worktree "$worktree_claude" "$templates_dir"
    install_duo_skills_to_worktree "$worktree_codex" "$templates_dir"
    success "Installed skills to agent worktrees"

    # Copy task file to all worktrees if it exists
    if [ -n "$task_file" ] && [ -f "$task_file" ]; then
        cp "$task_file" "$root_worktree/"
        cp "$task_file" "$worktree_claude/"
        cp "$task_file" "$worktree_codex/"
    fi

    # Save ttyd mode setting for restart command
    echo "$ttyd_mode" > "$peer_sync/ttyd-mode"

    if [ "$ttyd_mode" = "true" ]; then
        start_ttyd_mode "$feature" "$root_worktree" "$worktree_claude" "$worktree_codex" "$peer_sync" \
            "$auto_run" "$work_timeout" "$review_timeout" "$max_rounds" "$codex_thinking" \
            "$clarify_mode" "$clarify_timeout" "$pushback_mode" "$pushback_timeout" \
            "$plan_mode" "$plan_timeout"
    else
        start_tmux_mode "$feature" "$root_worktree" "$worktree_claude" "$worktree_codex" "$peer_sync" "$codex_thinking" "$clarify_mode" "$pushback_mode" "$plan_mode"
    fi
}

start_tmux_mode() {
    local feature="$1"
    local project_root="$2"
    local worktree_claude="$3"
    local worktree_codex="$4"
    local peer_sync="$5"
    local codex_thinking="${6:-$DEFAULT_CODEX_THINKING}"
    local clarify_mode="${7:-false}"
    local pushback_mode="${8:-false}"
    local plan_mode="${9:-false}"

    local session_name="duo-${feature}"

    # Kill existing session if any
    tmux kill-session -t "$session_name" 2>/dev/null || true

    # Create new tmux session with orchestrator window
    tmux new-session -d -s "$session_name" -n "orchestrator" -c "$project_root"
    tmux_set_title "$session_name" "duo: ${feature}"

    # Create claude window
    tmux new-window -t "$session_name" -n "claude" -c "$worktree_claude"
    tmux send-keys -t "$session_name:claude" "export PEER_SYNC='$peer_sync'"
    tmux send-keys -t "$session_name:claude" C-m
    tmux send-keys -t "$session_name:claude" "export MY_NAME='claude'"
    tmux send-keys -t "$session_name:claude" C-m
    tmux send-keys -t "$session_name:claude" "export PEER_NAME='codex'"
    tmux send-keys -t "$session_name:claude" C-m
    tmux send-keys -t "$session_name:claude" "export MY_WORKTREE='$worktree_claude'"
    tmux send-keys -t "$session_name:claude" C-m
    tmux send-keys -t "$session_name:claude" "export PEER_WORKTREE='$worktree_codex'"
    tmux send-keys -t "$session_name:claude" C-m
    tmux send-keys -t "$session_name:claude" "export FEATURE='$feature'"
    tmux send-keys -t "$session_name:claude" C-m

    # Create codex window
    tmux new-window -t "$session_name" -n "codex" -c "$worktree_codex"
    tmux send-keys -t "$session_name:codex" "export PEER_SYNC='$peer_sync'"
    tmux send-keys -t "$session_name:codex" C-m
    tmux send-keys -t "$session_name:codex" "export MY_NAME='codex'"
    tmux send-keys -t "$session_name:codex" C-m
    tmux send-keys -t "$session_name:codex" "export PEER_NAME='claude'"
    tmux send-keys -t "$session_name:codex" C-m
    tmux send-keys -t "$session_name:codex" "export MY_WORKTREE='$worktree_codex'"
    tmux send-keys -t "$session_name:codex" C-m
    tmux send-keys -t "$session_name:codex" "export PEER_WORKTREE='$worktree_claude'"
    tmux send-keys -t "$session_name:codex" C-m
    tmux send-keys -t "$session_name:codex" "export FEATURE='$feature'"
    tmux send-keys -t "$session_name:codex" C-m

    success "Created tmux session: $session_name"
    echo ""
    echo "Windows:"
    echo "  0: orchestrator  - Main project root"
    echo "  1: claude        - $worktree_claude"
    echo "  2: codex         - $worktree_codex"
    echo ""
    echo "Attach with: tmux attach -t $session_name"
    echo ""
    echo "To start agents, in each window run their CLI:"
    echo "  claude window: $(get_agent_cmd claude)"
    echo "  codex window:  $(get_agent_cmd codex "$codex_thinking")"
    if [ "$clarify_mode" = "true" ]; then
        echo ""
        echo "Clarify stage enabled. After agents submit their approaches:"
        echo "  1. Review approaches in .peer-sync/clarify-*.md"
        echo "  2. Respond to agents in their terminals (back-and-forth OK)"
        echo "  3. Press Enter in the orchestrator to proceed"
    fi
    if [ "$pushback_mode" = "true" ]; then
        echo ""
        echo "Pushback stage enabled. After clarify (if enabled), agents will:"
        echo "  1. Propose improvements to the task file"
        echo "  2. You can accept, reject, or modify the pushbacks"
    fi
    if [ "$plan_mode" = "true" ]; then
        echo ""
        echo "Plan stage enabled. After pushback (if enabled), agents will:"
        echo "  1. Write implementation plans"
        echo "  2. Review each other's plans before work begins"
    fi
}

start_ttyd_mode() {
    local feature="$1"
    local project_root="$2"
    local worktree_claude="$3"
    local worktree_codex="$4"
    local peer_sync="$5"
    local auto_run="${6:-false}"
    local work_timeout="${7:-$DEFAULT_WORK_TIMEOUT}"
    local review_timeout="${8:-$DEFAULT_REVIEW_TIMEOUT}"
    local max_rounds="${9:-10}"
    local codex_thinking="${10:-$DEFAULT_CODEX_THINKING}"
    local clarify_mode="${11:-false}"
    local clarify_timeout="${12:-$DEFAULT_CLARIFY_TIMEOUT}"
    local pushback_mode="${13:-false}"
    local pushback_timeout="${14:-$DEFAULT_PUSHBACK_TIMEOUT}"
    local plan_mode="${15:-false}"
    local plan_timeout="${16:-$DEFAULT_PLAN_TIMEOUT}"

    local session_name="duo-${feature}"

    # Check ttyd is installed
    command -v ttyd >/dev/null 2>&1 || die "ttyd not found. Install with: brew install ttyd"

    # Kill existing sessions if any
    tmux kill-session -t "${session_name}-orchestrator" 2>/dev/null || true
    tmux kill-session -t "${session_name}-claude" 2>/dev/null || true
    tmux kill-session -t "${session_name}-codex" 2>/dev/null || true

    # Create tmux sessions for orchestrator and each agent
    tmux new-session -d -s "${session_name}-orchestrator" -c "$project_root"
    tmux_set_title "${session_name}-orchestrator" "orchestrator: ${feature}"
    tmux new-session -d -s "${session_name}-claude" -c "$worktree_claude"
    tmux_set_title "${session_name}-claude" "claude: ${feature}"
    tmux new-session -d -s "${session_name}-codex" -c "$worktree_codex"
    tmux_set_title "${session_name}-codex" "codex: ${feature}"

    # Set environment variables for orchestrator
    for var in "PEER_SYNC='$peer_sync'" "FEATURE='$feature'"; do
        tmux send-keys -t "${session_name}-orchestrator" "export $var"
        tmux send-keys -t "${session_name}-orchestrator" C-m
    done

    # Set environment variables for agents
    for var in "PEER_SYNC='$peer_sync'" "MY_NAME='claude'" "PEER_NAME='codex'" "MY_WORKTREE='$worktree_claude'" "PEER_WORKTREE='$worktree_codex'" "FEATURE='$feature'"; do
        tmux send-keys -t "${session_name}-claude" "export $var"
        tmux send-keys -t "${session_name}-claude" C-m
    done

    for var in "PEER_SYNC='$peer_sync'" "MY_NAME='codex'" "PEER_NAME='claude'" "MY_WORKTREE='$worktree_codex'" "PEER_WORKTREE='$worktree_claude'" "FEATURE='$feature'"; do
        tmux send-keys -t "${session_name}-codex" "export $var"
        tmux send-keys -t "${session_name}-codex" C-m
    done

    # Allocate and load ports
    allocate_ports "$peer_sync" "$base_port"
    get_ports "$peer_sync"
    local orchestrator_port=$ORCHESTRATOR_PORT
    local claude_port=$CLAUDE_PORT
    local codex_port=$CODEX_PORT

    ttyd -p "$orchestrator_port" -t titleFixed="orchestrator: ${feature}" -W tmux attach -t "${session_name}-orchestrator" &
    echo $! > "$peer_sync/pids/ttyd-orchestrator.pid"

    ttyd -p "$claude_port" -t titleFixed="claude: ${feature}" -W tmux attach -t "${session_name}-claude" &
    echo $! > "$peer_sync/pids/ttyd-claude.pid"

    ttyd -p "$codex_port" -t titleFixed="codex: ${feature}" -W tmux attach -t "${session_name}-codex" &
    echo $! > "$peer_sync/pids/ttyd-codex.pid"

    success "Started ttyd servers"
    echo ""
    echo "Web terminals:"
    echo "  Orchestrator: http://localhost:$orchestrator_port"
    echo "  Claude:       http://localhost:$claude_port"
    echo "  Codex:        http://localhost:$codex_port"
    echo ""

    # If auto-run, start the orchestrator loop in the orchestrator session
    if [ "$auto_run" = "true" ]; then
        info "Starting orchestrator with --auto-start..."
        local run_cmd="agent-duo run --auto-start --work-timeout $work_timeout --review-timeout $review_timeout --max-rounds $max_rounds"
        if [ "$clarify_mode" = "true" ]; then
            run_cmd="$run_cmd --clarify-timeout $clarify_timeout"
        fi
        if [ "$pushback_mode" = "true" ]; then
            run_cmd="$run_cmd --pushback-timeout $pushback_timeout"
        fi
        if [ "$plan_mode" = "true" ]; then
            run_cmd="$run_cmd --plan-timeout $plan_timeout"
        fi
        tmux send-keys -t "${session_name}-orchestrator" "$run_cmd"
        tmux send-keys -t "${session_name}-orchestrator" C-m
    else
        echo "Start orchestrator with: agent-duo run --auto-start"
    fi
    echo "Stop with: agent-duo stop"
    if [ "$clarify_mode" = "true" ]; then
        echo ""
        echo "Clarify stage enabled. After agents submit their approaches:"
        echo "  1. Review approaches (shown in orchestrator, also emailed)"
        echo "  2. Respond to agents in their terminals (back-and-forth OK)"
        echo "  3. Press Enter in the orchestrator to proceed"
    fi
    if [ "$pushback_mode" = "true" ]; then
        echo ""
        echo "Pushback stage enabled. After clarify (if enabled), agents will:"
        echo "  1. Propose improvements to the task file"
        echo "  2. You can accept, reject, or modify the pushbacks"
    fi
    if [ "$plan_mode" = "true" ]; then
        echo ""
        echo "Plan stage enabled. After pushback (if enabled), agents will:"
        echo "  1. Write implementation plans"
        echo "  2. Review each other's plans before work begins"
    fi
}

#------------------------------------------------------------------------------
# Command: stop
#------------------------------------------------------------------------------

cmd_stop() {
    local feature_arg=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --feature) feature_arg="$2"; shift 2 ;;
            *) shift ;;
        esac
    done

    local main_root
    main_root="$(get_main_project_root 2>/dev/null)" || die "Not in a git repository"

    # If feature specified, stop just that one
    if [ -n "$feature_arg" ]; then
        local root_worktree
        root_worktree="$(get_session_root "$feature_arg" "$main_root")" || die "No session found for feature: $feature_arg"
        stop_single_session "$feature_arg" "$root_worktree" "$root_worktree/.peer-sync"
        return
    fi

    # Try to resolve session from current directory
    if resolve_session 2>/dev/null; then
        stop_single_session "$RESOLVED_FEATURE" "$RESOLVED_ROOT" "$RESOLVED_PEER_SYNC"
        return
    fi

    # In main project - stop all sessions from registry
    local sessions
    sessions="$(list_active_sessions "$main_root")"

    if [ -z "$sessions" ]; then
        die "No active sessions found."
    fi

    info "Stopping all sessions..."

    while IFS=: read -r feat root state; do
        [ -z "$feat" ] && continue
        echo ""
        info "=== Stopping: $feat ==="
        stop_single_session "$feat" "$root" "$root/.peer-sync"
    done <<< "$sessions"

    success "All sessions stopped"
}

# Stop a single session
stop_single_session() {
    local feature="$1"
    local root="$2"
    local peer_sync="$3"

    info "Stopping Agent Duo session: $feature"

    # Kill ttyd processes from PID files
    if [ -d "$peer_sync/pids" ]; then
        for pidfile in "$peer_sync/pids"/*.pid; do
            [ -f "$pidfile" ] || continue
            local pid
            pid="$(cat "$pidfile")"
            if kill -0 "$pid" 2>/dev/null; then
                kill "$pid" 2>/dev/null || true
                info "Killed process $pid ($(basename "$pidfile" .pid))"
            fi
            rm -f "$pidfile"
        done
    fi

    # Fallback: kill ttyd processes for THIS session only
    pkill -f "ttyd.*duo-${feature}-" 2>/dev/null && info "Killed remaining ttyd processes for duo-${feature}" || true

    # Kill tmux sessions for this feature
    tmux kill-session -t "duo-${feature}" 2>/dev/null && info "Killed tmux session: duo-${feature}" || true
    tmux kill-session -t "duo-${feature}-orchestrator" 2>/dev/null && info "Killed tmux session: duo-${feature}-orchestrator" || true
    tmux kill-session -t "duo-${feature}-claude" 2>/dev/null && info "Killed tmux session: duo-${feature}-claude" || true
    tmux kill-session -t "duo-${feature}-codex" 2>/dev/null && info "Killed tmux session: duo-${feature}-codex" || true

    success "Stopped: $feature"
}

#------------------------------------------------------------------------------
# Command: restart
#------------------------------------------------------------------------------

cmd_restart() {
    local auto_run=false
    local work_timeout=$DEFAULT_WORK_TIMEOUT
    local review_timeout=$DEFAULT_REVIEW_TIMEOUT
    local max_rounds=10
    local feature_arg=""
    local ttyd_mode_override=""  # Empty means use recorded setting
    local auto_finish=""         # Empty means use session default
    local auto_finish_timeout="" # Empty means use session default

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --auto-run) auto_run=true; shift ;;
            --no-ttyd) ttyd_mode_override="false"; shift ;;
            --work-timeout) work_timeout="$2"; shift 2 ;;
            --review-timeout) review_timeout="$2"; shift 2 ;;
            --max-rounds) max_rounds="$2"; shift 2 ;;
            --feature) feature_arg="$2"; shift 2 ;;
            --auto-finish) auto_finish="true"; shift ;;
            --auto-finish-timeout) auto_finish_timeout="$2"; shift 2 ;;
            -*) die "Unknown option: $1" ;;
            *) die "Unknown argument: $1" ;;
        esac
    done

    # Resolve session
    if [ -n "$feature_arg" ]; then
        resolve_session --feature "$feature_arg"
    else
        if ! resolve_session 2>/dev/null; then
            # Check if we're in main project with multiple sessions
            local main_root
            main_root="$(get_main_project_root)"
            local sessions
            sessions="$(list_active_sessions "$main_root")"
            if [ -n "$sessions" ]; then
                # Restart all sessions
                local session_count=0
                local features=()
                while IFS=: read -r feat root state; do
                    features+=("$feat")
                    session_count=$((session_count + 1))
                done <<< "$sessions"

                info "Restarting $session_count sessions..."
                local failed=0
                for feat in "${features[@]}"; do
                    echo ""
                    info "=== Restarting session: $feat ==="
                    # Build command with all the options
                    local cmd_args=(--feature "$feat")
                    cmd_args+=(--work-timeout "$work_timeout")
                    cmd_args+=(--review-timeout "$review_timeout")
                    cmd_args+=(--max-rounds "$max_rounds")
                    [ "$auto_run" = true ] && cmd_args+=(--auto-run)
                    [ "$ttyd_mode_override" = "false" ] && cmd_args+=(--no-ttyd)
                    [ -n "$auto_finish" ] && cmd_args+=(--auto-finish)
                    [ -n "$auto_finish_timeout" ] && cmd_args+=(--auto-finish-timeout "$auto_finish_timeout")

                    if ! "$0" restart "${cmd_args[@]}"; then
                        failed=$((failed + 1))
                    fi
                done

                echo ""
                if [ $failed -eq 0 ]; then
                    success "All $session_count sessions restarted"
                else
                    warn "$failed of $session_count sessions failed"
                fi
                return $failed
            fi
            die "No active session found. Use --feature <name> or cd to a session worktree."
        fi
    fi

    local root="$RESOLVED_ROOT"
    local peer_sync="$RESOLVED_PEER_SYNC"

    # Check we have an active session
    [ -f "$peer_sync/feature" ] || die "No active session (missing .peer-sync/feature)"

    # Check ttyd mode (default to true for backward compatibility with old sessions)
    # Command-line override takes precedence over recorded setting
    local ttyd_mode="true"
    if [ -n "$ttyd_mode_override" ]; then
        ttyd_mode="$ttyd_mode_override"
    elif [ -f "$peer_sync/ttyd-mode" ]; then
        ttyd_mode="$(cat "$peer_sync/ttyd-mode")"
    fi

    # For ttyd mode, we need ports
    if [ "$ttyd_mode" = "true" ]; then
        [ -f "$peer_sync/ports" ] || die "No port allocations found. Was this a ttyd session?"
    fi

    local feature="$RESOLVED_FEATURE"
    local main_root
    main_root="$(get_main_project_root)"
    local project_name
    project_name="$(basename "$main_root")"
    local parent_dir
    parent_dir="$(dirname "$main_root")"

    # Calculate paths - root worktree is the orchestrator location
    local worktree_claude="$parent_dir/${project_name}-${feature}-claude"
    local worktree_codex="$parent_dir/${project_name}-${feature}-codex"
    local session_name="duo-${feature}"

    # Load ports (only for ttyd mode)
    local orchestrator_port="" claude_port="" codex_port=""
    if [ "$ttyd_mode" = "true" ]; then
        get_ports "$peer_sync"
        orchestrator_port=$ORCHESTRATOR_PORT
        claude_port=$CLAUDE_PORT
        codex_port=$CODEX_PORT
    fi

    # Load codex thinking effort
    local codex_thinking
    codex_thinking="$(cat "$peer_sync/codex-thinking" 2>/dev/null)" || codex_thinking="$DEFAULT_CODEX_THINKING"

    echo ""
    echo "=== Agent Duo Restart ==="
    echo ""
    echo "Feature:  $feature"
    echo "Project:  $project_name"
    echo "Codex thinking: $codex_thinking"
    echo "Mode:     $([ "$ttyd_mode" = "true" ] && echo "ttyd (web terminals)" || echo "tmux (single session)")"
    echo ""

    # Ensure pids directory exists (only needed for ttyd mode, but harmless otherwise)
    mkdir -p "$peer_sync/pids"

    local errors=0
    local restarted=0

    #---------------------------------------------------------------------------
    # Phase 1: Check and restart tmux sessions
    #---------------------------------------------------------------------------
    info "Checking tmux sessions..."

    # Tmux target names depend on mode
    local orchestrator_target claude_target codex_target
    if [ "$ttyd_mode" = "true" ]; then
        # ttyd mode: separate sessions
        orchestrator_target="${session_name}-orchestrator"
        claude_target="${session_name}-claude"
        codex_target="${session_name}-codex"

        # Check orchestrator tmux session
        if ! tmux_session_exists "$orchestrator_target"; then
            info "Creating tmux session: $orchestrator_target"
            tmux new-session -d -s "$orchestrator_target" -c "$root"
            tmux_set_title "$orchestrator_target" "orchestrator: ${feature}"
            for var in "PEER_SYNC='$peer_sync'" "FEATURE='$feature'"; do
                tmux send-keys -t "$orchestrator_target" "export $var"
                tmux send-keys -t "$orchestrator_target" C-m
            done
            restarted=$((restarted + 1))
        else
            success "  orchestrator tmux session: OK"
        fi

        # Check claude tmux session
        if ! tmux_session_exists "$claude_target"; then
            if [ ! -d "$worktree_claude" ]; then
                warn "  claude worktree missing: $worktree_claude"
                errors=$((errors + 1))
            else
                info "Creating tmux session: $claude_target"
                tmux new-session -d -s "$claude_target" -c "$worktree_claude"
                tmux_set_title "$claude_target" "claude: ${feature}"
                for var in "PEER_SYNC='$peer_sync'" "MY_NAME='claude'" "PEER_NAME='codex'" "MY_WORKTREE='$worktree_claude'" "PEER_WORKTREE='$worktree_codex'" "FEATURE='$feature'"; do
                    tmux send-keys -t "$claude_target" "export $var"
                    tmux send-keys -t "$claude_target" C-m
                done
                restarted=$((restarted + 1))
            fi
        else
            success "  claude tmux session: OK"
        fi

        # Check codex tmux session
        if ! tmux_session_exists "$codex_target"; then
            if [ ! -d "$worktree_codex" ]; then
                warn "  codex worktree missing: $worktree_codex"
                errors=$((errors + 1))
            else
                info "Creating tmux session: $codex_target"
                tmux new-session -d -s "$codex_target" -c "$worktree_codex"
                tmux_set_title "$codex_target" "codex: ${feature}"
                for var in "PEER_SYNC='$peer_sync'" "MY_NAME='codex'" "PEER_NAME='claude'" "MY_WORKTREE='$worktree_codex'" "PEER_WORKTREE='$worktree_claude'" "FEATURE='$feature'"; do
                    tmux send-keys -t "$codex_target" "export $var"
                    tmux send-keys -t "$codex_target" C-m
                done
                restarted=$((restarted + 1))
            fi
        else
            success "  codex tmux session: OK"
        fi
    else
        # no-ttyd mode: single session with windows
        orchestrator_target="${session_name}:orchestrator"
        claude_target="${session_name}:claude"
        codex_target="${session_name}:codex"

        if ! tmux_session_exists "$session_name"; then
            info "Creating tmux session: $session_name"
            # Create session with orchestrator window
            tmux new-session -d -s "$session_name" -n "orchestrator" -c "$root"
            tmux_set_title "$session_name" "duo: ${feature}"

            # Create claude window
            if [ -d "$worktree_claude" ]; then
                tmux new-window -t "$session_name" -n "claude" -c "$worktree_claude"
                for var in "PEER_SYNC='$peer_sync'" "MY_NAME='claude'" "PEER_NAME='codex'" "MY_WORKTREE='$worktree_claude'" "PEER_WORKTREE='$worktree_codex'" "FEATURE='$feature'"; do
                    tmux send-keys -t "$claude_target" "export $var"
                    tmux send-keys -t "$claude_target" C-m
                done
            else
                warn "  claude worktree missing: $worktree_claude"
                errors=$((errors + 1))
            fi

            # Create codex window
            if [ -d "$worktree_codex" ]; then
                tmux new-window -t "$session_name" -n "codex" -c "$worktree_codex"
                for var in "PEER_SYNC='$peer_sync'" "MY_NAME='codex'" "PEER_NAME='claude'" "MY_WORKTREE='$worktree_codex'" "PEER_WORKTREE='$worktree_claude'" "FEATURE='$feature'"; do
                    tmux send-keys -t "$codex_target" "export $var"
                    tmux send-keys -t "$codex_target" C-m
                done
            else
                warn "  codex worktree missing: $worktree_codex"
                errors=$((errors + 1))
            fi

            restarted=$((restarted + 1))
        else
            success "  tmux session $session_name: OK"
        fi
    fi

    #---------------------------------------------------------------------------
    # Phase 2: Check and restart ttyd servers (only for ttyd mode)
    #---------------------------------------------------------------------------
    if [ "$ttyd_mode" = "true" ]; then
        echo ""
        info "Checking ttyd servers..."

        # Check orchestrator ttyd
        if ! restart_ttyd_for_session "orchestrator" "$orchestrator_port" \
                "$orchestrator_target" "$peer_sync/pids/ttyd-orchestrator.pid"; then
            errors=$((errors + 1))
        elif [ $? -eq 0 ] && ! is_port_in_use "$orchestrator_port" 2>/dev/null; then
            # Verify port came up
            sleep 0.5
            is_port_in_use "$orchestrator_port" || errors=$((errors + 1))
        fi

        # Check claude ttyd
        if ! restart_ttyd_for_session "claude" "$claude_port" \
                "$claude_target" "$peer_sync/pids/ttyd-claude.pid"; then
            errors=$((errors + 1))
        fi

        # Check codex ttyd
        if ! restart_ttyd_for_session "codex" "$codex_port" \
                "$codex_target" "$peer_sync/pids/ttyd-codex.pid"; then
            errors=$((errors + 1))
        fi
    fi

    #---------------------------------------------------------------------------
    # Phase 3: Check and restart agent TUIs
    #---------------------------------------------------------------------------
    echo ""
    info "Checking agent TUIs..."

    # Check claude TUI (thinking effort not used for claude)
    if ! restart_agent_tui "claude" "$claude_target"; then
        errors=$((errors + 1))
    fi

    # Check codex TUI (pass thinking effort)
    if ! restart_agent_tui "codex" "$codex_target" "$codex_thinking"; then
        errors=$((errors + 1))
    fi

    #---------------------------------------------------------------------------
    # Phase 4: Check orchestration state and optionally restart orchestrator
    #---------------------------------------------------------------------------
    echo ""
    info "Checking orchestration state..."

    local session_state
    session_state="$(cat "$peer_sync/session" 2>/dev/null)" || session_state="unknown"
    local phase
    phase="$(cat "$peer_sync/phase" 2>/dev/null)" || phase="unknown"
    local round
    round="$(cat "$peer_sync/round" 2>/dev/null)" || round="1"

    echo "  Session: $session_state"
    echo "  Phase:   $phase"
    echo "  Round:   $round"

    # Check if both agents have PRs (terminal state)
    local claude_has_pr=false
    local codex_has_pr=false
    [ -f "$peer_sync/claude.pr" ] && claude_has_pr=true
    [ -f "$peer_sync/codex.pr" ] && codex_has_pr=true

    if [ "$session_state" = "complete" ] || ($claude_has_pr && $codex_has_pr); then
        echo ""
        if [ -f "$peer_sync/claude.pr" ]; then
            echo "  Claude PR: $(cat "$peer_sync/claude.pr")"
        fi
        if [ -f "$peer_sync/codex.pr" ]; then
            echo "  Codex PR:  $(cat "$peer_sync/codex.pr")"
        fi
        if [ "$auto_run" = "true" ]; then
            info "PRs created. Transitioning to pr-comments phase for monitoring..."
            echo "pr-comments" > "$peer_sync/phase"
            echo "active" > "$peer_sync/session"
            local run_cmd="agent-duo run --auto-start --work-timeout $work_timeout --review-timeout $review_timeout --max-rounds $max_rounds"
            [ -n "$auto_finish" ] && run_cmd+=" --auto-finish"
            [ -n "$auto_finish_timeout" ] && run_cmd+=" --auto-finish-timeout $auto_finish_timeout"
            tmux send-keys -t "$orchestrator_target" "$run_cmd"
            tmux send-keys -t "$orchestrator_target" C-m
            success "Started PR comment monitoring"
        else
            info "PRs created. To monitor for PR comments:"
            echo "  agent-duo restart --auto-run"
        fi
    elif [ "$auto_run" = "true" ]; then
        echo ""
        info "Restarting orchestrator loop..."

        # Determine if orchestrator is already running
        local orchestrator_running=false
        if agent_tui_is_running "$orchestrator_target" "orchestrator"; then
            orchestrator_running=true
        fi

        if ! $orchestrator_running; then
            local run_cmd="agent-duo run --auto-start --work-timeout $work_timeout --review-timeout $review_timeout --max-rounds $max_rounds"
            [ -n "$auto_finish" ] && run_cmd+=" --auto-finish"
            [ -n "$auto_finish_timeout" ] && run_cmd+=" --auto-finish-timeout $auto_finish_timeout"
            tmux send-keys -t "$orchestrator_target" "$run_cmd"
            tmux send-keys -t "$orchestrator_target" C-m
            success "Started orchestrator loop"
        else
            info "Orchestrator appears to already be running"
        fi
    else
        echo ""
        info "Session is not complete. To restart the orchestrator loop:"
        echo "  agent-duo restart --auto-run"
        echo "Or manually in the orchestrator terminal:"
        echo "  agent-duo run --auto-start"
    fi

    #---------------------------------------------------------------------------
    # Summary
    #---------------------------------------------------------------------------
    echo ""
    if [ "$ttyd_mode" = "true" ]; then
        echo "--- Web Terminals ---"
        echo "Orchestrator: http://localhost:$orchestrator_port"
        echo "Claude:       http://localhost:$claude_port"
        echo "Codex:        http://localhost:$codex_port"
    else
        echo "--- tmux Session ---"
        echo "Attach with: tmux attach -t $session_name"
        echo "Windows: orchestrator, claude, codex"
    fi
    echo ""

    if [ "$errors" -gt 0 ]; then
        warn "Restart completed with $errors error(s)"
        return 1
    else
        success "Restart complete!"
        return 0
    fi
}

#------------------------------------------------------------------------------
# Command: status
#------------------------------------------------------------------------------

cmd_status() {
    local feature_arg=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --feature) feature_arg="$2"; shift 2 ;;
            *) shift ;;
        esac
    done

    if [ -n "$feature_arg" ]; then
        # Specific feature requested - show only that session
        resolve_session --feature "$feature_arg"
        show_single_status "$RESOLVED_PEER_SYNC"
    elif discover_feature_from_cwd >/dev/null 2>&1; then
        # Inside a worktree - show current session detail
        local root
        root="$(get_project_root)"
        show_single_status "$root/.peer-sync"
    else
        # At project root (or no .peer-sync found) - unified cross-type view
        local main_root
        main_root="$(get_main_project_root 2>/dev/null)" || die "Not in a git repository"
        show_all_sessions "$main_root"
    fi
}

# Unified project-root status: shows ALL session types (duo, solo, claude, codex)
show_all_sessions() {
    local main_root="$1"
    local sessions_dir="$main_root/.agent-sessions"

    if [ ! -d "$sessions_dir" ]; then
        die "No active sessions found. Start one with: agent-duo start <feature>"
    fi

    local has_any=false

    # Show orchestrated sessions (duo-* and solo-* symlinks)
    for session_link in "$sessions_dir"/duo-*.session "$sessions_dir"/solo-*.session; do
        [ -L "$session_link" ] || continue

        local filename
        filename="$(basename "$session_link" .session)"
        local entry_type="${filename%%-*}"   # "duo" or "solo"
        local feature="${filename#*-}"       # strip first prefix

        local peer_sync_path
        peer_sync_path="$(readlink "$session_link" 2>/dev/null)" || continue
        [ -d "$peer_sync_path" ] && [ -f "$peer_sync_path/session" ] || continue

        local state
        state="$(cat "$peer_sync_path/session" 2>/dev/null)"

        if [ "$has_any" = false ]; then
            has_any=true
            echo ""
            echo "=== All Sessions ==="
        fi

        echo ""
        echo "━━━ [$entry_type] $feature ($state) ━━━"
        show_single_status "$peer_sync_path"
    done

    # Show standalone launcher sessions (claude-* and codex-* plain files)
    for session_file in "$sessions_dir"/claude-*.session "$sessions_dir"/codex-*.session; do
        [ -f "$session_file" ] && [ ! -L "$session_file" ] || continue

        if [ "$has_any" = false ]; then
            has_any=true
            echo ""
            echo "=== All Sessions ==="
        fi

        local filename
        filename="$(basename "$session_file" .session)"
        local agent mode tmux_name workdir ttyd_port started
        agent="$(grep '^agent=' "$session_file" 2>/dev/null | cut -d= -f2-)"
        mode="$(grep '^mode=' "$session_file" 2>/dev/null | cut -d= -f2-)"
        tmux_name="$(grep '^tmux=' "$session_file" 2>/dev/null | cut -d= -f2-)"
        workdir="$(grep '^workdir=' "$session_file" 2>/dev/null | cut -d= -f2-)"
        ttyd_port="$(grep '^ttyd_port=' "$session_file" 2>/dev/null | cut -d= -f2-)"
        started="$(grep '^started=' "$session_file" 2>/dev/null | cut -d= -f2-)"

        local tmux_status="dead"
        if [ -n "$tmux_name" ] && tmux_session_exists "$tmux_name"; then
            tmux_status="alive"
        fi

        echo ""
        echo "━━━ $filename ━━━"
        echo "  Agent:   $agent"
        echo "  Mode:    $mode"
        echo "  tmux:    $tmux_name ($tmux_status)"
        echo "  Workdir: $workdir"
        [ -n "$ttyd_port" ] && echo "  Web URL: http://localhost:${ttyd_port}"
        [ -n "$started" ] && echo "  Started: $started"
    done

    if [ "$has_any" = false ]; then
        die "No active sessions found. Start one with: agent-duo start <feature>"
    fi
}

# Show status for a single session
show_single_status() {
    local peer_sync="$1"

    local session_mode="Duo"
    if [ -f "$peer_sync/mode" ]; then
        case "$(cat "$peer_sync/mode")" in
            solo) session_mode="Solo" ;;
            duo)  session_mode="Duo" ;;
        esac
    fi

    echo ""
    echo "=== Agent $session_mode Status ==="
    echo ""

    if [ -f "$peer_sync/feature" ]; then
        echo "Feature:  $(cat "$peer_sync/feature")"
    fi

    if [ -f "$peer_sync/session" ]; then
        echo "Session:  $(cat "$peer_sync/session")"
    fi

    if [ -f "$peer_sync/phase" ]; then
        echo "Phase:    $(cat "$peer_sync/phase")"
    fi

    if [ -f "$peer_sync/round" ]; then
        echo "Round:    $(cat "$peer_sync/round")"
    fi

    # Show allocated ports if available
    if [ -f "$peer_sync/ports" ]; then
        # shellcheck source=/dev/null
        source "$peer_sync/ports"
        echo ""
        echo "--- Web Terminals ---"
        echo "Orchestrator: http://localhost:$ORCHESTRATOR_PORT"
        echo "Claude:       http://localhost:$CLAUDE_PORT"
        echo "Codex:        http://localhost:$CODEX_PORT"
    fi

    echo ""
    echo "--- Agent Status ---"

    for agent in claude codex; do
        local status_file="$peer_sync/${agent}.status"
        if [ -f "$status_file" ]; then
            local line
            line="$(cat "$status_file")"
            local status msg timestamp
            status="$(echo "$line" | cut -d'|' -f1)"
            timestamp="$(echo "$line" | cut -d'|' -f2)"
            msg="$(echo "$line" | cut -d'|' -f3-)"

            local time_str=""
            if [ -n "$timestamp" ] && [ "$timestamp" != "$status" ]; then
                time_str=" ($(date -r "$timestamp" '+%H:%M:%S' 2>/dev/null || echo "$timestamp"))"
            fi

            printf "%-8s: %s%s" "$agent" "$status" "$time_str"
            [ -n "$msg" ] && [ "$msg" != "$status" ] && printf " - %s" "$msg"
            echo ""
        else
            echo "$agent:   (no status)"
        fi
    done

    # Check for PRs
    echo ""
    echo "--- Pull Requests ---"
    for agent in claude codex; do
        local pr_file="$peer_sync/${agent}.pr"
        if [ -f "$pr_file" ]; then
            echo "$agent:   $(cat "$pr_file")"
        else
            echo "$agent:   (none)"
        fi
    done

    # List reviews
    if [ -d "$peer_sync/reviews" ] && [ "$(ls -A "$peer_sync/reviews" 2>/dev/null)" ]; then
        echo ""
        echo "--- Reviews ---"
        ls -1 "$peer_sync/reviews"
    fi

    echo ""
}

#------------------------------------------------------------------------------
# Command: pr
#------------------------------------------------------------------------------

cmd_pr() {
    local agent=""
    local feature_arg=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --feature) feature_arg="$2"; shift 2 ;;
            -*) die "Unknown option: $1" ;;
            *) agent="$1"; shift ;;
        esac
    done

    [ -z "$agent" ] && die "Usage: agent-duo pr <agent> [--feature <name>]"

    # Resolve session
    if [ -n "$feature_arg" ]; then
        resolve_session --feature "$feature_arg"
    else
        if ! resolve_session 2>/dev/null; then
            die "No active session found. Use --feature <name> or cd to a session worktree."
        fi
    fi

    local root="$RESOLVED_ROOT"
    local peer_sync="$RESOLVED_PEER_SYNC"
    local feature="$RESOLVED_FEATURE"

    # Determine worktree - get main project root for path calculation
    local main_root
    main_root="$(get_main_project_root)"
    local project_name
    project_name="$(basename "$main_root")"
    local parent_dir
    parent_dir="$(dirname "$main_root")"
    local worktree="$parent_dir/${project_name}-${feature}-${agent}"
    local pr_name="${feature}-${agent}"

    lib_create_pr "$pr_name" "$agent" "$worktree" "$root" "$peer_sync" "$feature" "duo" "${agent}'s solution for $feature" || return 1

    # Check if both PRs exist
    if [ -f "$peer_sync/claude.pr" ] && [ -f "$peer_sync/codex.pr" ]; then
        echo "complete" > "$peer_sync/session"
        success "Both PRs created - session complete!"
        persist_workflow_feedback "$peer_sync" "$feature" "duo"
    fi
}

#------------------------------------------------------------------------------
# Command: feedback
#------------------------------------------------------------------------------

cmd_feedback() {
    local action="${1:-list}"
    shift || true

    local feedback_dir
    feedback_dir="$(workflow_feedback_dir)"

    case "$action" in
        list)
            if [ ! -d "$feedback_dir" ] || [ -z "$(ls -A "$feedback_dir" 2>/dev/null)" ]; then
                info "No accumulated workflow feedback."
                return 0
            fi
            info "Accumulated workflow feedback:"
            echo ""
            ls -1 "$feedback_dir" | while read -r file; do
                local filepath="$feedback_dir/$file"
                local lines
                lines="$(wc -l < "$filepath" | tr -d ' ')"
                echo "  $file ($lines lines)"
            done
            ;;
        view)
            local file="$1"
            [ -z "$file" ] && die "Usage: agent-duo feedback view <filename>"
            local filepath="$feedback_dir/$file"
            [ ! -f "$filepath" ] && die "Feedback file not found: $file"
            cat "$filepath"
            ;;
        delete)
            local file="$1"
            [ -z "$file" ] && die "Usage: agent-duo feedback delete <filename|--all>"
            if [ "$file" = "--all" ]; then
                rm -rf "$feedback_dir"
                success "All feedback deleted"
            else
                local filepath="$feedback_dir/$file"
                [ ! -f "$filepath" ] && die "Feedback file not found: $file"
                rm "$filepath"
                success "Deleted: $file"
            fi
            ;;
        submit)
            if [ ! -d "$feedback_dir" ] || [ -z "$(ls -A "$feedback_dir" 2>/dev/null)" ]; then
                die "No feedback to submit"
            fi

            # Check for gh CLI
            if ! command -v gh >/dev/null 2>&1; then
                die "GitHub CLI (gh) not found. Install it or submit feedback manually."
            fi

            # List files for selection
            info "Available feedback files:"
            local files=()
            local i=1
            while IFS= read -r file; do
                files+=("$file")
                echo "  $i) $file"
                i=$((i + 1))
            done < <(ls -1 "$feedback_dir")

            echo ""
            echo "Enter file number to submit (or 'all' to combine all): "
            read -r selection

            local body=""
            local title=""

            if [ "$selection" = "all" ]; then
                title="Workflow feedback from agent sessions"
                for file in "${files[@]}"; do
                    body+="# From: $file"$'\n\n'
                    body+="$(cat "$feedback_dir/$file")"$'\n\n'
                    body+="---"$'\n\n'
                done
            else
                local idx=$((selection - 1))
                if [ "$idx" -lt 0 ] || [ "$idx" -ge "${#files[@]}" ]; then
                    die "Invalid selection"
                fi
                local selected="${files[$idx]}"
                title="Workflow feedback: $selected"
                body="$(cat "$feedback_dir/$selected")"
            fi

            echo ""
            echo "Title: $title"
            echo ""
            echo "Body preview (first 500 chars):"
            echo "${body:0:500}..."
            echo ""
            echo "Submit this feedback to agent-duo GitHub issues? [y/N] "
            read -r confirm

            if [ "$confirm" = "y" ] || [ "$confirm" = "Y" ]; then
                # Get configured repo or prompt
                local repo
                repo="$(get_config_value "feedback_repo" 2>/dev/null)" || repo=""
                if [ -z "$repo" ]; then
                    echo "Enter GitHub repo (e.g., owner/repo): "
                    read -r repo
                    if [ -z "$repo" ]; then
                        die "No repo specified"
                    fi
                    echo "Save this repo for future submissions? [y/N] "
                    read -r save_repo
                    if [ "$save_repo" = "y" ] || [ "$save_repo" = "Y" ]; then
                        set_config_value "feedback_repo" "$repo"
                        success "Saved feedback_repo=$repo"
                    fi
                fi
                info "Creating issue in $repo..."
                echo "$body" | gh issue create --title "$title" --body-file - --repo "$repo" 2>/dev/null || \
                    warn "Could not create issue. Check repo access or submit manually."
            else
                info "Submission cancelled. You can copy the feedback manually."
            fi
            ;;
        digest)
            # Check ludics is available
            if ! command -v ludics >/dev/null 2>&1; then
                die "ludics CLI not found on PATH. Install ludics first."
            fi

            # Check feedback files exist (excluding processed/)
            local has_files=false
            if [ -d "$feedback_dir" ]; then
                for f in "$feedback_dir"/*.md; do
                    [ -f "$f" ] && { has_files=true; break; }
                done
            fi
            if [ "$has_files" = false ]; then
                die "No feedback files to digest"
            fi

            # Get configured repo or prompt
            local repo
            repo="$(get_config_value "feedback_repo" 2>/dev/null)" || repo=""
            if [ -z "$repo" ]; then
                echo "Enter GitHub repo for feedback issues (e.g., owner/repo): "
                read -r repo
                [ -z "$repo" ] && die "No repo specified"
                echo "Save this repo for future digests? [y/N] "
                read -r save_repo
                if [ "$save_repo" = "y" ] || [ "$save_repo" = "Y" ]; then
                    set_config_value "feedback_repo" "$repo"
                    success "Saved feedback_repo=$repo"
                fi
            fi

            info "Queuing feedback digest via ludics mag..."
            ludics mag feedback-digest "$repo"
            success "Feedback digest queued. Run 'ludics mag queue' to check status."
            ;;
        *)
            die "Unknown feedback action: $action (valid: list, view, delete, submit, digest)"
            ;;
    esac
}

#------------------------------------------------------------------------------
# Command: cleanup
#------------------------------------------------------------------------------

cmd_cleanup() {
    local full=false
    local feature_arg=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --full) full=true; shift ;;
            --feature) feature_arg="$2"; shift 2 ;;
            *) shift ;;
        esac
    done

    local main_root
    main_root="$(get_main_project_root 2>/dev/null)" || die "Not in a git repository"

    # If feature specified, clean just that one
    if [ -n "$feature_arg" ]; then
        cleanup_single_session "$feature_arg" "$main_root" "$full"
        return
    fi

    # Try to resolve session from current directory
    if resolve_session 2>/dev/null; then
        cleanup_single_session "$RESOLVED_FEATURE" "$main_root" "$full"
        return
    fi

    # In main project - clean all sessions from registry
    local sessions
    sessions="$(list_active_sessions "$main_root")"

    if [ -z "$sessions" ]; then
        die "No active sessions found."
    fi

    local count=0
    while IFS=: read -r feat root state; do
        [ -z "$feat" ] && continue
        count=$((count + 1))
    done <<< "$sessions"

    info "Cleaning up $count session(s)..."

    while IFS=: read -r feat root state; do
        [ -z "$feat" ] && continue
        echo ""
        info "=== Cleaning up: $feat ==="
        cleanup_single_session "$feat" "$main_root" "$full"
    done <<< "$sessions"

    success "All sessions cleaned up"
}

# Cleanup a single session (multi-session mode)
cleanup_single_session() {
    local feature="$1"
    local main_root="$2"
    local full="$3"

    local project_name
    project_name="$(basename "$main_root")"
    local parent_dir
    parent_dir="$(dirname "$main_root")"
    local sessions_dir="$main_root/.agent-sessions"

    # Get root worktree path
    local root_worktree="$parent_dir/${project_name}-${feature}"
    local peer_sync="$root_worktree/.peer-sync"

    info "Cleaning up session: $feature"

    # Stop any running processes first
    if [ -d "$peer_sync" ]; then
        # Temporarily set variables for cmd_stop
        RESOLVED_FEATURE="$feature"
        RESOLVED_ROOT="$root_worktree"
        RESOLVED_PEER_SYNC="$peer_sync"
        stop_single_session "$feature" "$root_worktree" "$peer_sync"
    fi

    # Accumulate workflow feedback before cleanup
    persist_workflow_feedback "$peer_sync" "$feature" "duo"

    # Remove session from registry
    if [ -L "$sessions_dir/duo-${feature}.session" ]; then
        rm -f "$sessions_dir/duo-${feature}.session"
        info "Removed from registry"
    fi

    # Remove .peer-sync from root worktree
    if [ -d "$peer_sync" ]; then
        rm -rf "$peer_sync"
        info "Removed .peer-sync"
    fi

    if [ "$full" = "true" ]; then
        local worktree_claude="$parent_dir/${project_name}-${feature}-claude"
        local worktree_codex="$parent_dir/${project_name}-${feature}-codex"

        cd "$main_root"  # Make sure we're in main repo for git operations

        # Remove agent worktrees
        if [ -d "$worktree_claude" ]; then
            git worktree remove --force "$worktree_claude" 2>/dev/null || rm -rf "$worktree_claude"
            info "Removed worktree: $worktree_claude"
        fi

        if [ -d "$worktree_codex" ]; then
            git worktree remove --force "$worktree_codex" 2>/dev/null || rm -rf "$worktree_codex"
            info "Removed worktree: $worktree_codex"
        fi

        # Remove root worktree
        if [ -d "$root_worktree" ]; then
            git worktree remove --force "$root_worktree" 2>/dev/null || rm -rf "$root_worktree"
            info "Removed root worktree: $root_worktree"
        fi

        # Prune worktree references
        git worktree prune

        # Delete local branches
        git branch -D "${feature}" 2>/dev/null && info "Deleted local branch: ${feature}" || true
        git branch -D "${feature}-claude" 2>/dev/null && info "Deleted local branch: ${feature}-claude" || true
        git branch -D "${feature}-codex" 2>/dev/null && info "Deleted local branch: ${feature}-codex" || true

        # Delete remote branches
        git push origin --delete "${feature}" 2>/dev/null && info "Deleted remote branch: origin/${feature}" || true
        git push origin --delete "${feature}-claude" 2>/dev/null && info "Deleted remote branch: origin/${feature}-claude" || true
        git push origin --delete "${feature}-codex" 2>/dev/null && info "Deleted remote branch: origin/${feature}-codex" || true
    fi

    success "Cleanup complete for $feature"
}

#------------------------------------------------------------------------------
# Command: merge - Start merge phase to consolidate PRs
#------------------------------------------------------------------------------

# Get merge vote file path for agent at given round
# Args: peer_sync agent round
get_merge_vote_file() {
    local peer_sync="$1"
    local agent="$2"
    local round="$3"
    echo "$peer_sync/merge-votes/round-${round}-${agent}-vote.md"
}

# Get current merge round (defaults to 0 if not set)
get_merge_round() {
    local peer_sync="$1"
    local round_file="$peer_sync/merge-round"
    if [ -f "$round_file" ]; then
        cat "$round_file"
    else
        echo "0"
    fi
}

# Extract vote from a merge-vote file (returns "claude" or "codex")
extract_vote() {
    local vote_file="$1"
    if [ ! -f "$vote_file" ]; then
        echo ""
        return
    fi
    # Look for "## My Vote: claude" or "## My Vote: codex" pattern
    grep -i "^## My Vote:" "$vote_file" | head -1 | sed 's/.*: *\([a-z]*\).*/\1/' | tr '[:upper:]' '[:lower:]'
}

# Check if both agents have voted in current round
both_voted() {
    local peer_sync="$1"
    local round
    round="$(get_merge_round "$peer_sync")"
    local claude_file codex_file
    claude_file="$(get_merge_vote_file "$peer_sync" "claude" "$round")"
    codex_file="$(get_merge_vote_file "$peer_sync" "codex" "$round")"
    [ -f "$claude_file" ] && [ -f "$codex_file" ]
}

# Check if votes agree in current round
votes_agree() {
    local peer_sync="$1"
    local round
    round="$(get_merge_round "$peer_sync")"
    local claude_file codex_file claude_vote codex_vote
    claude_file="$(get_merge_vote_file "$peer_sync" "claude" "$round")"
    codex_file="$(get_merge_vote_file "$peer_sync" "codex" "$round")"
    claude_vote="$(extract_vote "$claude_file")"
    codex_vote="$(extract_vote "$codex_file")"
    [ -n "$claude_vote" ] && [ "$claude_vote" = "$codex_vote" ]
}

# Get the agreed vote (or empty if no agreement) from current round
get_agreed_vote() {
    local peer_sync="$1"
    local round
    round="$(get_merge_round "$peer_sync")"
    local claude_file codex_file claude_vote codex_vote
    claude_file="$(get_merge_vote_file "$peer_sync" "claude" "$round")"
    codex_file="$(get_merge_vote_file "$peer_sync" "codex" "$round")"
    claude_vote="$(extract_vote "$claude_file")"
    codex_vote="$(extract_vote "$codex_file")"
    if [ -n "$claude_vote" ] && [ "$claude_vote" = "$codex_vote" ]; then
        echo "$claude_vote"
    else
        echo ""
    fi
}

# Generate merge vote message for agents (sent at start of merge phase)
generate_merge_vote_message() {
    local agent="$1"
    local peer="$2"
    local feature="$3"
    local peer_sync="$4"
    local claude_pr="$5"
    local codex_pr="$6"
    local round="${7:-0}"

    cat <<EOF
# Merge Phase: Vote on PR to Merge

Both PRs are ready. You must analyze them and vote on which one to merge.

---
## Agent-Duo Context - MERGE VOTE PHASE

You are **$agent** in a fresh merge session. This is NOT the agent who created either PR.

**Your Task**: Objectively evaluate both solutions and vote.

### PRs to Evaluate

- **Claude's PR**: $claude_pr
- **Codex's PR**: $codex_pr

### Environment

- **Working directory**: Main branch (project root)
- **Sync directory**: $peer_sync
- **Feature**: $feature
- **Merge round**: $round

### Steps

1. Read the original task: \`cat "$feature.md"\`
2. View both PRs: \`gh pr view <url>\` and \`gh pr diff <url>\`
3. Read previous reviews: \`ls "$peer_sync/reviews/" 2>/dev/null && cat "$peer_sync/reviews/"*.md\`

### Write Your Vote

\`\`\`bash
mkdir -p "$peer_sync/merge-votes"
cat > "$peer_sync/merge-votes/round-${round}-${agent}-vote.md" << 'VOTE_EOF'
# Merge Vote from $agent (Round $round)

## Summary of Claude's PR
[2-3 sentences on approach and key decisions]

## Summary of Codex's PR
[2-3 sentences on approach and key decisions]

## Comparison
| Aspect | Claude's PR | Codex's PR |
|--------|-------------|------------|
| Code quality | | |
| Test coverage | | |
| Alignment with task | | |

## My Vote: [claude / codex]

### Rationale
[3-5 sentences explaining your choice]

### Features to Cherry-Pick from Losing PR
[List specific features that should be incorporated]

VOTE_EOF
\`\`\`

Edit with actual content, then signal:

\`\`\`bash
agent-duo signal "$agent" vote-done "merge vote submitted"
\`\`\`

Then **STOP and wait** for consensus check.
EOF
}

# Generate merge debate message for agents (triggered when votes disagree)
generate_merge_debate_message() {
    local agent="$1"
    local peer="$2"
    local feature="$3"
    local peer_sync="$4"
    local debate_round="$5"

    local prev_round=$((debate_round - 1))

    cat <<EOF
# Merge Phase: Debate Round $debate_round

Your vote differs from $peer's. Review their reasoning and respond.

---
## Agent-Duo Context - MERGE DEBATE

Read your peer's latest vote and your previous vote:

\`\`\`bash
# Your peer's vote from round $prev_round
cat "$peer_sync/merge-votes/round-${prev_round}-${peer}-vote.md"

# Your previous vote from round $prev_round
cat "$peer_sync/merge-votes/round-${prev_round}-${agent}-vote.md"
\`\`\`

Then write your debate response as a new vote file:

\`\`\`bash
cat > "$peer_sync/merge-votes/round-${debate_round}-${agent}-vote.md" << 'VOTE_EOF'
# Merge Vote from $agent (Debate Round $debate_round)

## Response to $peer's Arguments
[Address their key points. What do you agree/disagree with?]

## My Vote: [claude / codex]

### Position: [CHANGED / UNCHANGED]

### Rationale
[If changed: what convinced you. If unchanged: why their arguments don't outweigh yours]

### Features to Cherry-Pick from Losing PR
[Updated list combining insights from both analyses]

VOTE_EOF
\`\`\`

Edit with actual content, then signal:

\`\`\`bash
agent-duo signal "$agent" debate-done "debate response submitted"
\`\`\`

Then **STOP and wait**.
EOF
}

#------------------------------------------------------------------------------
# Trigger final merge for single remaining PR (auto-finish mode)
# Usage: trigger_final_merge <agent> <session> <peer_sync> <tui_exit_behavior>
#------------------------------------------------------------------------------
trigger_final_merge() {
    local agent="$1"
    local session="$2"
    local peer_sync="$3"
    local tui_exit_behavior="${4:-$DEFAULT_TUI_EXIT_BEHAVIOR}"

    local pr_url
    pr_url="$(cat "$peer_sync/${agent}.pr")"

    echo "final-merge" > "$peer_sync/phase"
    check_tui_health "$agent" "$session" "$peer_sync" "$tui_exit_behavior"
    atomic_write "$peer_sync/${agent}.status" "working|$(date +%s)|performing final merge"

    info "Triggering duo-final-merge for $agent..."
    send_to_agent "$agent" "$session" "$peer_sync" skill "duo-final-merge"

    # Wait for completion
    local merge_start=$SECONDS
    local merge_timeout=600  # 10 minutes

    while true; do
        local elapsed=$((SECONDS - merge_start))
        local status
        status="$(get_agent_status "$agent" "$peer_sync")"

        if [[ "$status" =~ ^(final-merge-done|done)$ ]]; then
            success "Final merge completed by $agent"
            break
        fi

        # Check for API errors and retry
        check_and_retry_on_error "$agent" "$session" "$peer_sync"

        if [ "$elapsed" -ge "$merge_timeout" ]; then
            warn "Final merge timeout (${merge_timeout}s)"
            break
        fi

        printf "\r  Waiting for final merge... %s=%s (%ds)  " "$agent" "$status" "$elapsed"
        sleep 5
    done
    echo ""

    # Check if PR was merged
    if is_pr_merged "$pr_url"; then
        success "PR merged successfully!"
        echo "accepted" > "$peer_sync/session"
    else
        warn "PR not yet merged - agent may need manual intervention"
    fi
}

# Run merge orchestration - starts fresh agent sessions for unbiased voting
# Called from orchestrator terminal via cmd_merge or automatic trigger
cmd_run_merge() {
    local root
    root="$(get_project_root)"
    local peer_sync="$root/.peer-sync"
    local feature
    feature="$(get_feature)"

    # Validate both PRs exist
    if ! has_pr "claude" "$peer_sync" || ! has_pr "codex" "$peer_sync"; then
        die "Both PRs must exist before merge phase. Run 'agent-duo pr <agent>' first."
    fi

    local claude_pr codex_pr
    claude_pr="$(cat "$peer_sync/claude.pr")"
    codex_pr="$(cat "$peer_sync/codex.pr")"

    info "=== Merge Phase ==="
    echo "Claude PR: $claude_pr"
    echo "Codex PR:  $codex_pr"
    echo ""

    # Check if PRs are still open
    local claude_open=false codex_open=false
    is_pr_open "$claude_pr" && claude_open=true
    is_pr_open "$codex_pr" && codex_open=true

    if ! $claude_open && ! $codex_open; then
        die "Both PRs are already closed/merged. Nothing to do."
    fi

    # Initialize merge phase state
    echo "merge" > "$peer_sync/phase"
    echo "0" > "$peer_sync/merge-round"
    rm -rf "$peer_sync/merge-votes"
    mkdir -p "$peer_sync/merge-votes"
    rm -f "$peer_sync/merge-decision"

    local session_name="duo-${feature}"

    # Find existing agent sessions
    local claude_session codex_session
    if tmux has-session -t "$session_name" 2>/dev/null; then
        # Non-ttyd mode: windows in main session
        claude_session="${session_name}:claude"
        codex_session="${session_name}:codex"
    elif tmux has-session -t "${session_name}-claude" 2>/dev/null; then
        # ttyd mode: separate sessions
        claude_session="${session_name}-claude"
        codex_session="${session_name}-codex"
    else
        die "No agent sessions found. Run 'agent-duo restart' first."
    fi

    # Load codex thinking effort from session
    local codex_thinking
    codex_thinking="$(cat "$peer_sync/codex-thinking" 2>/dev/null)" || codex_thinking="$DEFAULT_CODEX_THINKING"

    # Restart agents with fresh context for unbiased merge vote
    # We keep the tmux sessions (for ttyd) but restart the agent CLIs
    info "Restarting agents with fresh context for unbiased merge vote..."

    # Stop existing agents: Ctrl-C to interrupt, then exit
    for session in "$claude_session" "$codex_session"; do
        tmux send-keys -t "$session" C-c
        sleep 0.3
        tmux send-keys -t "$session" C-c
        sleep 0.3
        # Send /exit for Claude Code, or just exit for shell
        tmux send-keys -t "$session" "/exit"
        tmux send-keys -t "$session" C-m
        sleep 0.5
    done

    # Wait for agents to fully exit
    sleep 2

    # Change to project root (main branch) and set up fresh environment
    for session in "$claude_session" "$codex_session"; do
        tmux send-keys -t "$session" "cd '$root'"
        tmux send-keys -t "$session" C-m
    done

    # Set environment variables for both agents
    for var in "PEER_SYNC='$peer_sync'" "MY_NAME='claude'" "PEER_NAME='codex'" "FEATURE='$feature'"; do
        tmux send-keys -t "$claude_session" "export $var"
        tmux send-keys -t "$claude_session" C-m
    done
    for var in "PEER_SYNC='$peer_sync'" "MY_NAME='codex'" "PEER_NAME='claude'" "FEATURE='$feature'"; do
        tmux send-keys -t "$codex_session" "export $var"
        tmux send-keys -t "$codex_session" C-m
    done

    # Start fresh agent CLIs
    info "Starting fresh agent CLIs..."
    tmux send-keys -t "$claude_session" "$(get_agent_cmd claude)"
    tmux send-keys -t "$claude_session" C-m
    tmux send-keys -t "$codex_session" "$(get_agent_cmd codex "$codex_thinking")"
    tmux send-keys -t "$codex_session" C-m

    # Wait for agents to initialize
    sleep 3
    success "Fresh agent sessions started on main branch."
    echo ""

    # Timeouts
    local vote_timeout="${VOTE_TIMEOUT:-10800}"
    local debate_timeout="${DEBATE_TIMEOUT:-2400}"
    local max_debate_rounds=2
    local poll_interval=5

    # === VOTE PHASE ===
    info "=== Vote Phase ==="

    # Send vote messages to both agents
    local round
    round="$(get_merge_round "$peer_sync")"

    atomic_write "$peer_sync/claude.status" "voting|$(date +%s)|merge vote phase"
    info "Sending vote request to claude..."
    local claude_vote_msg
    claude_vote_msg="$(generate_merge_vote_message "claude" "codex" "$feature" "$peer_sync" "$claude_pr" "$codex_pr" "$round")"
    send_to_agent "claude" "$claude_session" "$peer_sync" message "$claude_vote_msg" "merge-vote"

    atomic_write "$peer_sync/codex.status" "voting|$(date +%s)|merge vote phase"
    info "Sending vote request to codex..."
    local codex_vote_msg
    codex_vote_msg="$(generate_merge_vote_message "codex" "claude" "$feature" "$peer_sync" "$claude_pr" "$codex_pr" "$round")"
    send_to_agent "codex" "$codex_session" "$peer_sync" message "$codex_vote_msg" "merge-vote"

    # Wait for both votes
    local vote_start=$SECONDS
    local claude_voted=false codex_voted=false

    while ! ($claude_voted && $codex_voted); do
        local elapsed=$((SECONDS - vote_start))

        local claude_status codex_status
        claude_status="$(get_agent_status "claude" "$peer_sync")"
        codex_status="$(get_agent_status "codex" "$peer_sync")"

        [ "$claude_status" = "vote-done" ] && claude_voted=true
        [ "$codex_status" = "vote-done" ] && codex_voted=true

        if $claude_voted && $codex_voted; then
            break
        fi

        # Check for API errors and retry if needed
        if ! $claude_voted; then
            check_and_retry_on_error "claude" "$claude_session" "$peer_sync"
        fi
        if ! $codex_voted; then
            check_and_retry_on_error "codex" "$codex_session" "$peer_sync"
        fi

        if [ "$elapsed" -ge "$vote_timeout" ]; then
            warn "Vote phase timeout (${vote_timeout}s)"
            # Interrupt agents that haven't voted and create synthetic vote files
            local round
            round="$(get_merge_round "$peer_sync")"
            if ! $claude_voted; then
                interrupt_agent "claude" "$claude_session" "$peer_sync"
                local claude_vote_file
                claude_vote_file="$(get_merge_vote_file "$peer_sync" "claude" "$round")"
                if [ ! -f "$claude_vote_file" ]; then
                    mkdir -p "$peer_sync/merge-votes"
                    cat > "$claude_vote_file" << 'SYNTH_EOF'
# Merge Vote from claude (INTERRUPTED)

## My Vote: interrupted

### Rationale
Agent was interrupted by orchestrator due to vote phase timeout.
SYNTH_EOF
                    warn "Created synthetic interrupted vote for claude"
                fi
            fi
            if ! $codex_voted; then
                interrupt_agent "codex" "$codex_session" "$peer_sync"
                local codex_vote_file
                codex_vote_file="$(get_merge_vote_file "$peer_sync" "codex" "$round")"
                if [ ! -f "$codex_vote_file" ]; then
                    mkdir -p "$peer_sync/merge-votes"
                    cat > "$codex_vote_file" << 'SYNTH_EOF'
# Merge Vote from codex (INTERRUPTED)

## My Vote: interrupted

### Rationale
Agent was interrupted by orchestrator due to vote phase timeout.
SYNTH_EOF
                    warn "Created synthetic interrupted vote for codex"
                fi
            fi
            break
        fi

        printf "\r  Waiting... claude=%s codex=%s (%ds/%ds)  " "$claude_status" "$codex_status" "$elapsed" "$vote_timeout"
        sleep "$poll_interval"
    done
    echo ""

    # === CONSENSUS CHECK ===
    local current_round
    current_round="$(get_merge_round "$peer_sync")"
    local decision=""

    while [ -z "$decision" ] && [ "$current_round" -lt "$max_debate_rounds" ]; do
        if votes_agree "$peer_sync"; then
            decision="$(get_agreed_vote "$peer_sync")"
            success "Consensus reached: merge $decision's PR"
            break
        fi

        # Votes disagree - start debate
        current_round=$((current_round + 1))
        echo "$current_round" > "$peer_sync/merge-round"

        info "=== Debate Round $current_round ==="
        local claude_vote codex_vote
        local claude_file codex_file prev_round
        prev_round=$((current_round - 1))
        claude_file="$(get_merge_vote_file "$peer_sync" "claude" "$prev_round")"
        codex_file="$(get_merge_vote_file "$peer_sync" "codex" "$prev_round")"
        claude_vote="$(extract_vote "$claude_file")"
        codex_vote="$(extract_vote "$codex_file")"
        echo "  Claude votes: $claude_vote"
        echo "  Codex votes:  $codex_vote"
        echo ""

        # Send debate messages
        atomic_write "$peer_sync/claude.status" "debating|$(date +%s)|debate round $current_round"
        local claude_debate_msg
        claude_debate_msg="$(generate_merge_debate_message "claude" "codex" "$feature" "$peer_sync" "$current_round")"
        send_to_agent "claude" "$claude_session" "$peer_sync" message "$claude_debate_msg" "merge-debate"

        atomic_write "$peer_sync/codex.status" "debating|$(date +%s)|debate round $current_round"
        local codex_debate_msg
        codex_debate_msg="$(generate_merge_debate_message "codex" "claude" "$feature" "$peer_sync" "$current_round")"
        send_to_agent "codex" "$codex_session" "$peer_sync" message "$codex_debate_msg" "merge-debate"

        # Wait for debate responses
        local debate_start=$SECONDS
        local claude_debated=false codex_debated=false

        while ! ($claude_debated && $codex_debated); do
            local elapsed=$((SECONDS - debate_start))

            local claude_status codex_status
            claude_status="$(get_agent_status "claude" "$peer_sync")"
            codex_status="$(get_agent_status "codex" "$peer_sync")"

            [ "$claude_status" = "debate-done" ] && claude_debated=true
            [ "$codex_status" = "debate-done" ] && codex_debated=true

            if $claude_debated && $codex_debated; then
                break
            fi

            # Check for API errors and retry if needed
            if ! $claude_debated; then
                check_and_retry_on_error "claude" "$claude_session" "$peer_sync"
            fi
            if ! $codex_debated; then
                check_and_retry_on_error "codex" "$codex_session" "$peer_sync"
            fi

            if [ "$elapsed" -ge "$debate_timeout" ]; then
                warn "Debate timeout (${debate_timeout}s)"
                # Interrupt agents that haven't responded and create synthetic debate vote files
                if ! $claude_debated; then
                    interrupt_agent "claude" "$claude_session" "$peer_sync"
                    local claude_debate_file
                    claude_debate_file="$(get_merge_vote_file "$peer_sync" "claude" "$current_round")"
                    if [ ! -f "$claude_debate_file" ]; then
                        mkdir -p "$peer_sync/merge-votes"
                        cat > "$claude_debate_file" << 'SYNTH_EOF'
# Merge Vote from claude (Debate - INTERRUPTED)

## My Vote: interrupted

### Rationale
Agent was interrupted by orchestrator due to debate phase timeout.
SYNTH_EOF
                        warn "Created synthetic interrupted debate vote for claude"
                    fi
                fi
                if ! $codex_debated; then
                    interrupt_agent "codex" "$codex_session" "$peer_sync"
                    local codex_debate_file
                    codex_debate_file="$(get_merge_vote_file "$peer_sync" "codex" "$current_round")"
                    if [ ! -f "$codex_debate_file" ]; then
                        mkdir -p "$peer_sync/merge-votes"
                        cat > "$codex_debate_file" << 'SYNTH_EOF'
# Merge Vote from codex (Debate - INTERRUPTED)

## My Vote: interrupted

### Rationale
Agent was interrupted by orchestrator due to debate phase timeout.
SYNTH_EOF
                        warn "Created synthetic interrupted debate vote for codex"
                    fi
                fi
                break
            fi

            printf "\r  Waiting... claude=%s codex=%s (%ds/%ds)  " "$claude_status" "$codex_status" "$elapsed" "$debate_timeout"
            sleep "$poll_interval"
        done
        echo ""
    done

    # === ESCALATE TO USER IF NO CONSENSUS ===
    if [ -z "$decision" ]; then
        warn "No consensus after $max_debate_rounds debate rounds."
        echo ""
        local final_round
        final_round="$(get_merge_round "$peer_sync")"
        local claude_final codex_final
        claude_final="$(get_merge_vote_file "$peer_sync" "claude" "$final_round")"
        codex_final="$(get_merge_vote_file "$peer_sync" "codex" "$final_round")"

        echo "--- Claude's Final Vote ---"
        cat "$claude_final"
        echo ""
        echo "--- Codex's Final Vote ---"
        cat "$codex_final"
        echo ""
        echo "=================================="
        echo ""
        info "Options:"
        echo "  [c] - Merge Claude's PR"
        echo "  [x] - Merge Codex's PR"
        echo ""
        read -r -p "Your decision: " user_choice

        case "$user_choice" in
            c|C) decision="claude" ;;
            x|X) decision="codex" ;;
            *) die "Invalid choice. Run 'agent-duo merge' again." ;;
        esac
        info "User decided: merge $decision's PR"
    fi

    # Record decision
    echo "$decision" > "$peer_sync/merge-decision"

    # === EXECUTION PHASE ===
    info "=== Merge Execution Phase ==="

    # Determine roles based on decision
    # "Losing" agent does the merge + cherry-pick work
    # "Winning" agent reviews
    local executor reviewer
    if [ "$decision" = "claude" ]; then
        executor="codex"
        reviewer="claude"
    else
        executor="claude"
        reviewer="codex"
    fi

    info "Executor (merge + cherry-pick): $executor"
    info "Reviewer: $reviewer"

    # Trigger merge-execute skill for executor
    local executor_session
    [ "$executor" = "claude" ] && executor_session="$claude_session" || executor_session="$codex_session"

    atomic_write "$peer_sync/${executor}.status" "merging|$(date +%s)|executing merge"
    info "Triggering duo-merge-execute for $executor..."
    send_to_agent "$executor" "$executor_session" "$peer_sync" skill "duo-merge-execute"

    # Wait for merge execution
    local merge_timeout="${MERGE_TIMEOUT:-900}"
    local merge_start=$SECONDS
    local merge_done=false

    while ! $merge_done; do
        local elapsed=$((SECONDS - merge_start))
        local executor_status
        executor_status="$(get_agent_status "$executor" "$peer_sync")"

        [ "$executor_status" = "merge-done" ] && merge_done=true

        if $merge_done; then
            break
        fi

        # Check for API errors and retry if needed
        check_and_retry_on_error "$executor" "$executor_session" "$peer_sync"

        if [ "$elapsed" -ge "$merge_timeout" ]; then
            warn "Merge execution timeout (${merge_timeout}s)"
            break
        fi

        printf "\r  Waiting for merge... %s=%s (%ds/%ds)  " "$executor" "$executor_status" "$elapsed" "$merge_timeout"
        sleep "$poll_interval"
    done
    echo ""

    # === REVIEW/AMEND LOOP ===
    local reviewer_session executor_session
    [ "$reviewer" = "claude" ] && reviewer_session="$claude_session" || reviewer_session="$codex_session"
    [ "$executor" = "claude" ] && executor_session="$claude_session" || executor_session="$codex_session"

    local review_timeout="${MERGE_REVIEW_TIMEOUT:-600}"
    local amend_timeout="${MERGE_AMEND_TIMEOUT:-600}"
    local max_amend_rounds=3
    local amend_round=0
    local merge_approved=false

    while ! $merge_approved && [ "$amend_round" -lt "$max_amend_rounds" ]; do
        # === REVIEW PHASE ===
        info "=== Merge Review Phase ==="

        atomic_write "$peer_sync/${reviewer}.status" "merge-reviewing|$(date +%s)|reviewing merge"
        info "Triggering duo-merge-review for $reviewer..."
        send_to_agent "$reviewer" "$reviewer_session" "$peer_sync" skill "duo-merge-review"

        # Wait for review
        local review_start=$SECONDS
        local review_done=false

        while ! $review_done; do
            local elapsed=$((SECONDS - review_start))
            local reviewer_status
            reviewer_status="$(get_agent_status "$reviewer" "$peer_sync")"

            [ "$reviewer_status" = "merge-review-done" ] && review_done=true

            if $review_done; then
                break
            fi

            # Check for API errors and retry if needed
            check_and_retry_on_error "$reviewer" "$reviewer_session" "$peer_sync"

            if [ "$elapsed" -ge "$review_timeout" ]; then
                warn "Merge review timeout (${review_timeout}s)"
                break
            fi

            printf "\r  Waiting for review... %s=%s (%ds/%ds)  " "$reviewer" "$reviewer_status" "$elapsed" "$review_timeout"
            sleep "$poll_interval"
        done
        echo ""

        # Check review result
        if [ ! -f "$peer_sync/merge-review-${reviewer}.md" ]; then
            # No review file - this is unexpected, notify user and re-trigger review
            warn "No merge review file found - reviewer may be in bad state"
            send_ntfy "Merge review missing" "No review file from $reviewer. Re-triggering review." "default" "warning,robot" 2>/dev/null || true
            # Don't increment amend_round - this is a retry of review, not an amend
            # Loop will continue and re-trigger duo-merge-review
            continue
        fi

        # Check for explicit approval (require "APPROVED" to pass)
        if grep -qi "APPROVED" "$peer_sync/merge-review-${reviewer}.md" && \
           ! grep -qi "CHANGES REQUESTED" "$peer_sync/merge-review-${reviewer}.md"; then
            merge_approved=true
            success "Merge approved!"
        else
            # Either explicit "CHANGES REQUESTED" or ambiguous review
            amend_round=$((amend_round + 1))
            if grep -qi "CHANGES REQUESTED" "$peer_sync/merge-review-${reviewer}.md"; then
                warn "Review requested changes (round $amend_round/$max_amend_rounds)"
            else
                warn "Review result ambiguous (no clear APPROVED) - treating as changes requested (round $amend_round/$max_amend_rounds)"
                send_ntfy "Ambiguous merge review" "Review from $reviewer unclear. Treating as changes requested." "default" "warning,robot" 2>/dev/null || true
            fi

            if [ "$amend_round" -ge "$max_amend_rounds" ]; then
                warn "Max amend rounds reached. Manual intervention needed."
                break
            fi

            # === AMEND PHASE ===
            info "=== Merge Amend Phase (round $amend_round) ==="

            atomic_write "$peer_sync/${executor}.status" "merging|$(date +%s)|addressing review feedback"
            info "Triggering duo-merge-amend for $executor..."
            send_to_agent "$executor" "$executor_session" "$peer_sync" skill "duo-merge-amend"

            # Wait for amend
            local amend_start=$SECONDS
            local amend_done=false

            while ! $amend_done; do
                local elapsed=$((SECONDS - amend_start))
                local executor_status
                executor_status="$(get_agent_status "$executor" "$peer_sync")"

                [ "$executor_status" = "merge-done" ] && amend_done=true

                if $amend_done; then
                    break
                fi

                # Check for API errors and retry if needed
                check_and_retry_on_error "$executor" "$executor_session" "$peer_sync"

                if [ "$elapsed" -ge "$amend_timeout" ]; then
                    warn "Merge amend timeout (${amend_timeout}s)"
                    break
                fi

                printf "\r  Waiting for amend... %s=%s (%ds/%ds)  " "$executor" "$executor_status" "$elapsed" "$amend_timeout"
                sleep "$poll_interval"
            done
            echo ""

            # Clear the old review for next round
            rm -f "$peer_sync/merge-review-${reviewer}.md"
        fi
    done

    echo ""
    info "=== Merge Phase Complete ==="

    if $merge_approved; then
        # Get the winning PR URL
        local winning_pr
        winning_pr="$(cat "$peer_sync/${decision}.pr")"

        echo "Cherry-picks consolidated into $decision's PR: $winning_pr"
        echo "Losing PR has been closed."
        echo ""
        success "Winning PR is ready for human merge!"

        # Notify user that PR is ready
        send_ntfy "PR ready for merge" "$decision's PR ($winning_pr) has cherry-picks incorporated and is ready for merge to main." "high" "white_check_mark,rocket" 2>/dev/null || true

        # Return to PR-comments phase for the winning PR only
        echo "pr-comments" > "$peer_sync/phase"
        info "Returning to PR comment watch phase for final review..."
    else
        warn "Merge phase ended without approval. Manual intervention may be needed."
        if [ -f "$peer_sync/merge-review-${reviewer}.md" ]; then
            echo "See merge review: $peer_sync/merge-review-${reviewer}.md"
        fi
    fi
}

#------------------------------------------------------------------------------
# Command: merge (user-level command - sends merge to orchestrator terminal)
#------------------------------------------------------------------------------

cmd_merge() {
    local auto_restart=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --auto-restart) auto_restart=true; shift ;;
            -*) die "Unknown option: $1" ;;
            *) die "Unknown argument: $1" ;;
        esac
    done

    local root
    root="$(get_project_root)"
    local peer_sync="$root/.peer-sync"
    local feature
    feature="$(get_feature)"

    # Validate session and PRs exist
    if [ ! -d "$peer_sync" ]; then
        die "No session found. Start with 'agent-duo start <feature>' first."
    fi

    if ! has_pr "claude" "$peer_sync" || ! has_pr "codex" "$peer_sync"; then
        die "Both PRs must exist before merge phase. Run 'agent-duo pr <agent>' first."
    fi

    local claude_pr codex_pr
    claude_pr="$(cat "$peer_sync/claude.pr")"
    codex_pr="$(cat "$peer_sync/codex.pr")"

    info "=== Starting Merge Phase ==="
    echo "Feature: $feature"
    echo "Claude PR: $claude_pr"
    echo "Codex PR:  $codex_pr"
    echo ""

    # Check if PRs are still open
    local claude_open=false codex_open=false
    is_pr_open "$claude_pr" && claude_open=true
    is_pr_open "$codex_pr" && codex_open=true

    if ! $claude_open && ! $codex_open; then
        die "Both PRs are already closed/merged. Nothing to do."
    fi

    # Find orchestrator session
    local session_name="duo-${feature}"
    local orchestrator_session=""

    if tmux has-session -t "${session_name}-orchestrator" 2>/dev/null; then
        orchestrator_session="${session_name}-orchestrator"
    elif tmux has-session -t "$session_name" 2>/dev/null; then
        # Non-ttyd mode: orchestrator is a window in the main session
        orchestrator_session="${session_name}:orchestrator"
    else
        if $auto_restart; then
            info "No orchestrator session found. Auto-restarting..."
            # Run restart to recreate sessions, then proceed
            cmd_restart
            # After restart, find the session again
            if tmux has-session -t "${session_name}-orchestrator" 2>/dev/null; then
                orchestrator_session="${session_name}-orchestrator"
            elif tmux has-session -t "$session_name" 2>/dev/null; then
                orchestrator_session="${session_name}:orchestrator"
            else
                die "Failed to restart sessions."
            fi
        else
            die "No orchestrator session found. Run 'agent-duo restart' or use 'agent-duo merge --auto-restart'."
        fi
    fi

    info "Sending merge command to orchestrator terminal..."

    # Send Ctrl-C to ensure the terminal is ready (cancel any running command)
    tmux send-keys -t "$orchestrator_session" C-c
    sleep 0.5

    # Send the run-merge command
    tmux send-keys -t "$orchestrator_session" "agent-duo run-merge"
    tmux send-keys -t "$orchestrator_session" C-m

    success "Merge command sent to orchestrator."
    echo ""
    echo "The orchestrator terminal will:"
    echo "  1. Start fresh agent sessions for unbiased voting"
    echo "  2. Run the vote → debate → execute → review flow"
    echo ""
    echo "Monitor progress in the orchestrator terminal (ttyd or tmux)."
}

#------------------------------------------------------------------------------
# Command: signal (for agents)
#------------------------------------------------------------------------------

cmd_signal() {
    local agent="$1"
    local status="$2"
    local message="${3:-}"

    [ -z "$agent" ] || [ -z "$status" ] && die "Usage: agent-duo signal <agent> <status> [message]"

    local root
    root="$(get_project_root)"
    local peer_sync="$root/.peer-sync"

    # Validate status
    case "$status" in
        clarifying|clarify-done|pushing-back|pushback-done|planning|plan-done|plan-reviewing|plan-review-done|needs-clarify|working|done|reviewing|review-done|updating-docs|docs-update-done|integrating|integrate-done|final-merging|final-merge-done|suggest-refactor-done|interrupted|error|pr-created|escalated|voting|vote-done|debating|debate-done|merging|merge-done|merge-reviewing|merge-review-done) ;;
        *) die "Invalid status: $status (valid: clarifying, clarify-done, pushing-back, pushback-done, planning, plan-done, plan-reviewing, plan-review-done, needs-clarify, working, done, reviewing, review-done, updating-docs, docs-update-done, integrating, integrate-done, final-merging, final-merge-done, suggest-refactor-done, interrupted, error, pr-created, escalated, voting, vote-done, debating, debate-done, merging, merge-done, merge-reviewing, merge-review-done)" ;;
    esac

    local content="${status}|$(date +%s)|${message}"
    atomic_write "$peer_sync/${agent}.status" "$content"
    if [ "$status" = "docs-update-done" ]; then
        touch "$peer_sync/docs-update-${agent}.done"
    fi

    success "$agent status: $status"
}

#------------------------------------------------------------------------------
# Command: peer-status (for agents)
#------------------------------------------------------------------------------

cmd_peer_status() {
    local peer="${PEER_NAME:-}"
    [ -z "$peer" ] && die "PEER_NAME not set. Are you in an agent session?"

    local root
    root="$(get_project_root)"
    local peer_sync="$root/.peer-sync"
    local status_file="$peer_sync/${peer}.status"

    if [ -f "$status_file" ]; then
        cat "$status_file"
    else
        echo "unknown"
    fi
}

#------------------------------------------------------------------------------
# Command: phase (for agents)
#------------------------------------------------------------------------------

cmd_phase() {
    local root
    root="$(get_project_root)"
    local peer_sync="$root/.peer-sync"

    if [ -f "$peer_sync/phase" ]; then
        cat "$peer_sync/phase"
    else
        echo "unknown"
    fi
}

#------------------------------------------------------------------------------
# Command: learn (for agents - record project learnings)
#------------------------------------------------------------------------------

cmd_learn() {
    local title="${1:-}"

    [ -z "$title" ] && die "Usage: agent-duo learn \"<title>\" [content]
       Or pipe content: echo 'details' | agent-duo learn \"<title>\""

    shift || true
    local content="$*"

    # Get agent name
    local agent="${MY_NAME:-unknown}"
    local feature="${FEATURE:-unknown}"

    # Determine worktree root (where AGENTS_STAGING.md should live)
    local worktree_root="${MY_WORKTREE:-$(pwd)}"

    # If content not provided as argument, read from stdin
    if [ -z "$content" ]; then
        if [ -t 0 ]; then
            # No stdin, no content - just create a placeholder
            content=""
        else
            content="$(cat)"
        fi
    fi

    local staging_file="$worktree_root/AGENTS_STAGING.md"
    local date_str
    date_str="$(date +%Y-%m-%d)"

    # Create file with header if it doesn't exist
    if [ ! -f "$staging_file" ]; then
        cat > "$staging_file" << 'EOF'
# Agent Learnings (Staging)

This file contains learnings discovered by AI agents during development sessions.
Periodically review and consolidate valuable entries into `CLAUDE.md` or `AGENTS.md`.

---

EOF
    fi

    # Append the learning entry
    cat >> "$staging_file" << EOF

<!-- Entry: ${feature}-${agent} | ${date_str} -->
### ${title}

${content}
<!-- End entry -->
EOF

    success "Learning recorded to AGENTS_STAGING.md"
}

#------------------------------------------------------------------------------
# Command: workflow-feedback (for agents - record feedback about agent-duo)
#------------------------------------------------------------------------------

cmd_workflow_feedback() {
    local category="${1:-}"

    [ -z "$category" ] && die "Usage: agent-duo workflow-feedback <category> [content]
       Categories: skill-unclear, coordination, tooling, friction, other
       Or pipe content: echo 'details' | agent-duo workflow-feedback <category>"

    shift || true
    local content="$*"

    # Validate category
    case "$category" in
        skill-unclear|coordination|tooling|friction|other) ;;
        *) die "Invalid category: $category (valid: skill-unclear, coordination, tooling, friction, other)" ;;
    esac

    # Get agent name and session info
    local agent="${MY_NAME:-unknown}"
    local feature="${FEATURE:-unknown}"

    # Get project root with .peer-sync
    local root
    root="$(get_project_root)"
    local peer_sync="$root/.peer-sync"

    # If content not provided as argument, read from stdin
    if [ -z "$content" ]; then
        if [ -t 0 ]; then
            die "No feedback content provided. Provide as argument or pipe to stdin."
        else
            content="$(cat)"
        fi
    fi

    local feedback_file="$peer_sync/workflow-feedback-${agent}.md"
    local date_str
    date_str="$(date +%Y-%m-%d)"
    local timestamp
    timestamp="$(date +%H:%M:%S)"

    # Create file with header if it doesn't exist
    if [ ! -f "$feedback_file" ]; then
        cat > "$feedback_file" << EOF
# Workflow Feedback - ${agent}

Session: ${feature}
Agent: ${agent}

---

EOF
    fi

    # Append the feedback entry
    cat >> "$feedback_file" << EOF

## [${category}] ${date_str} ${timestamp}

${content}

---
EOF

    success "Workflow feedback recorded"
}

#------------------------------------------------------------------------------
# Command: confirm (user confirms clarify phase completion)
#------------------------------------------------------------------------------

cmd_confirm() {
    local root
    root="$(get_project_root)"
    local peer_sync="$root/.peer-sync"

    # Check we're in clarify phase
    local phase
    phase="$(cat "$peer_sync/phase" 2>/dev/null)" || die "No active session"

    if [ "$phase" != "clarify" ]; then
        if [ -f "$peer_sync/clarify-confirmed" ]; then
            info "Clarify phase already confirmed."
        else
            die "Not in clarify phase (current phase: $phase)"
        fi
        return 0
    fi

    # Mark clarify as confirmed
    echo "confirmed" > "$peer_sync/clarify-confirmed"

    # Transition to work phase
    echo "work" > "$peer_sync/phase"

    success "Clarify phase confirmed! Transitioning to work phase."
    echo "Note: If orchestrator is waiting for input, press Enter there to continue."
}

#------------------------------------------------------------------------------
# Command: escalate (for agents to flag issues needing user input)
#------------------------------------------------------------------------------

cmd_escalate() {
    local reason="$1"
    local message="${2:-}"

    [ -z "$reason" ] && die "Usage: agent-duo escalate <reason> [message]
Reasons:
  ambiguity     - Requirements are unclear, need clarification
  inconsistency - Conflicting requirements or code/docs mismatch
  misguided     - Evidence the task approach is wrong"

    # Validate reason
    case "$reason" in
        ambiguity|inconsistency|misguided) ;;
        *) die "Invalid reason: $reason (valid: ambiguity, inconsistency, misguided)" ;;
    esac

    local agent="${AGENT_NAME:-}"
    [ -z "$agent" ] && die "AGENT_NAME not set. Are you in an agent session?"

    local root
    root="$(get_project_root)"
    local peer_sync="$root/.peer-sync"

    # Write escalation file with details
    local escalation_file="$peer_sync/escalation-${agent}.md"
    {
        echo "# Escalation from $agent"
        echo ""
        echo "**Reason:** $reason"
        echo "**Time:** $(date)"
        echo ""
        if [ -n "$message" ]; then
            echo "## Details"
            echo ""
            echo "$message"
        fi
    } > "$escalation_file"

    # Update agent status to escalated
    local content="escalated|$(date +%s)|$reason: ${message:-no details}"
    atomic_write "$peer_sync/${agent}.status" "$content"

    success "Escalation filed: $reason"
    info "The orchestrator will pause before advancing phases."
    info "Continue your current work - you won't be interrupted."
}

#------------------------------------------------------------------------------
# Command: escalate-resolve (user resolves an escalation)
#------------------------------------------------------------------------------

cmd_escalate_resolve() {
    local root
    root="$(get_project_root)"
    local peer_sync="$root/.peer-sync"

    # Find pending escalations
    local escalations=()
    for f in "$peer_sync"/escalation-*.md; do
        [ -f "$f" ] && escalations+=("$f")
    done

    if [ ${#escalations[@]} -eq 0 ]; then
        info "No pending escalations."
        return 0
    fi

    # Display all escalations
    echo ""
    info "=== Pending Escalations ==="
    echo ""
    for f in "${escalations[@]}"; do
        cat "$f"
        echo ""
        echo "---"
        echo ""
    done

    # Prompt for resolution
    echo "Options:"
    echo "  1. Resolve all escalations (agents will continue normally)"
    echo "  2. Cancel (keep escalations pending)"
    echo ""
    read -r -p "Choice [1/2]: " choice

    case "$choice" in
        1)
            # Remove escalation files
            for f in "${escalations[@]}"; do
                rm -f "$f"
            done

            # Mark escalations as resolved
            echo "resolved|$(date +%s)" > "$peer_sync/escalation-resolved"

            success "Escalations resolved. Orchestrator will continue."
            echo "Note: If orchestrator is waiting, press Enter there to continue."
            ;;
        2|*)
            info "Escalations remain pending."
            ;;
    esac
}

# Note: send_clarify_notification is provided by agent-lib.sh
# It tries ntfy first (if configured), then email

#------------------------------------------------------------------------------
# Generate clarify phase message for agents
#------------------------------------------------------------------------------

generate_clarify_message() {
    local agent="$1"
    local peer="$2"
    local feature="$3"
    local task_content="$4"
    local peer_worktree="$5"
    local peer_sync="$6"

    cat <<EOF
# Task: $feature

$task_content

---
## Agent-Duo Context - CLARIFY PHASE

You are **$agent** in a duo workflow with **$peer** as your peer.

**PHASE: CLARIFY** - Before starting implementation, propose your high-level approach and ask clarifying questions.

### Your Environment

- **Your worktree**: Current directory
- **Peer's worktree**: $peer_worktree (read-only)
- **Sync directory**: $peer_sync

### Your Task

Produce TWO outputs:

1. **High-level approach** - Not a detailed plan, but a sketch: the key idea, first steps to explore, or general direction
2. **Clarifying questions** - Questions for the user that would help you start more effectively

### Write Your Approach and Questions

\`\`\`bash
cat > "$peer_sync/clarify-${agent}.md" << 'CLARIFY_EOF'
# Clarification from $agent

## Proposed Approach

[Write 3-5 sentences describing your high-level approach.]

## Questions for the User

1. [Question 1]
2. [Question 2]
3. [Question 3 - optional]

CLARIFY_EOF
\`\`\`

Edit the file with actual content, then signal completion:

\`\`\`bash
agent-duo signal "$agent" clarify-done "approach and questions submitted"
\`\`\`

Then **STOP and wait**. The user will review your approach and respond in this terminal.
Do NOT start implementing until the work phase begins.
EOF
}

#------------------------------------------------------------------------------
# Generate pushback stage message for agents
#------------------------------------------------------------------------------

generate_pushback_message() {
    local agent="$1"
    local peer="$2"
    local feature="$3"
    local task_content="$4"
    local peer_worktree="$5"
    local peer_sync="$6"

    cat <<EOF
# Task: $feature

$task_content

---
## Agent-Duo Context - PUSHBACK STAGE

You are **$agent** in a duo workflow with **$peer** as your peer.

**STAGE: PUSHBACK** - Before starting implementation, you may propose improvements to the task specification.

### Your Environment

- **Your worktree**: Current directory
- **Peer's worktree**: $peer_worktree (read-only)
- **Sync directory**: $peer_sync

### Purpose

The task file may specify both a goal and a plan. Sometimes the plan is suboptimal or could be improved. This is your opportunity to suggest modifications that would lead to a better solution.

### Your Task

Consider:
1. Is the stated plan the best approach to achieve the core goal?
2. Are there better alternatives or optimizations?
3. Are there missing requirements or edge cases?

### Modify the Task File Directly

If you believe the task could be improved, edit \`$feature.md\` directly in your worktree. The user will compare versions using diff3.

If the task is well-specified and needs no changes, skip to writing your rationale.

### Write Your Rationale

\`\`\`bash
cat > "$peer_sync/pushback-${agent}.md" << 'PUSHBACK_EOF'
# Pushback from $agent

## Summary of Proposed Changes

[1-3 sentences explaining what you changed and why, or "No changes proposed - the task is well-specified."]

## Reasoning

[Explain why your changes would improve the solution quality, or why the original is already good]

PUSHBACK_EOF
\`\`\`

Edit the file with actual content, then signal completion:

\`\`\`bash
agent-duo signal "$agent" pushback-done "proposed task modifications submitted"
\`\`\`

Then **STOP and wait**. The user will review task file changes (via diff3) and rationales, then decide whether to accept, reject, or modify.
Do NOT start implementing until the work phase begins.
EOF
}

#------------------------------------------------------------------------------
# Command: run (orchestrator)
#------------------------------------------------------------------------------

# Note: get_agent_status, has_pr, interrupt_agent, nudge_agent, and
# trigger_skill are all provided by agent-lib.sh

# Generate augmented first-round message with full context
# This replaces the need for /duo-work skill in round 1
generate_round1_message() {
    local agent="$1"
    local peer="$2"
    local feature="$3"
    local task_content="$4"
    local peer_worktree="$5"
    local peer_sync="$6"

    cat <<EOF
# Task: $feature

$task_content

---
## Agent-Duo Context

You are **$agent** in a duo workflow with **$peer** as your peer.
Both of you are developing **alternative solutions** in parallel.

- **Phase**: Work (Round 1)
- **Your worktree**: Current directory (read/write)
- **Peer's worktree**: $peer_worktree (read-only - look but don't touch)
- **Sync directory**: $peer_sync

### Your Goal

Implement your solution independently. Your peer works in parallel on the same task.

### Guidelines

1. **Diverge to explore the search space**: Produce an *alternative* solution, not a copy
2. **Different tradeoffs are good**: If peer chose approach A, consider approach B
3. **Read peer's code for insight, not imitation**
4. **Focus on your implementation**: Make progress on your own solution, convergence is fine if it arises organically from a confident consensus

### Checking Peer's Progress (Optional)

\`\`\`bash
agent-duo peer-status
git -C "$peer_worktree" diff
\`\`\`

### If You Discover a Blocking Issue

If you find ambiguity, inconsistency, or evidence the task is misguided — escalate:
\`\`\`bash
agent-duo escalate ambiguity "requirements unclear: what should happen when X?"
agent-duo escalate inconsistency "docs say X but code does Y"
agent-duo escalate misguided "this feature already exists in module Z"
\`\`\`
This notifies the user without interrupting your work. Continue with your best interpretation.

### When Done

Signal completion and **STOP**:
\`\`\`bash
agent-duo signal "$agent" done "brief summary of what you did"
\`\`\`

The orchestrator will then trigger the review phase.

### When Ready to Submit Final PR

Before creating your PR, capture learnings (you may be prompted to run update-docs).
Then create your PR:
\`\`\`bash
agent-duo pr "$agent"   # handles doc updates (if needed), commit, push, and sync
# or: gh pr create ...  # also works, orchestrator will detect it
\`\`\`
EOF
}

cmd_run() {
    local work_timeout=$DEFAULT_WORK_TIMEOUT
    local review_timeout=$DEFAULT_REVIEW_TIMEOUT
    local clarify_timeout=$DEFAULT_CLARIFY_TIMEOUT
    local pushback_timeout=$DEFAULT_PUSHBACK_TIMEOUT
    local plan_timeout=$DEFAULT_PLAN_TIMEOUT
    local poll_interval=$DEFAULT_POLL_INTERVAL
    local max_rounds=10
    local auto_start=false
    local enable_clarify=""  # empty means use session default
    local enable_pushback="" # empty means use session default
    local enable_plan=""     # empty means use session default
    local enable_auto_finish=""  # empty means use session default
    local auto_finish_timeout=""  # empty means use session default
    local tui_exit_behavior=$DEFAULT_TUI_EXIT_BEHAVIOR

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --work-timeout) work_timeout="$2"; shift 2 ;;
            --review-timeout) review_timeout="$2"; shift 2 ;;
            --clarify-timeout) clarify_timeout="$2"; shift 2 ;;
            --pushback-timeout) pushback_timeout="$2"; shift 2 ;;
            --plan-timeout) plan_timeout="$2"; shift 2 ;;
            --clarify) enable_clarify="true"; shift ;;
            --pushback) enable_pushback="true"; shift ;;
            --plan) enable_plan="true"; shift ;;
            --auto-finish) enable_auto_finish="true"; shift ;;
            --auto-finish-timeout) auto_finish_timeout="$2"; shift 2 ;;
            --poll) poll_interval="$2"; shift 2 ;;
            --max-rounds) max_rounds="$2"; shift 2 ;;
            --auto-start) auto_start=true; shift ;;
            --on-tui-exit) tui_exit_behavior="$2"; shift 2 ;;
            -*) die "Unknown option: $1" ;;
            *) die "Unknown argument: $1" ;;
        esac
    done

    # Must be run from within a session worktree
    local root
    root="$(get_project_root 2>/dev/null)" || die "Not in an agent-duo session. Run from the orchestrator worktree."
    local peer_sync="$root/.peer-sync"
    [ -f "$peer_sync/feature" ] || die "No active session (missing .peer-sync/feature)"

    local feature
    feature="$(get_feature)"

    # Determine tmux session name
    local session_name="duo-${feature}"

    # Check tmux session exists
    if ! tmux has-session -t "$session_name" 2>/dev/null; then
        # Try ttyd-style separate sessions
        if tmux has-session -t "${session_name}-claude" 2>/dev/null; then
            local claude_session="${session_name}-claude"
            local codex_session="${session_name}-codex"
        else
            die "No tmux session found. Run 'agent-duo restart' to resume, or 'agent-duo start $feature' to start fresh."
        fi
    else
        local claude_session="${session_name}:claude"
        local codex_session="${session_name}:codex"
    fi

    echo ""
    echo "=== Agent Duo Orchestrator ==="
    echo "Feature:        $feature"
    echo "Work timeout:   ${work_timeout}s"
    echo "Review timeout: ${review_timeout}s"
    echo "Max rounds:     $max_rounds"
    echo ""

    # Calculate worktree paths for augmented messages
    local project_name
    project_name="$(basename "$root")"
    local parent_dir
    parent_dir="$(dirname "$root")"
    local worktree_claude="$parent_dir/${project_name}-${feature}-claude"
    local worktree_codex="$parent_dir/${project_name}-${feature}-codex"

    # Load codex thinking effort from session
    local codex_thinking
    codex_thinking="$(cat "$peer_sync/codex-thinking" 2>/dev/null)" || codex_thinking="$DEFAULT_CODEX_THINKING"

    # Optionally auto-start agents (only if not already running)
    if $auto_start; then
        info "Starting agents..."
        if ! agent_tui_is_running "$claude_session" "claude"; then
            tmux send-keys -t "$claude_session" "$(get_agent_cmd claude)"
            tmux send-keys -t "$claude_session" C-m
        fi
        if ! agent_tui_is_running "$codex_session" "codex"; then
            tmux send-keys -t "$codex_session" "$(get_agent_cmd codex "$codex_thinking")"
            tmux send-keys -t "$codex_session" C-m
        fi
        sleep 3
        # Task will be sent as augmented round 1 message or clarify message below
    fi

    # Check if clarify mode is enabled (command line overrides session setting)
    local clarify_mode
    if [ -n "$enable_clarify" ]; then
        clarify_mode="$enable_clarify"
        echo "$enable_clarify" > "$peer_sync/clarify-mode"
    else
        clarify_mode="$(cat "$peer_sync/clarify-mode" 2>/dev/null)" || clarify_mode="false"
    fi

    # Check if auto-finish mode is enabled (command line overrides session setting)
    local auto_finish
    if [ -n "$enable_auto_finish" ]; then
        auto_finish="$enable_auto_finish"
        echo "$enable_auto_finish" > "$peer_sync/auto-finish"
    else
        auto_finish="$(cat "$peer_sync/auto-finish" 2>/dev/null)" || auto_finish="false"
    fi
    if [ -z "$auto_finish_timeout" ]; then
        auto_finish_timeout="$(cat "$peer_sync/auto-finish-timeout" 2>/dev/null)" || auto_finish_timeout="$DEFAULT_AUTO_FINISH_TIMEOUT"
    else
        echo "$auto_finish_timeout" > "$peer_sync/auto-finish-timeout"
    fi

    # Handle clarify phase if enabled and not already confirmed
    if [ "$clarify_mode" = "true" ] && [ ! -f "$peer_sync/clarify-confirmed" ]; then
        info "=== Clarify Phase ==="
        echo "clarify" > "$peer_sync/phase"

        # Read task content
        local task_file
        local task_content=""
        if task_file="$(find_task_file "$root" "$feature")"; then
            task_content="$(cat "$task_file" | head -c 4000)"
        fi

        # Send clarify message to both agents
        atomic_write "$peer_sync/claude.status" "clarifying|$(date +%s)|clarify phase"
        info "Sending clarify task to claude..."
        local claude_clarify_msg
        claude_clarify_msg="$(generate_clarify_message "claude" "codex" "$feature" "$task_content" "$worktree_codex" "$peer_sync")"
        send_to_agent "claude" "$claude_session" "$peer_sync" message "$claude_clarify_msg" "clarify"

        atomic_write "$peer_sync/codex.status" "clarifying|$(date +%s)|clarify phase"
        info "Sending clarify task to codex..."
        local codex_clarify_msg
        codex_clarify_msg="$(generate_clarify_message "codex" "claude" "$feature" "$task_content" "$worktree_claude" "$peer_sync")"
        send_to_agent "codex" "$codex_session" "$peer_sync" message "$codex_clarify_msg" "clarify"

        # Wait for both agents to complete clarify phase
        local clarify_start=$SECONDS
        local claude_clarify_done=false
        local codex_clarify_done=false

        while ! ($claude_clarify_done && $codex_clarify_done); do
            local elapsed=$((SECONDS - clarify_start))

            # Check for completion
            local claude_status
            claude_status="$(get_agent_status "claude" "$peer_sync")"
            local codex_status
            codex_status="$(get_agent_status "codex" "$peer_sync")"

            [ "$claude_status" = "clarify-done" ] && claude_clarify_done=true
            [ "$codex_status" = "clarify-done" ] && codex_clarify_done=true

            if $claude_clarify_done && $codex_clarify_done; then
                break
            fi

            # Check if agent TUIs have exited unexpectedly
            if ! $claude_clarify_done; then
                check_tui_health "claude" "$claude_session" "$peer_sync" "$tui_exit_behavior"
                check_and_retry_on_error "claude" "$claude_session" "$peer_sync"
            fi
            if ! $codex_clarify_done; then
                check_tui_health "codex" "$codex_session" "$peer_sync" "$tui_exit_behavior"
                check_and_retry_on_error "codex" "$codex_session" "$peer_sync"
            fi

            # Check timeout
            if [ "$elapsed" -ge "$clarify_timeout" ]; then
                warn "Clarify phase timeout (${clarify_timeout}s)"
                # Don't interrupt - just proceed with whatever was submitted
                break
            fi

            printf "\r  Waiting... claude=%s codex=%s (%ds/%ds)  " "$claude_status" "$codex_status" "$elapsed" "$clarify_timeout"
            sleep "$poll_interval"
        done
        echo ""

        # Send notification with clarify results (ntfy and/or email)
        send_clarify_notification "$peer_sync" "$feature" "duo"

        # Display clarify results
        echo ""
        info "=== Clarify Phase Results ==="
        echo ""

        if [ -f "$peer_sync/clarify-claude.md" ]; then
            echo "--- Claude's Approach ---"
            cat "$peer_sync/clarify-claude.md"
            echo ""
        else
            warn "Claude did not submit a clarification"
        fi

        if [ -f "$peer_sync/clarify-codex.md" ]; then
            echo "--- Codex's Approach ---"
            cat "$peer_sync/clarify-codex.md"
            echo ""
        else
            warn "Codex did not submit a clarification"
        fi

        echo ""
        echo "=================================="
        echo ""
        info "Respond to agents in their terminals if needed."
        echo ""
        read -r -p "Press Enter when ready to proceed... "

        # Mark clarify as confirmed
        echo "confirmed" > "$peer_sync/clarify-confirmed"

        success "Clarify stage confirmed!"
        echo ""
    fi

    # Check if pushback mode is enabled (command line overrides session setting)
    local pushback_mode
    if [ -n "$enable_pushback" ]; then
        pushback_mode="$enable_pushback"
        echo "$enable_pushback" > "$peer_sync/pushback-mode"
    else
        pushback_mode="$(cat "$peer_sync/pushback-mode" 2>/dev/null)" || pushback_mode="false"
    fi

    # Handle pushback stage if enabled and not already confirmed
    if [ "$pushback_mode" = "true" ] && [ ! -f "$peer_sync/pushback-confirmed" ]; then
        info "=== Pushback Stage ==="
        echo "pushback" > "$peer_sync/phase"

        # Find task file
        local task_file
        local task_content=""
        if task_file="$(find_task_file "$root" "$feature")"; then
            task_content="$(cat "$task_file" | head -c 4000)"
        fi
        local task_basename="${feature}.md"

        # Send pushback message to both agents
        atomic_write "$peer_sync/claude.status" "pushing-back|$(date +%s)|pushback stage"
        info "Sending pushback task to claude..."
        local claude_pushback_msg
        claude_pushback_msg="$(generate_pushback_message "claude" "codex" "$feature" "$task_content" "$worktree_codex" "$peer_sync")"
        send_to_agent "claude" "$claude_session" "$peer_sync" message "$claude_pushback_msg" "pushback"

        atomic_write "$peer_sync/codex.status" "pushing-back|$(date +%s)|pushback stage"
        info "Sending pushback task to codex..."
        local codex_pushback_msg
        codex_pushback_msg="$(generate_pushback_message "codex" "claude" "$feature" "$task_content" "$worktree_claude" "$peer_sync")"
        send_to_agent "codex" "$codex_session" "$peer_sync" message "$codex_pushback_msg" "pushback"

        # Wait for both agents to complete pushback stage
        local pushback_start=$SECONDS
        local claude_pushback_done=false
        local codex_pushback_done=false

        while ! ($claude_pushback_done && $codex_pushback_done); do
            local elapsed=$((SECONDS - pushback_start))

            # Check for completion
            local claude_status
            claude_status="$(get_agent_status "claude" "$peer_sync")"
            local codex_status
            codex_status="$(get_agent_status "codex" "$peer_sync")"

            [ "$claude_status" = "pushback-done" ] && claude_pushback_done=true
            [ "$codex_status" = "pushback-done" ] && codex_pushback_done=true

            if $claude_pushback_done && $codex_pushback_done; then
                break
            fi

            # Check if agent TUIs have exited unexpectedly
            if ! $claude_pushback_done; then
                check_tui_health "claude" "$claude_session" "$peer_sync" "$tui_exit_behavior"
                check_and_retry_on_error "claude" "$claude_session" "$peer_sync"
            fi
            if ! $codex_pushback_done; then
                check_tui_health "codex" "$codex_session" "$peer_sync" "$tui_exit_behavior"
                check_and_retry_on_error "codex" "$codex_session" "$peer_sync"
            fi

            # Check timeout
            if [ "$elapsed" -ge "$pushback_timeout" ]; then
                warn "Pushback stage timeout (${pushback_timeout}s)"
                break
            fi

            printf "\r  Waiting... claude=%s codex=%s (%ds/%ds)  " "$claude_status" "$codex_status" "$elapsed" "$pushback_timeout"
            sleep "$poll_interval"
        done
        echo ""

        # Send notification with pushback results
        send_pushback_notification "$peer_sync" "$feature" "duo"

        # Display pushback results
        echo ""
        info "=== Pushback Stage Results ==="
        echo ""

        if [ -f "$peer_sync/pushback-claude.md" ]; then
            echo "--- Claude's Pushback ---"
            cat "$peer_sync/pushback-claude.md"
            echo ""
        else
            warn "Claude did not submit a pushback"
        fi

        if [ -f "$peer_sync/pushback-codex.md" ]; then
            echo "--- Codex's Pushback ---"
            cat "$peer_sync/pushback-codex.md"
            echo ""
        else
            warn "Codex did not submit a pushback"
        fi

        echo ""
        echo "=================================="
        echo ""
        info "Options:"
        echo "  [Enter] - Reject pushbacks, proceed with original task"
        echo "  [c]     - Accept Claude's pushback"
        echo "  [x]     - Accept Codex's pushback"
        echo ""
        read -r -p "Your choice: " pushback_choice

        case "$pushback_choice" in
            c|C)
                # Accept Claude's: copy Claude's task file to Codex's worktree
                info "Accepting Claude's pushback..."
                if [ -f "$worktree_claude/$task_basename" ]; then
                    cp "$worktree_claude/$task_basename" "$worktree_codex/$task_basename"
                    success "Copied Claude's task file to Codex worktree"
                fi
                echo "claude" > "$peer_sync/pushback-accepted"
                ;;
            x|X)
                # Accept Codex's: copy Codex's task file to Claude's worktree
                info "Accepting Codex's pushback..."
                if [ -f "$worktree_codex/$task_basename" ]; then
                    cp "$worktree_codex/$task_basename" "$worktree_claude/$task_basename"
                    success "Copied Codex's task file to Claude worktree"
                fi
                echo "codex" > "$peer_sync/pushback-accepted"
                ;;
            *)
                # Reject: restore original task file from project root to both worktrees
                info "Rejecting pushbacks, restoring original task..."
                if [ -f "$root/$task_basename" ]; then
                    cp "$root/$task_basename" "$worktree_claude/$task_basename"
                    cp "$root/$task_basename" "$worktree_codex/$task_basename"
                    success "Restored original task file to both worktrees"
                else
                    warn "Original task file not found in project root"
                fi
                echo "rejected" > "$peer_sync/pushback-accepted"
                ;;
        esac

        # Mark pushback as confirmed
        echo "confirmed" > "$peer_sync/pushback-confirmed"
        echo "work" > "$peer_sync/phase"

        success "Pushback stage complete!"
        echo ""
    fi

    # Check if plan mode is enabled (command line overrides session setting)
    local plan_mode
    if [ -n "$enable_plan" ]; then
        plan_mode="$enable_plan"
        echo "$enable_plan" > "$peer_sync/plan-mode"
    else
        plan_mode="$(cat "$peer_sync/plan-mode" 2>/dev/null)" || plan_mode="false"
    fi

    # Handle plan phase if enabled and not already confirmed
    if [ "$plan_mode" = "true" ] && [ ! -f "$peer_sync/plan-confirmed" ]; then
        info "=== Plan Phase ==="
        echo "plan" > "$peer_sync/phase"

        check_tui_health "claude" "$claude_session" "$peer_sync" "$tui_exit_behavior"
        atomic_write "$peer_sync/claude.status" "planning|$(date +%s)|plan phase"
        info "Triggering duo-plan for claude..."
        send_to_agent "claude" "$claude_session" "$peer_sync" skill "duo-plan"

        check_tui_health "codex" "$codex_session" "$peer_sync" "$tui_exit_behavior"
        atomic_write "$peer_sync/codex.status" "planning|$(date +%s)|plan phase"
        info "Triggering duo-plan for codex..."
        send_to_agent "codex" "$codex_session" "$peer_sync" skill "duo-plan"

        # Wait for both agents to complete plan phase
        local plan_start=$SECONDS
        local claude_plan_done=false
        local codex_plan_done=false
        local claude_needs_notice=false
        local codex_needs_notice=false

        while ! ($claude_plan_done && $codex_plan_done); do
            local elapsed=$((SECONDS - plan_start))

            local claude_status
            claude_status="$(get_agent_status "claude" "$peer_sync")"
            local codex_status
            codex_status="$(get_agent_status "codex" "$peer_sync")"

            [ "$claude_status" = "plan-done" ] && claude_plan_done=true
            [ "$codex_status" = "plan-done" ] && codex_plan_done=true

            if [ "$claude_status" = "needs-clarify" ] && [ "$claude_needs_notice" = "false" ]; then
                claude_needs_notice=true
                echo ""
                warn "Claude needs clarification during planning"
                echo "Respond in Claude's terminal, then they will signal plan-done."
                echo ""
            fi
            if [ "$codex_status" = "needs-clarify" ] && [ "$codex_needs_notice" = "false" ]; then
                codex_needs_notice=true
                echo ""
                warn "Codex needs clarification during planning"
                echo "Respond in Codex's terminal, then they will signal plan-done."
                echo ""
            fi

            if $claude_plan_done && $codex_plan_done; then
                break
            fi

            if ! $claude_plan_done; then
                check_tui_health "claude" "$claude_session" "$peer_sync" "$tui_exit_behavior"
                check_and_retry_on_error "claude" "$claude_session" "$peer_sync"
            fi
            if ! $codex_plan_done; then
                check_tui_health "codex" "$codex_session" "$peer_sync" "$tui_exit_behavior"
                check_and_retry_on_error "codex" "$codex_session" "$peer_sync"
            fi

            if [ "$elapsed" -ge "$plan_timeout" ]; then
                warn "Plan phase timeout (${plan_timeout}s)"
                break
            fi

            printf "\r  Waiting... claude=%s codex=%s (%ds/%ds)  " "$claude_status" "$codex_status" "$elapsed" "$plan_timeout"
            sleep "$poll_interval"
        done
        echo ""

        # Display plan results
        echo ""
        info "=== Plan Phase Results ==="
        echo ""

        if [ -f "$peer_sync/plan-claude.md" ]; then
            echo "--- Claude's Plan ---"
            cat "$peer_sync/plan-claude.md"
            echo ""
        else
            warn "Claude did not submit a plan"
        fi

        if [ -f "$peer_sync/plan-codex.md" ]; then
            echo "--- Codex's Plan ---"
            cat "$peer_sync/plan-codex.md"
            echo ""
        else
            warn "Codex did not submit a plan"
        fi

        # Plan-review phase
        info "=== Plan-Review Phase ==="
        echo "plan-review" > "$peer_sync/phase"

        check_tui_health "claude" "$claude_session" "$peer_sync" "$tui_exit_behavior"
        atomic_write "$peer_sync/claude.status" "plan-reviewing|$(date +%s)|plan-review phase"
        info "Triggering duo-plan-review for claude..."
        send_to_agent "claude" "$claude_session" "$peer_sync" skill "duo-plan-review"

        check_tui_health "codex" "$codex_session" "$peer_sync" "$tui_exit_behavior"
        atomic_write "$peer_sync/codex.status" "plan-reviewing|$(date +%s)|plan-review phase"
        info "Triggering duo-plan-review for codex..."
        send_to_agent "codex" "$codex_session" "$peer_sync" skill "duo-plan-review"

        local review_start=$SECONDS
        local claude_review_done=false
        local codex_review_done=false
        local claude_review_notice=false
        local codex_review_notice=false

        while ! ($claude_review_done && $codex_review_done); do
            local elapsed=$((SECONDS - review_start))

            local claude_status
            claude_status="$(get_agent_status "claude" "$peer_sync")"
            local codex_status
            codex_status="$(get_agent_status "codex" "$peer_sync")"

            [ "$claude_status" = "plan-review-done" ] && claude_review_done=true
            [ "$codex_status" = "plan-review-done" ] && codex_review_done=true

            if [ "$claude_status" = "needs-clarify" ] && [ "$claude_review_notice" = "false" ]; then
                claude_review_notice=true
                echo ""
                warn "Claude needs clarification during plan review"
                echo "Respond in Claude's terminal, then they will signal plan-review-done."
                echo ""
            fi
            if [ "$codex_status" = "needs-clarify" ] && [ "$codex_review_notice" = "false" ]; then
                codex_review_notice=true
                echo ""
                warn "Codex needs clarification during plan review"
                echo "Respond in Codex's terminal, then they will signal plan-review-done."
                echo ""
            fi

            if $claude_review_done && $codex_review_done; then
                break
            fi

            if ! $claude_review_done; then
                check_tui_health "claude" "$claude_session" "$peer_sync" "$tui_exit_behavior"
                check_and_retry_on_error "claude" "$claude_session" "$peer_sync"
            fi
            if ! $codex_review_done; then
                check_tui_health "codex" "$codex_session" "$peer_sync" "$tui_exit_behavior"
                check_and_retry_on_error "codex" "$codex_session" "$peer_sync"
            fi

            if [ "$elapsed" -ge "$plan_timeout" ]; then
                warn "Plan-review phase timeout (${plan_timeout}s)"
                break
            fi

            printf "\r  Waiting... claude=%s codex=%s (%ds/%ds)  " "$claude_status" "$codex_status" "$elapsed" "$plan_timeout"
            sleep "$poll_interval"
        done
        echo ""

        echo ""
        info "=== Plan-Review Results ==="
        echo ""

        if [ -f "$peer_sync/plan-review-claude.md" ]; then
            echo "--- Claude's Review of Codex's Plan ---"
            cat "$peer_sync/plan-review-claude.md"
            echo ""
        fi

        if [ -f "$peer_sync/plan-review-codex.md" ]; then
            echo "--- Codex's Review of Claude's Plan ---"
            cat "$peer_sync/plan-review-codex.md"
            echo ""
        fi

        echo "confirmed" > "$peer_sync/plan-confirmed"
        echo "work" > "$peer_sync/phase"

        success "Plan phase complete! Proceeding to work phase..."
        echo ""
    fi

    # Check if both PRs already exist - skip directly to PR comment watch phase
    if has_pr "claude" "$peer_sync" && has_pr "codex" "$peer_sync"; then
        success "Both PRs already created - skipping to PR comment watch phase"
        echo ""
        echo "Claude PR: $(cat "$peer_sync/claude.pr")"
        echo "Codex PR:  $(cat "$peer_sync/codex.pr")"
        # Jump directly to PR comment watch phase (after the main loop)
    else
        # Set phase to work if not already set
        if [ "$(cat "$peer_sync/phase" 2>/dev/null)" != "work" ]; then
            echo "work" > "$peer_sync/phase"
        fi

        # Resume from saved round or start at 1
        local round
        round="$(cat "$peer_sync/round" 2>/dev/null)" || round=1

        while [ "$round" -le "$max_rounds" ]; do
            # Check if session is complete
            if [ "$(cat "$peer_sync/session" 2>/dev/null)" = "complete" ]; then
                success "Session complete!"
                break
            fi

            # Check if both have PRs AND at least one review cycle completed (round >= 2)
            # This ensures both agents see at least one review before session ends
            if has_pr "claude" "$peer_sync" && has_pr "codex" "$peer_sync" && [ "$round" -ge 2 ]; then
                echo "complete" > "$peer_sync/session"
                success "Both PRs created - session complete!"
                echo ""
                echo "Claude PR: $(cat "$peer_sync/claude.pr")"
                echo "Codex PR:  $(cat "$peer_sync/codex.pr")"
                break
            fi

            echo ""
            info "=== Round $round: Work Phase ==="
            echo "$round" > "$peer_sync/round"
            echo "work" > "$peer_sync/phase"

            # Trigger work phase for agents that don't have PRs
            # Round 1: Send augmented message with full context (avoids skill race condition)
            # Round 2+: Trigger duo-work skill (agent already has context)
            if [ "$round" -eq 1 ]; then
                # Round 1: Send augmented task with full context
                local task_file
                local task_content=""
                if task_file="$(find_task_file "$root" "$feature")"; then
                    task_content="$(cat "$task_file" | head -c 4000)"
                fi

                if ! has_pr "claude" "$peer_sync"; then
                    atomic_write "$peer_sync/claude.status" "working|$(date +%s)|round $round work phase"
                    info "Sending augmented task to claude..."
                    local claude_msg
                    claude_msg="$(generate_round1_message "claude" "codex" "$feature" "$task_content" "$worktree_codex" "$peer_sync")"
                    send_to_agent "claude" "$claude_session" "$peer_sync" message "$claude_msg" "round1-work"
                fi
                if ! has_pr "codex" "$peer_sync"; then
                    atomic_write "$peer_sync/codex.status" "working|$(date +%s)|round $round work phase"
                    info "Sending augmented task to codex..."
                    local codex_msg
                    codex_msg="$(generate_round1_message "codex" "claude" "$feature" "$task_content" "$worktree_claude" "$peer_sync")"
                    send_to_agent "codex" "$codex_session" "$peer_sync" message "$codex_msg" "round1-work"
                fi
            else
                # Round 2+: Trigger skill (agent already knows the context)
                # Reset status to working before triggering (in case agent doesn't signal)
                # Check TUI health before triggering to avoid sending to dead session
                # Agents with PRs get duo-amend; others get duo-work
                check_tui_health "claude" "$claude_session" "$peer_sync" "$tui_exit_behavior"
                atomic_write "$peer_sync/claude.status" "working|$(date +%s)|round $round work phase"
                if has_pr "claude" "$peer_sync"; then
                    info "Triggering duo-amend for claude (has PR)..."
                    send_to_agent "claude" "$claude_session" "$peer_sync" skill "duo-amend"
                else
                    info "Triggering duo-work for claude..."
                    send_to_agent "claude" "$claude_session" "$peer_sync" skill "duo-work"
                fi

                check_tui_health "codex" "$codex_session" "$peer_sync" "$tui_exit_behavior"
                atomic_write "$peer_sync/codex.status" "working|$(date +%s)|round $round work phase"
                if has_pr "codex" "$peer_sync"; then
                    info "Triggering duo-amend for codex (has PR)..."
                    send_to_agent "codex" "$codex_session" "$peer_sync" skill "duo-amend"
                else
                    info "Triggering duo-work for codex..."
                    send_to_agent "codex" "$codex_session" "$peer_sync" skill "duo-work"
                fi
            fi

            # Wait for work phase completion with timeout
            # Note: Agents with PRs still participate to respond to peer reviews
            local work_start=$SECONDS
            local claude_done=false
            local codex_done=false

            while ! ($claude_done && $codex_done); do
                local elapsed=$((SECONDS - work_start))

                # Check for completion
                local claude_status
                claude_status="$(get_agent_status "claude" "$peer_sync")"
                local codex_status
                codex_status="$(get_agent_status "codex" "$peer_sync")"

                # Accept done, review-done (agent jumped ahead), or pr-created
                [[ "$claude_status" =~ ^(done|review-done|updating-docs|docs-update-done|pr-created)$ ]] && claude_done=true
                [[ "$codex_status" =~ ^(done|review-done|updating-docs|docs-update-done|pr-created)$ ]] && codex_done=true

                # Check for PRs created mid-phase
                has_pr "claude" "$peer_sync" && claude_done=true
                has_pr "codex" "$peer_sync" && codex_done=true

                if $claude_done && $codex_done; then
                    break
                fi

                # Check if agent TUIs have exited unexpectedly
                if ! $claude_done; then
                    check_tui_health "claude" "$claude_session" "$peer_sync" "$tui_exit_behavior"
                fi
                if ! $codex_done; then
                    check_tui_health "codex" "$codex_session" "$peer_sync" "$tui_exit_behavior"
                fi

                # Check for API errors and retry if needed
                if ! $claude_done; then
                    check_and_retry_on_error "claude" "$claude_session" "$peer_sync"
                fi
                if ! $codex_done; then
                    check_and_retry_on_error "codex" "$codex_session" "$peer_sync"
                fi

                # Check timeout
                if [ "$elapsed" -ge "$work_timeout" ]; then
                    warn "Work phase timeout (${work_timeout}s)"

                    # Interrupt agents that aren't done
                    if ! $claude_done; then
                        interrupt_agent "claude" "$claude_session" "$peer_sync"
                        claude_done=true
                    fi
                    if ! $codex_done; then
                        interrupt_agent "codex" "$codex_session" "$peer_sync"
                        codex_done=true
                    fi
                    break
                fi

                printf "\r  Waiting... claude=%s codex=%s (%ds/%ds)  " "$claude_status" "$codex_status" "$elapsed" "$work_timeout"
                sleep "$poll_interval"
            done
            echo ""

            # Check again if both have PRs (might have been created during work)
            # Require round >= 2 to ensure at least one review cycle
            if has_pr "claude" "$peer_sync" && has_pr "codex" "$peer_sync" && [ "$round" -ge 2 ]; then
                echo "complete" > "$peer_sync/session"
                success "Both PRs created - session complete!"
                break
            fi

            # Check for escalations before transitioning to review phase
            # If user chooses to defer, escalations remain but we continue to review phase
            # They'll be checked again at the next phase boundary
            if has_pending_escalations "$peer_sync" >/dev/null; then
                handle_escalation_block "$peer_sync" "$feature" "duo" || true
            fi

            # Review phase
            info "=== Round $round: Review Phase ==="
            echo "review" > "$peer_sync/phase"

            # Trigger review phase for all agents (including those with PRs)
            # Agents with PRs still review peer's work and can see peer's review of their PR
            # Reset status to reviewing before triggering (in case agent doesn't signal)
            # Check TUI health before triggering to avoid sending to dead session
            check_tui_health "claude" "$claude_session" "$peer_sync" "$tui_exit_behavior"
            atomic_write "$peer_sync/claude.status" "reviewing|$(date +%s)|round $round review phase"
            info "Triggering duo-review for claude..."
            send_to_agent "claude" "$claude_session" "$peer_sync" skill "duo-review"

            check_tui_health "codex" "$codex_session" "$peer_sync" "$tui_exit_behavior"
            atomic_write "$peer_sync/codex.status" "reviewing|$(date +%s)|round $round review phase"
            info "Triggering duo-review for codex..."
            send_to_agent "codex" "$codex_session" "$peer_sync" skill "duo-review"

            # Wait for review phase completion with timeout
            # Note: Agents with PRs still participate in reviews
            local review_start=$SECONDS
            claude_done=false
            codex_done=false

            while ! ($claude_done && $codex_done); do
                local elapsed=$((SECONDS - review_start))

                local claude_status
                claude_status="$(get_agent_status "claude" "$peer_sync")"
                local codex_status
                codex_status="$(get_agent_status "codex" "$peer_sync")"

                # Accept review-done, done (agent skipped review), or pr-created
                [[ "$claude_status" =~ ^(done|review-done|updating-docs|docs-update-done|pr-created)$ ]] && claude_done=true
                [[ "$codex_status" =~ ^(done|review-done|updating-docs|docs-update-done|pr-created)$ ]] && codex_done=true

                has_pr "claude" "$peer_sync" && claude_done=true
                has_pr "codex" "$peer_sync" && codex_done=true

                if $claude_done && $codex_done; then
                    break
                fi

                # Check if agent TUIs have exited unexpectedly
                if ! $claude_done; then
                    check_tui_health "claude" "$claude_session" "$peer_sync" "$tui_exit_behavior"
                    check_and_retry_on_error "claude" "$claude_session" "$peer_sync"
                fi
                if ! $codex_done; then
                    check_tui_health "codex" "$codex_session" "$peer_sync" "$tui_exit_behavior"
                    check_and_retry_on_error "codex" "$codex_session" "$peer_sync"
                fi

                # Check timeout
                if [ "$elapsed" -ge "$review_timeout" ]; then
                    warn "Review phase timeout (${review_timeout}s)"

                    if ! $claude_done; then
                        interrupt_agent "claude" "$claude_session" "$peer_sync"
                        claude_done=true
                    fi
                    if ! $codex_done; then
                        interrupt_agent "codex" "$codex_session" "$peer_sync"
                        codex_done=true
                    fi
                    break
                fi

                printf "\r  Waiting... claude=%s codex=%s (%ds/%ds)  " "$claude_status" "$codex_status" "$elapsed" "$review_timeout"
                sleep "$poll_interval"
            done
            echo ""

            # Check if both have PRs after review phase (before starting next round)
            # Require round >= 2 to ensure at least one review cycle
            if has_pr "claude" "$peer_sync" && has_pr "codex" "$peer_sync" && [ "$round" -ge 2 ]; then
                echo "complete" > "$peer_sync/session"
                success "Both PRs created - session complete!"
                break
            fi

            # Check for escalations before transitioning to next work round
            # If user chooses to defer, escalations remain but we continue to next round
            # They'll be checked again at the next phase boundary
            if has_pending_escalations "$peer_sync" >/dev/null; then
                handle_escalation_block "$peer_sync" "$feature" "duo" || true
            fi

            round=$((round + 1))
        done

        if [ "$round" -gt "$max_rounds" ]; then
            warn "Reached max rounds ($max_rounds)"
        fi
    fi  # end of else block (PRs not already created)

    # PR Comment Watch Phase
    # After both PRs are created, monitor for new comments/reviews
    # This also works for backward compatibility: running on old sessions with PRs
    if has_pr "claude" "$peer_sync" && has_pr "codex" "$peer_sync"; then
        persist_workflow_feedback "$peer_sync" "$feature" "duo"
        local claude_pr codex_pr
        claude_pr="$(cat "$peer_sync/claude.pr")"
        codex_pr="$(cat "$peer_sync/codex.pr")"

        # Check if both PRs are already closed/merged before entering watch phase
        local claude_open=false codex_open=false
        is_pr_open "$claude_pr" && claude_open=true
        is_pr_open "$codex_pr" && codex_open=true

        if ! $claude_open && ! $codex_open; then
            info "Both PRs are already closed/merged. Skipping PR watch phase."
        else
            echo ""
            info "=== PR Comment Watch Phase ==="
            echo "pr-comments" > "$peer_sync/phase"

            echo "Monitoring PRs for new comments..."
            echo "  Claude: $claude_pr"
            echo "  Codex:  $codex_pr"
            echo ""
            echo "Press Ctrl-C to stop watching."
            echo ""

            # Check if this is first entry to PR comment phase (no hash files yet)
            # If so, assume existing comments/reviews need to be processed
            local claude_first_entry=false
            local codex_first_entry=false
            if [ ! -f "$peer_sync/claude.pr-hash" ]; then
                claude_first_entry=true
                get_pr_comment_hash "$claude_pr" > "$peer_sync/claude.pr-hash" 2>/dev/null || true
            fi
            if [ ! -f "$peer_sync/codex.pr-hash" ]; then
                codex_first_entry=true
                get_pr_comment_hash "$codex_pr" > "$peer_sync/codex.pr-hash" 2>/dev/null || true
            fi

            # Auto-finish timeout tracking (resets on any activity)
            local auto_finish_last_activity=$SECONDS

            while true; do
                # Check if both PRs are closed/merged
                claude_open=false codex_open=false
                is_pr_open "$claude_pr" && claude_open=true
                is_pr_open "$codex_pr" && codex_open=true

                if ! $claude_open && ! $codex_open; then
                    # Distinguish between merged and closed-without-merge
                    if is_pr_merged "$claude_pr" || is_pr_merged "$codex_pr"; then
                        success "PR accepted and merged to main. Session complete!"
                        echo "accepted" > "$peer_sync/session"
                        run_suggest_refactor_duo "$peer_sync" "$claude_session" "$codex_session" "$feature"
                    else
                        info "PRs closed without merging. Session complete."
                        echo "closed" > "$peer_sync/session"
                    fi
                    break
                fi

                # Check if main has advanced (another feature was merged)
                # and our branches need rebasing
                if main_has_advanced "$peer_sync"; then
                    info "Main branch has advanced - checking if rebase needed..."

                    local claude_branch codex_branch
                    claude_branch="${feature}-claude"
                    codex_branch="${feature}-codex"

                    local needs_integrate=false
                    if $claude_open && branch_needs_rebase "$claude_branch" "$peer_sync"; then
                        needs_integrate=true
                    fi
                    if $codex_open && branch_needs_rebase "$codex_branch" "$peer_sync"; then
                        needs_integrate=true
                    fi

                    if $needs_integrate; then
                        info "Branches need rebasing onto updated main"
                        echo "integrate" > "$peer_sync/phase"

                        # Trigger integrate skill for agents with open PRs
                        if $claude_open; then
                            check_tui_health "claude" "$claude_session" "$peer_sync" "$tui_exit_behavior"
                            atomic_write "$peer_sync/claude.status" "working|$(date +%s)|integrating (rebasing onto main)"
                            info "Triggering duo-integrate for claude..."
                            send_to_agent "claude" "$claude_session" "$peer_sync" skill "duo-integrate"
                        fi
                        if $codex_open; then
                            check_tui_health "codex" "$codex_session" "$peer_sync" "$tui_exit_behavior"
                            atomic_write "$peer_sync/codex.status" "working|$(date +%s)|integrating (rebasing onto main)"
                            info "Triggering duo-integrate for codex..."
                            send_to_agent "codex" "$codex_session" "$peer_sync" skill "duo-integrate"
                        fi

                        # Wait for integration to complete
                        local integrate_start=$SECONDS
                        local claude_integrated=$claude_open codex_integrated=$codex_open
                        $claude_open && claude_integrated=false
                        $codex_open && codex_integrated=false

                        while ! ($claude_integrated && $codex_integrated); do
                            local elapsed=$((SECONDS - integrate_start))

                            local claude_status codex_status
                            claude_status="$(get_agent_status "claude" "$peer_sync")"
                            codex_status="$(get_agent_status "codex" "$peer_sync")"

                            # Check for completion
                            if ! $claude_integrated && [[ "$claude_status" =~ ^(integrate-done|done)$ ]]; then
                                claude_integrated=true
                                info "Claude completed integration"
                            fi
                            if ! $codex_integrated && [[ "$codex_status" =~ ^(integrate-done|done)$ ]]; then
                                codex_integrated=true
                                info "Codex completed integration"
                            fi

                            if $claude_integrated && $codex_integrated; then
                                break
                            fi

                            # Check for API errors and retry if needed
                            if ! $claude_integrated && $claude_open; then
                                check_and_retry_on_error "claude" "$claude_session" "$peer_sync"
                            fi
                            if ! $codex_integrated && $codex_open; then
                                check_and_retry_on_error "codex" "$codex_session" "$peer_sync"
                            fi

                            # Check timeout
                            if [ "$elapsed" -ge "$DEFAULT_INTEGRATE_TIMEOUT" ]; then
                                warn "Integration timeout (${DEFAULT_INTEGRATE_TIMEOUT}s)"
                                break
                            fi

                            printf "\r  Integrating... claude=%s codex=%s (%ds)  " "$claude_status" "$codex_status" "$elapsed"
                            sleep "$poll_interval"
                        done
                        echo ""

                        # Resume pr-comments phase
                        echo "pr-comments" > "$peer_sync/phase"
                        info "Integration complete, resuming PR comment watch"
                        # Reset auto-finish timeout after integration activity
                        auto_finish_last_activity=$SECONDS
                    fi
                fi

                # Check for "Proceed to merge" trigger in either PR
                local merge_triggered=false
                if pr_has_merge_trigger "$claude_pr" || pr_has_merge_trigger "$codex_pr"; then
                    merge_triggered=true
                fi

                if $merge_triggered; then
                    echo ""
                    success "Merge trigger detected ('Proceed to merge' comment found)!"
                    echo ""
                    info "Transitioning to merge phase..."
                    cmd_run_merge
                    # After merge phase, continue watching for the winning PR
                    # (The losing PR is closed, so only the winning PR remains)
                    # Update open status - losing PR should now be closed
                    claude_open=false codex_open=false
                    is_pr_open "$claude_pr" && claude_open=true
                    is_pr_open "$codex_pr" && codex_open=true
                    if ! $claude_open && ! $codex_open; then
                        # Both closed means winning PR was merged by user during merge phase
                        success "All PRs closed. Session complete!"
                        echo "complete" > "$peer_sync/session"
                        break
                    fi
                    info "Continuing to monitor remaining open PR(s)..."
                    # Reset auto-finish timeout after merge phase activity
                    auto_finish_last_activity=$SECONDS
                    continue
                fi

                # Check for new comments on each open PR
                # On first entry, trigger if PR has any reviews (comment_count|review_count|...)
                local claude_needs_attention=false
                local codex_needs_attention=false

                if $claude_open; then
                    if $claude_first_entry; then
                        # First entry: check if PR has any reviews to process
                        local claude_hash
                        claude_hash="$(cat "$peer_sync/claude.pr-hash" 2>/dev/null)" || claude_hash=""
                        local claude_reviews="${claude_hash#*|}"  # remove comment count
                        claude_reviews="${claude_reviews%%|*}"    # extract review count
                        if [ -n "$claude_reviews" ] && [ "$claude_reviews" != "0" ]; then
                            claude_needs_attention=true
                            info "Claude's PR has $claude_reviews review(s) to process"
                        fi
                        claude_first_entry=false
                    elif pr_has_new_comments "claude" "$peer_sync"; then
                        claude_needs_attention=true
                        info "New comments on Claude's PR!"
                        send_pr_comment_notification "claude" "$feature" "$claude_pr" "duo"
                    fi
                fi

                if $codex_open; then
                    if $codex_first_entry; then
                        # First entry: check if PR has any reviews to process
                        local codex_hash
                        codex_hash="$(cat "$peer_sync/codex.pr-hash" 2>/dev/null)" || codex_hash=""
                        local codex_reviews="${codex_hash#*|}"  # remove comment count
                        codex_reviews="${codex_reviews%%|*}"    # extract review count
                        if [ -n "$codex_reviews" ] && [ "$codex_reviews" != "0" ]; then
                            codex_needs_attention=true
                            info "Codex's PR has $codex_reviews review(s) to process"
                        fi
                        codex_first_entry=false
                    elif pr_has_new_comments "codex" "$peer_sync"; then
                        codex_needs_attention=true
                        info "New comments on Codex's PR!"
                        send_pr_comment_notification "codex" "$feature" "$codex_pr" "duo"
                    fi
                fi

                # Trigger pr-comment skill for agents with new comments
                if $claude_needs_attention; then
                    check_tui_health "claude" "$claude_session" "$peer_sync" "$tui_exit_behavior"
                    atomic_write "$peer_sync/claude.status" "working|$(date +%s)|addressing PR comments"
                    info "Triggering duo-pr-comment for claude..."
                    send_to_agent "claude" "$claude_session" "$peer_sync" skill "duo-pr-comment"
                fi

                if $codex_needs_attention; then
                    check_tui_health "codex" "$codex_session" "$peer_sync" "$tui_exit_behavior"
                    atomic_write "$peer_sync/codex.status" "working|$(date +%s)|addressing PR comments"
                    info "Triggering duo-pr-comment for codex..."
                    send_to_agent "codex" "$codex_session" "$peer_sync" skill "duo-pr-comment"
                fi

                # Wait for agents to finish if they were triggered
                if $claude_needs_attention || $codex_needs_attention; then
                    local pr_watch_start=$SECONDS
                    local claude_done=true codex_done=true
                    $claude_needs_attention && claude_done=false
                    $codex_needs_attention && codex_done=false

                    while ! ($claude_done && $codex_done); do
                        local elapsed=$((SECONDS - pr_watch_start))

                        local claude_status codex_status
                        claude_status="$(get_agent_status "claude" "$peer_sync")"
                        codex_status="$(get_agent_status "codex" "$peer_sync")"

                        # Check for completion
                        if ! $claude_done && [[ "$claude_status" =~ ^(done|pr-created)$ ]]; then
                            claude_done=true
                        fi
                        if ! $codex_done && [[ "$codex_status" =~ ^(done|pr-created)$ ]]; then
                            codex_done=true
                        fi

                        if $claude_done && $codex_done; then
                            break
                        fi

                        # Check for API errors and retry if needed
                        if ! $claude_done; then
                            check_and_retry_on_error "claude" "$claude_session" "$peer_sync"
                        fi
                        if ! $codex_done; then
                            check_and_retry_on_error "codex" "$codex_session" "$peer_sync"
                        fi

                        # Check timeout
                        if [ "$elapsed" -ge "$DEFAULT_PR_WATCH_TIMEOUT" ]; then
                            warn "PR comment response timeout (${DEFAULT_PR_WATCH_TIMEOUT}s)"
                            break
                        fi

                        printf "\r  Waiting... claude=%s codex=%s (%ds)  " "$claude_status" "$codex_status" "$elapsed"
                        sleep "$poll_interval"
                    done
                    echo ""
                    # Reset auto-finish timeout after agent activity
                    auto_finish_last_activity=$SECONDS
                fi

                # Auto-finish timeout check
                if [ "$auto_finish" = "true" ]; then
                    local inactivity_elapsed=$((SECONDS - auto_finish_last_activity))
                    if [ "$inactivity_elapsed" -ge "$auto_finish_timeout" ]; then
                        info "Auto-finish timeout reached (${auto_finish_timeout}s inactivity)"

                        # Count open PRs
                        local open_pr_count=0
                        local remaining_agent=""
                        local remaining_session=""
                        if $claude_open; then
                            open_pr_count=$((open_pr_count + 1))
                            remaining_agent="claude"
                            remaining_session="$claude_session"
                        fi
                        if $codex_open; then
                            open_pr_count=$((open_pr_count + 1))
                            remaining_agent="codex"
                            remaining_session="$codex_session"
                        fi

                        if [ "$open_pr_count" -eq 2 ]; then
                            # Two PRs open: trigger merge phase
                            info "Both PRs still open - triggering merge phase..."
                            cmd_run_merge
                            # Reset activity timer after merge phase
                            auto_finish_last_activity=$SECONDS
                            # Update open status after merge
                            claude_open=false codex_open=false
                            is_pr_open "$claude_pr" && claude_open=true
                            is_pr_open "$codex_pr" && codex_open=true
                            if ! $claude_open && ! $codex_open; then
                                success "All PRs closed after merge. Session complete!"
                                echo "complete" > "$peer_sync/session"
                                break
                            fi
                        elif [ "$open_pr_count" -eq 1 ]; then
                            # One PR open: trigger final merge
                            info "Single PR remaining ($remaining_agent) - triggering final merge..."
                            trigger_final_merge "$remaining_agent" "$remaining_session" "$peer_sync" "$tui_exit_behavior"
                            # Check if merge succeeded
                            local remaining_pr
                            remaining_pr="$(cat "$peer_sync/${remaining_agent}.pr")"
                            if is_pr_merged "$remaining_pr"; then
                                success "PR merged successfully!"
                                echo "accepted" > "$peer_sync/session"
                                run_suggest_refactor_duo "$peer_sync" "$claude_session" "$codex_session" "$feature"
                            fi
                            break
                        fi
                    fi
                fi

                # Poll interval before next check
                if [ "$auto_finish" = "true" ]; then
                    local inactivity_elapsed=$((SECONDS - auto_finish_last_activity))
                    local remaining=$((auto_finish_timeout - inactivity_elapsed))
                    printf "\r  Watching for PR comments... (auto-finish in %ds)  " "$remaining"
                else
                    printf "\r  Watching for PR comments... (Ctrl-C to stop)  "
                fi
                sleep "$poll_interval"
            done
        fi
    fi

    echo ""
    info "=== Final Status ==="
    cmd_status
}

#------------------------------------------------------------------------------
# Command: nudge
#------------------------------------------------------------------------------

cmd_nudge() {
    local agent="$1"
    local message="${2:-Continue.}"

    [ -z "$agent" ] && die "Usage: agent-duo nudge <agent> [message]"

    local root
    root="$(get_project_root)"
    local feature
    feature="$(get_feature)"
    local session_name="duo-${feature}"

    # Determine session target
    local session
    if tmux has-session -t "$session_name" 2>/dev/null; then
        session="${session_name}:${agent}"
    elif tmux has-session -t "${session_name}-${agent}" 2>/dev/null; then
        session="${session_name}-${agent}"
    else
        die "No tmux session found for $agent"
    fi

    nudge_agent "$agent" "$session" "$message"
    success "Nudged $agent"
}

#------------------------------------------------------------------------------
# Command: interrupt
#------------------------------------------------------------------------------

cmd_interrupt() {
    local agent="$1"

    [ -z "$agent" ] && die "Usage: agent-duo interrupt <agent>"

    local root
    root="$(get_project_root)"
    local peer_sync="$root/.peer-sync"
    local feature
    feature="$(get_feature)"
    local session_name="duo-${feature}"

    # Determine session target
    local session
    if tmux has-session -t "$session_name" 2>/dev/null; then
        session="${session_name}:${agent}"
    elif tmux has-session -t "${session_name}-${agent}" 2>/dev/null; then
        session="${session_name}-${agent}"
    else
        die "No tmux session found for $agent"
    fi

    interrupt_agent "$agent" "$session" "$peer_sync"
    success "Interrupted $agent"
}

#------------------------------------------------------------------------------
# Command: help
#------------------------------------------------------------------------------

cmd_help() {
    cat << 'EOF'
Agent Duo - Coordinate two AI coding agents

USAGE
    agent-duo <command> [options]

SESSION COMMANDS
    start <feature> [<feature2> ...] [options]
        Start a new session for the given feature(s).
        Creates worktrees, tmux sessions, and ttyd web terminals.
        Looks for task description in: <feature>.md, doc/<feature>.md,
        docs/<feature>.md, or **/<feature>.md (anywhere in project).

        Options:
          --auto-run               Start orchestrator immediately in its own terminal
          --no-ttyd                Use single tmux session instead of web terminals
          --clarify                Enable clarify stage before work starts
          --pushback               Enable pushback stage (after clarify if both enabled)
          --plan                   Enable plan stage (after pushback if both enabled)
          --skip-docs-update       Skip update-docs phase before PR creation
          --work-timeout <secs>    Work phase timeout (default: 1200, with --auto-run)
          --review-timeout <secs>  Review phase timeout (default: 600, with --auto-run)
          --clarify-timeout <secs> Clarify stage timeout (default: 600, with --clarify)
          --pushback-timeout <secs> Pushback stage timeout (default: 600, with --pushback)
          --plan-timeout <secs>    Plan phase timeout (default: 600, with --plan)
          --max-rounds <n>         Maximum rounds (default: 10, with --auto-run)
          --codex-thinking <level> Codex reasoning effort: low, medium, high (default: high)
          --codex-model <model>    GPT model for Codex (e.g., o3, gpt-4.1)
          --claude-model <model>   Claude model (e.g., opus, sonnet)
          --port <port>            Base port for web terminals (uses 3 consecutive ports)
                                   If not specified, finds first available consecutive ports.
                                   Fails if any of the 3 ports are occupied.

        With ttyd (default): Creates 3 web terminals on consecutive ports
          - Orchestrator: port (or first available)
          - Claude: port+1
          - Codex: port+2
          Port assignments are stored in .peer-sync/ports for the session.

        With --no-ttyd: Creates single tmux session with 3 windows

        With --clarify: Agents first propose approaches and questions.
          User receives email and can respond before work begins.

        With --pushback: Agents propose improvements to the task file.
          User can accept, reject, or modify the proposed changes.

    run [options]
        Run the orchestrator loop (work -> review -> work... -> pr-comments).
        Automatically manages phase transitions and timeouts.
        After both PRs are created, monitors for new GitHub comments/reviews.
        Not needed if using 'start --auto-run'.

        Options:
          --clarify                Enable clarify stage before work starts
          --pushback               Enable pushback stage (after clarify if both enabled)
          --plan                   Enable plan stage (after pushback if both enabled)
          --work-timeout <secs>    Work phase timeout (default: 1200)
          --review-timeout <secs>  Review phase timeout (default: 600)
          --clarify-timeout <secs> Clarify stage timeout (default: 600)
          --pushback-timeout <secs> Pushback stage timeout (default: 600)
          --plan-timeout <secs>    Plan phase timeout (default: 600)
          --poll <secs>            Status poll interval (default: 10)
          --max-rounds <n>         Maximum rounds (default: 10)
          --auto-start             Auto-launch agent CLIs and send task

    stop
        Stop ttyd servers and tmux sessions, keep worktrees.

    restart [options]
        Restart a session after system restart or crash (DWIM behavior).
        - If healthy: no-op
        - If tmux sessions missing: recreates them
        - If ttyd down: restarts it (skipped for --no-ttyd sessions)
        - If agent TUIs not running: restarts them
        - If orchestration incomplete: optionally restarts orchestrator

        Options:
          --auto-run               Also restart the orchestrator loop
          --no-ttyd                Force tmux-only mode (override recorded setting)
          --work-timeout <secs>    Work phase timeout (default: 1200)
          --review-timeout <secs>  Review phase timeout (default: 600)
          --max-rounds <n>         Maximum rounds (default: 10)

    status
        Show current session state, agent statuses, and PRs.

    confirm
        Confirm the clarify phase is complete and proceed to work phase.
        Alternative to pressing Enter in the orchestrator terminal.

    escalate-resolve
        Review and resolve pending escalations from agents.
        Escalations block phase transitions until resolved.

    pr <agent>
        Create a PR for the specified agent (claude or codex).
        Auto-commits uncommitted changes and pushes.
        Runs update-docs phase before PR creation (unless skipped).

    feedback [list|view|delete|submit|digest]
        Manage accumulated workflow feedback from agent sessions.

        Subcommands:
          list               List accumulated feedback files (default)
          view <file>        View contents of a feedback file
          delete <file>      Delete a feedback file (or --all for all)
          submit             Interactively submit feedback as GitHub issue
                             (uses feedback_repo config, or prompts for repo)
          digest             Send feedback to ludics mag for LLM-powered
                             deduplication and structured GitHub issue filing

        Workflow feedback is automatically accumulated from .peer-sync/ to
        ~/.agent-duo/workflow-feedback/ when both PRs are created or during cleanup.

        Configure target repo: agent-duo config feedback_repo owner/repo

    merge [options]
        Start merge phase to consolidate both PRs into main.
        Sends the merge command to the orchestrator terminal, which then
        starts fresh agent sessions (unbiased by original implementation).
        Both agents vote on which PR to merge, debate if needed,
        then the losing agent merges and cherry-picks features.
        Requires both PRs to exist.

        Options:
          --auto-restart           Restart sessions first if not running

        The merge phase can also be triggered automatically during the
        PR comment watch phase by adding a comment containing "Proceed
        to merge" on either PR.

    run-merge
        Run merge orchestration directly (for use in orchestrator terminal).
        Starts fresh agent sessions on main branch for unbiased voting,
        then runs the vote → debate → execute → review flow.
        Requires both PRs to exist.

    cleanup [--full]
        Remove session state (.peer-sync). With --full, also removes
        worktrees and deletes the feature branches.

    setup
        Install agent-duo to ~/.local/bin and skills to agent dirs.

    doctor [--send-email] [--send-ntfy]
        Check system configuration and diagnose common issues.
        Verifies: required tools, AI CLIs, git config, email/ntfy setup,
        skills installation, hook configuration, and PATH.

        Options:
          --send-email    Send a test email to verify email delivery
          --send-ntfy     Send a test ntfy notification

    config [key] [value]
        Get or set configuration values.
        Without arguments, shows current configuration.

        Keys:
          ntfy_topic      ntfy.sh topic name for push notifications
          ntfy_token      ntfy.sh access token (for reserved/private topics)
          ntfy_server     ntfy server URL (default: https://ntfy.sh)

        Examples:
          agent-duo config                       # Show all config
          agent-duo config ntfy_topic            # Get ntfy topic
          agent-duo config ntfy_topic myapp123   # Set ntfy topic
          agent-duo config ntfy_token tk_abc123  # Set access token

CONTROL COMMANDS
    nudge <agent> [message]
        Send a message to an agent's terminal.
        Default message: "Continue."

    interrupt <agent>
        Send Escape to interrupt an agent and mark as interrupted.

AGENT COMMANDS (used by AI agents)
    signal <agent> <status> [message]
        Signal a status change. Status values:
        clarifying, clarify-done, pushing-back, pushback-done, planning,
        plan-done, plan-reviewing, plan-review-done, needs-clarify, working,
        done, reviewing, review-done, integrating, integrate-done, interrupted,
        clarifying, clarify-done, pushing-back, pushback-done, working, done,
        reviewing, review-done, updating-docs, docs-update-done, integrating, integrate-done, interrupted,
        error, pr-created, escalated, voting, vote-done, debating, debate-done,
        merging, merge-done, merge-reviewing, merge-review-done

    peer-status
        Read peer's current status (requires PEER_NAME env var).

    phase
        Read current phase (clarify, pushback, plan, plan-review, work, review, or merge).
        Read current phase (clarify, pushback, work, review, update-docs, or merge).

    escalate <reason> [message]
        Escalate an issue requiring user input. Does not interrupt the agent.
        The orchestrator will block phase transitions until user resolves.

        Reasons:
          ambiguity     - Requirements are unclear
          inconsistency - Conflicting requirements or code/docs mismatch
          misguided     - Evidence the task approach is wrong

    learn "<title>" [content]
        Record a project learning to AGENTS_STAGING.md.
        Append documentation about patterns, gotchas, or conventions discovered
        during development. Content can be piped from stdin.

        Example:
          agent-duo learn "Redis required for tests" "Integration tests need Redis on localhost:6379"
          echo "Use ApiError from src/errors.ts" | agent-duo learn "Error handling pattern"

    workflow-feedback <category> [content]
        Record feedback about the agent-duo workflow itself.
        Helps improve skills and coordination for future sessions.
        Content can be piped from stdin.

        Categories:
          skill-unclear  - Skill instructions were ambiguous or missing
          coordination   - Timing or signaling issues
          tooling        - Missing commands or features
          friction       - General workflow friction points
          other          - Other feedback

ENVIRONMENT VARIABLES (set in agent sessions)
    PEER_SYNC       Path to .peer-sync directory
    MY_NAME         This agent's name (claude or codex)
    PEER_NAME       Other agent's name
    MY_WORKTREE     Path to this agent's worktree
    PEER_WORKTREE   Path to peer's worktree
    FEATURE         Feature name

EXAMPLES
    # Recommended: start with auto-run (opens 3 web terminals, starts everything)
    agent-duo start auth --auto-run

    # With clarify stage: agents propose approaches before starting work
    agent-duo start auth --auto-run --clarify

    # With pushback stage: agents propose improvements to the task file
    agent-duo start auth --auto-run --pushback

    # With both stages: clarify -> pushback -> work
    agent-duo start auth --auto-run --clarify --pushback
    # Review approaches, respond to agents, then press Enter in orchestrator

    # Alternative: start manually then run orchestrator
    agent-duo start auth
    agent-duo run --auto-start

    # Use tmux instead of web terminals
    agent-duo start auth --no-ttyd
    tmux attach -t duo-auth
    # Then run: agent-duo run --auto-start

    # Recover after system restart
    agent-duo restart --auto-run

    # Nudge a stuck agent
    agent-duo nudge claude "Please continue with the implementation."

    # Check status
    agent-duo status

    # Create PR when done
    agent-duo pr claude

    # After both PRs created: merge phase
    agent-duo merge
    # Agents vote, debate if needed, then execute merge

    # Clean up
    agent-duo cleanup --full

    # View accumulated workflow feedback from past sessions
    agent-duo feedback list
    agent-duo feedback view 2026-02-03-auth-claude.md
EOF
}

#------------------------------------------------------------------------------
# Main
#------------------------------------------------------------------------------

main() {
    local cmd="${1:-help}"
    shift || true

    case "$cmd" in
        start)       cmd_start "$@" ;;
        run)         cmd_run "$@" ;;
        stop)        cmd_stop "$@" ;;
        restart)     cmd_restart "$@" ;;
        status)      cmd_status "$@" ;;
        confirm)     cmd_confirm "$@" ;;
        escalate)    cmd_escalate "$@" ;;
        escalate-resolve) cmd_escalate_resolve "$@" ;;
        pr)          cmd_pr "$@" ;;
        feedback)    cmd_feedback "$@" ;;
        merge)       cmd_merge "$@" ;;
        run-merge)   cmd_run_merge "$@" ;;
        cleanup)     cmd_cleanup "$@" ;;
        setup)       cmd_setup "$@" ;;
        doctor)      cmd_doctor "$@" ;;
        config)      cmd_config "$@" ;;
        nudge)       cmd_nudge "$@" ;;
        interrupt)   cmd_interrupt "$@" ;;
        signal)      cmd_signal "$@" ;;
        peer-status) cmd_peer_status "$@" ;;
        phase)       cmd_phase "$@" ;;
        learn)       cmd_learn "$@" ;;
        workflow-feedback) cmd_workflow_feedback "$@" ;;
        help|--help|-h) cmd_help ;;
        *)           die "Unknown command: $cmd (try 'agent-duo help')" ;;
    esac
}

main "$@"
