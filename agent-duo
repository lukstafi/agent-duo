#!/usr/bin/env bash
# agent-duo - Coordinate two AI coding agents working in parallel
#
# Requires Bash 4.0+ (for associative arrays, regex matching, etc.)
# macOS users: install modern bash via Homebrew: brew install bash
#
# Usage: agent-duo <command> [options]
#
# Session Commands:
#   start <feature> [--auto-run] [--no-ttyd] [--clarify]  Start session
#   run [options]        Run orchestrator loop with timeouts
#                        --on-tui-exit=pause|quit|ignore  TUI exit behavior
#   stop                 Stop ttyd servers, keep worktrees
#   restart [--auto-run] Restart session after system restart/crash
#   status               Show session state
#   confirm              Confirm clarify phase completion (proceed to work)
#   pr <agent>           Create PR for agent's solution
#   cleanup [--full]     Remove session state (--full: also worktrees/branches)
#   setup                Install agent-duo to PATH and skills
#   doctor [--send-email|--send-ntfy]  Check system health and configuration
#   config <key> [value] Get/set configuration (e.g., ntfy_topic)
#
# Control Commands:
#   nudge <agent> [msg]  Send message to agent terminal
#   interrupt <agent>    Interrupt agent (Esc)
#
# Agent Commands:
#   signal <agent> <status> [message]   Signal status change
#   peer-status                         Read peer's status
#   phase                               Read current phase

set -e

# Determine script location (resolves symlinks)
SCRIPT_PATH="${BASH_SOURCE[0]}"
while [ -L "$SCRIPT_PATH" ]; do
    SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
    SCRIPT_PATH="$(readlink "$SCRIPT_PATH")"
    [[ $SCRIPT_PATH != /* ]] && SCRIPT_PATH="$SCRIPT_DIR/$SCRIPT_PATH"
done
SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"

# Source shared library
if [ -f "$SCRIPT_DIR/agent-lib.sh" ]; then
    # shellcheck source=agent-lib.sh
    source "$SCRIPT_DIR/agent-lib.sh"
elif [ -f "$HOME/.local/bin/agent-lib.sh" ]; then
    # shellcheck source=agent-lib.sh
    source "$HOME/.local/bin/agent-lib.sh"
else
    echo "Error: agent-lib.sh not found" >&2
    exit 1
fi

# Default agents for duo mode
DEFAULT_AGENT_A="claude"
DEFAULT_AGENT_B="codex"

# Allocate ports for a session and store in .peer-sync/ports
# Args: peer_sync [base_port]
# If base_port is provided, uses consecutive ports starting from it (fails if any occupied)
# Otherwise, dynamically finds available ports starting from DEFAULT_BASE_PORT
allocate_ports() {
    local peer_sync="$1"
    local base_port="${2:-}"
    local ports_file="$peer_sync/ports"

    # If ports already allocated, return
    if [ -f "$ports_file" ]; then
        return 0
    fi

    local orchestrator_port claude_port codex_port

    if [ -n "$base_port" ]; then
        # User specified a port: use consecutive ports, fail if any occupied
        orchestrator_port="$base_port"
        claude_port=$((base_port + 1))
        codex_port=$((base_port + 2))

        if ! is_port_available "$orchestrator_port"; then
            die "Port $orchestrator_port (orchestrator) is already in use"
        fi
        if ! is_port_available "$claude_port"; then
            die "Port $claude_port (claude) is already in use"
        fi
        if ! is_port_available "$codex_port"; then
            die "Port $codex_port (codex) is already in use"
        fi
    else
        # Dynamic allocation: find 3 consecutive available ports
        orchestrator_port="$(find_consecutive_ports "$DEFAULT_BASE_PORT" 3)" || die "Could not find 3 consecutive available ports"
        claude_port=$((orchestrator_port + 1))
        codex_port=$((orchestrator_port + 2))
    fi

    cat > "$ports_file" << EOF
ORCHESTRATOR_PORT=$orchestrator_port
CLAUDE_PORT=$claude_port
CODEX_PORT=$codex_port
EOF
}

# Note: get_ports, tmux_session_exists, ttyd_is_running, is_port_in_use,
# agent_tui_is_running, restart_ttyd_for_session, restart_agent_tui, and
# find_task_file are all provided by agent-lib.sh

#------------------------------------------------------------------------------
# Command: setup
#------------------------------------------------------------------------------

# Install a skill from template with agent-specific replacements
install_skill() {
    local template="$1"
    local dest="$2"
    local skill_cmd="$3"  # e.g., "/duo-work" for Claude, "$duo-work" for Codex

    if [ -f "$template" ]; then
        # Replace {{SKILL_CMD}} placeholder with agent-specific command prefix
        sed "s|{{SKILL_CMD}}|${skill_cmd}|g" "$template" > "$dest"
    fi
}

cmd_setup() {
    # Detect if user meant to run ./agent-duo setup from a repo checkout
    local install_dir="$HOME/.local/bin"

    if [ "$SCRIPT_DIR" = "$install_dir" ] && [ -x "./agent-duo" ]; then
        die "Found ./agent-duo in current directory - did you mean to run:
  ./agent-duo setup"
    fi

    info "Installing agent-duo..."

    local templates_dir="$SCRIPT_DIR/skills/templates"

    if [ ! -d "$templates_dir" ]; then
        die "Skills templates not found at $templates_dir"
    fi

    # Install CLI to ~/.local/bin
    mkdir -p "$install_dir"

    local install_path="$install_dir/agent-duo"
    if [ "$SCRIPT_DIR/agent-duo" != "$install_path" ]; then
        cp "$SCRIPT_DIR/agent-duo" "$install_path"
        chmod +x "$install_path"
        success "Installed agent-duo to $install_path"
    else
        success "agent-duo already installed at $install_path"
    fi

    # Install shared library
    local lib_path="$install_dir/agent-lib.sh"
    if [ -f "$SCRIPT_DIR/agent-lib.sh" ]; then
        cp "$SCRIPT_DIR/agent-lib.sh" "$lib_path"
        success "Installed agent-lib.sh to $lib_path"
    fi

    # Copy skills/templates to install dir so setup works from installed location
    local installed_templates="$install_dir/skills/templates"
    if [ "$templates_dir" != "$installed_templates" ]; then
        mkdir -p "$installed_templates"
        cp -r "$templates_dir"/* "$installed_templates/"
        success "Installed skill templates to $installed_templates"
    fi

    # Install shared helper scripts
    local shared_dir="$HOME/.local/share/agent-duo"
    mkdir -p "$shared_dir"
    local shared_templates="$templates_dir/shared"
    if [ -d "$shared_templates" ]; then
        cp "$shared_templates"/*.sh "$shared_dir/" 2>/dev/null || true
        chmod +x "$shared_dir"/*.sh 2>/dev/null || true
        success "Installed shared scripts to $shared_dir"
    fi

    # Check if ~/.local/bin is in PATH
    if [[ ":$PATH:" != *":$install_dir:"* ]]; then
        warn "Add $install_dir to your PATH:"
        echo "  export PATH=\"\$HOME/.local/bin:\$PATH\""
    fi

    # Install Claude skills (uses /command syntax)
    local claude_skills="$HOME/.claude/commands"
    mkdir -p "$claude_skills"

    install_skill "$templates_dir/duo-work.md" "$claude_skills/duo-work.md" "/duo-work"
    install_skill "$templates_dir/duo-review.md" "$claude_skills/duo-review.md" "/duo-review"
    install_skill "$templates_dir/duo-clarify.md" "$claude_skills/duo-clarify.md" "/duo-clarify"
    install_skill "$templates_dir/duo-pushback.md" "$claude_skills/duo-pushback.md" "/duo-pushback"
    install_skill "$templates_dir/duo-amend.md" "$claude_skills/duo-amend.md" "/duo-amend"
    install_skill "$templates_dir/duo-pr-comment.md" "$claude_skills/duo-pr-comment.md" "/duo-pr-comment"
    install_skill "$templates_dir/duo-merge-vote.md" "$claude_skills/duo-merge-vote.md" "/duo-merge-vote"
    install_skill "$templates_dir/duo-merge-debate.md" "$claude_skills/duo-merge-debate.md" "/duo-merge-debate"
    install_skill "$templates_dir/duo-merge-execute.md" "$claude_skills/duo-merge-execute.md" "/duo-merge-execute"
    install_skill "$templates_dir/duo-merge-review.md" "$claude_skills/duo-merge-review.md" "/duo-merge-review"
    install_skill "$templates_dir/duo-merge-amend.md" "$claude_skills/duo-merge-amend.md" "/duo-merge-amend"
    success "Installed Claude skills to $claude_skills"

    # Install Codex skills (uses $command syntax)
    # Codex expects skills as directories with SKILL.md inside
    local codex_skills="$HOME/.codex/skills"
    mkdir -p "$codex_skills/duo-work" "$codex_skills/duo-review" "$codex_skills/duo-clarify" "$codex_skills/duo-pushback" "$codex_skills/duo-amend" "$codex_skills/duo-pr-comment"
    mkdir -p "$codex_skills/duo-merge-vote" "$codex_skills/duo-merge-debate" "$codex_skills/duo-merge-execute" "$codex_skills/duo-merge-review" "$codex_skills/duo-merge-amend"

    install_skill "$templates_dir/duo-work.md" "$codex_skills/duo-work/SKILL.md" "\$duo-work"
    install_skill "$templates_dir/duo-review.md" "$codex_skills/duo-review/SKILL.md" "\$duo-review"
    install_skill "$templates_dir/duo-clarify.md" "$codex_skills/duo-clarify/SKILL.md" "\$duo-clarify"
    install_skill "$templates_dir/duo-pushback.md" "$codex_skills/duo-pushback/SKILL.md" "\$duo-pushback"
    install_skill "$templates_dir/duo-amend.md" "$codex_skills/duo-amend/SKILL.md" "\$duo-amend"
    install_skill "$templates_dir/duo-pr-comment.md" "$codex_skills/duo-pr-comment/SKILL.md" "\$duo-pr-comment"
    install_skill "$templates_dir/duo-merge-vote.md" "$codex_skills/duo-merge-vote/SKILL.md" "\$duo-merge-vote"
    install_skill "$templates_dir/duo-merge-debate.md" "$codex_skills/duo-merge-debate/SKILL.md" "\$duo-merge-debate"
    install_skill "$templates_dir/duo-merge-execute.md" "$codex_skills/duo-merge-execute/SKILL.md" "\$duo-merge-execute"
    install_skill "$templates_dir/duo-merge-review.md" "$codex_skills/duo-merge-review/SKILL.md" "\$duo-merge-review"
    install_skill "$templates_dir/duo-merge-amend.md" "$codex_skills/duo-merge-amend/SKILL.md" "\$duo-merge-amend"
    success "Installed Codex skills to $codex_skills"

    # Install unified notify hook script and configure agent hooks
    local notify_script
    notify_script="$(install_notify_hook "$install_dir")"
    success "Installed unified notify hook script to $notify_script"

    configure_codex_notify "$notify_script"
    configure_claude_notify "$notify_script"

    success "Setup complete!"

    # Prominent message about agent-solo
    echo ""
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    info "To install agent-solo (single-agent mode), run: ./agent-solo setup"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
}

#------------------------------------------------------------------------------
# Command: doctor
#------------------------------------------------------------------------------

cmd_doctor() {
    local all_ok=true
    local send_test_email=false
    local send_test_ntfy=false

    # Parse arguments
    while [ $# -gt 0 ]; do
        case "$1" in
            --send-email) send_test_email=true ;;
            --send-ntfy) send_test_ntfy=true ;;
            *) die "Unknown option: $1" ;;
        esac
        shift
    done

    info "Running health checks..."
    echo ""

    # --- Required Tools ---
    echo "=== Required Tools ==="

    # git
    if command -v git >/dev/null 2>&1; then
        success "git: $(git --version | head -1)"
    else
        warn "git: NOT FOUND (required)"
        all_ok=false
    fi

    # tmux
    if command -v tmux >/dev/null 2>&1; then
        success "tmux: $(tmux -V)"
    else
        warn "tmux: NOT FOUND (required)"
        all_ok=false
    fi

    # ttyd (optional but recommended)
    if command -v ttyd >/dev/null 2>&1; then
        success "ttyd: $(ttyd --version 2>&1 | head -1)"
    else
        warn "ttyd: NOT FOUND (optional - use --no-ttyd flag without it)"
    fi

    # jq (optional but helpful)
    if command -v jq >/dev/null 2>&1; then
        success "jq: $(jq --version)"
    else
        warn "jq: NOT FOUND (optional - used for JSON config manipulation)"
    fi

    echo ""

    # --- AI Agent CLIs ---
    echo "=== AI Agent CLIs ==="

    # claude
    if command -v claude >/dev/null 2>&1; then
        success "claude: found at $(command -v claude)"
    else
        warn "claude: NOT FOUND"
        warn "  Install: npm install -g @anthropic-ai/claude-code"
        all_ok=false
    fi

    # codex
    if command -v codex >/dev/null 2>&1; then
        success "codex: found at $(command -v codex)"
    else
        warn "codex: NOT FOUND"
        warn "  Install: npm install -g @openai/codex"
        all_ok=false
    fi

    echo ""

    # --- Git Configuration ---
    echo "=== Git Configuration ==="

    local git_name git_email
    git_name="$(git config user.name 2>/dev/null || true)"
    git_email="$(git config user.email 2>/dev/null || true)"

    if [ -n "$git_name" ]; then
        success "git user.name: $git_name"
    else
        warn "git user.name: NOT SET"
        warn "  Run: git config --global user.name \"Your Name\""
        all_ok=false
    fi

    if [ -n "$git_email" ]; then
        success "git user.email: $git_email"
    else
        warn "git user.email: NOT SET (required for email notifications)"
        warn "  Run: git config --global user.email \"you@example.com\""
        all_ok=false
    fi

    echo ""

    # --- Email Setup ---
    echo "=== Email Notifications ==="

    local email_likely_works=false

    if command -v mail >/dev/null 2>&1; then
        success "mail command: found at $(command -v mail)"

        # Check if email delivery is likely to work
        local mail_warning=""

        # Check for running mail daemon (postfix, sendmail, etc.)
        if ! pgrep -x "master" >/dev/null 2>&1 && ! pgrep -x "sendmail" >/dev/null 2>&1; then
            # No mail daemon running - check if msmtp is configured as sendmail
            if command -v msmtp >/dev/null 2>&1; then
                # msmtp found - check if it's linked as sendmail
                local sendmail_path
                sendmail_path="$(command -v sendmail 2>/dev/null || true)"
                if [ -n "$sendmail_path" ] && readlink "$sendmail_path" 2>/dev/null | grep -q msmtp; then
                    success "msmtp: configured as sendmail relay"
                    email_likely_works=true
                elif [ -f "$HOME/.msmtprc" ]; then
                    success "msmtp: found with config"
                    info "  Tip: link msmtp as sendmail for mail command to use it"
                    email_likely_works=true
                else
                    warn "msmtp: found but not configured (~/.msmtprc missing)"
                fi
            else
                mail_warning="no mail daemon running"
            fi
        else
            success "Mail daemon: running"
            email_likely_works=true
        fi

        # On macOS, warn about common postfix issue
        if [ "$(uname)" = "Darwin" ] && [ "$email_likely_works" = false ]; then
            warn "macOS mail issue: $mail_warning"
            warn "  The 'mail' command will appear to succeed but emails won't deliver."
            warn "  Fix options:"
            warn "    1. Install msmtp: brew install msmtp"
            warn "       Configure ~/.msmtprc with SMTP relay (e.g., Gmail app password)"
            warn "    2. Start postfix: sudo postfix start (temporary)"
            warn "    3. Use a webhook notification service instead"
        elif [ "$email_likely_works" = false ]; then
            warn "Mail delivery issue: $mail_warning"
            warn "  Emails may not be delivered. Check your MTA configuration."
        fi

        if [ "$send_test_email" = true ]; then
            if [ -n "$git_email" ]; then
                info "Sending test email to $git_email..."
                local test_body="This is a test email from agent-duo doctor.

If you received this, your email configuration is working correctly.

Sent: $(date)"
                if echo "$test_body" | mail -s "[agent-duo] Test email from doctor" "$git_email" 2>/dev/null; then
                    if [ "$email_likely_works" = true ]; then
                        success "Test email sent to $git_email"
                        info "  Check your inbox (and spam folder)"
                    else
                        warn "Test email queued to $git_email (but delivery unlikely)"
                        warn "  The mail command succeeded, but without a working MTA,"
                        warn "  the email is probably sitting in a local queue."
                    fi
                else
                    warn "Failed to send test email"
                    warn "  Your mail system may not be configured correctly"
                fi
            else
                warn "Cannot send test email: git user.email not configured"
            fi
        else
            info "  Use --send-email to send a test email"
        fi
    else
        warn "mail command: NOT FOUND"
        warn "  Email notifications will not work"
        warn "  Install: mailutils (Linux) or configure msmtp (macOS)"
    fi

    echo ""

    # --- ntfy.sh Setup ---
    echo "=== ntfy.sh Notifications ==="

    local ntfy_topic
    ntfy_topic="$(get_ntfy_topic 2>/dev/null || true)"

    if [ -n "$ntfy_topic" ]; then
        success "ntfy topic: $ntfy_topic"
        local ntfy_server
        ntfy_server="$(get_ntfy_server)"
        info "  Server: $ntfy_server"

        # Check for token
        local ntfy_token
        if ntfy_token="$(get_ntfy_token 2>/dev/null)"; then
            success "ntfy token: ${ntfy_token:0:6}...${ntfy_token: -4} (authenticated)"
        else
            info "  Token: not set (using anonymous access)"
        fi

        if [ "$send_test_ntfy" = true ]; then
            info "Sending test notification..."
            if send_ntfy "agent-duo test" "This is a test notification from agent-duo doctor. Sent: $(date)" "default" "white_check_mark"; then
                success "Test notification sent to $ntfy_server/$ntfy_topic"
            else
                warn "Failed to send test notification"
                warn "  Check your internet connection, topic name, and token"
            fi
        else
            info "  Use --send-ntfy to send a test notification"
        fi
    else
        info "ntfy: not configured (optional)"
        info "  Configure with: agent-duo config ntfy_topic <your-topic>"
        info "  ntfy.sh is a free push notification service"
        info "  Subscribe at: https://ntfy.sh/<your-topic>"
    fi

    echo ""

    # --- Skills Installation ---
    echo "=== Skills Installation ==="

    # Claude skills
    local claude_skills="$HOME/.claude/commands"
    local claude_skills_ok=true
    for skill in duo-work duo-review duo-clarify duo-pushback duo-amend; do
        if [ -f "$claude_skills/$skill.md" ]; then
            success "Claude skill: $skill"
        else
            warn "Claude skill: $skill NOT FOUND"
            claude_skills_ok=false
        fi
    done
    if [ "$claude_skills_ok" = false ]; then
        warn "  Run: agent-duo setup"
        all_ok=false
    fi

    # Codex skills
    local codex_skills="$HOME/.codex/skills"
    local codex_skills_ok=true
    for skill in duo-work duo-review duo-clarify duo-pushback duo-amend; do
        if [ -f "$codex_skills/$skill/SKILL.md" ]; then
            success "Codex skill: $skill"
        else
            warn "Codex skill: $skill NOT FOUND"
            codex_skills_ok=false
        fi
    done
    if [ "$codex_skills_ok" = false ]; then
        warn "  Run: agent-duo setup"
        all_ok=false
    fi

    echo ""

    # --- Hook Configuration ---
    echo "=== Hook Configuration ==="

    local notify_script="$HOME/.local/bin/agent-duo-notify"
    if [ -x "$notify_script" ]; then
        success "Notify script: $notify_script"
    else
        warn "Notify script: NOT FOUND or not executable"
        warn "  Run: agent-duo setup"
        all_ok=false
    fi

    # Check Claude hooks
    local claude_settings="$HOME/.claude/settings.json"
    if [ -f "$claude_settings" ]; then
        if grep -q "agent-duo-notify" "$claude_settings" 2>/dev/null; then
            success "Claude hooks: configured"
        else
            warn "Claude hooks: not configured for agent-duo"
            warn "  Run: agent-duo setup"
        fi
    else
        warn "Claude settings: $claude_settings not found"
    fi

    # Check Codex hooks
    local codex_config="$HOME/.codex/config.toml"
    if [ -f "$codex_config" ]; then
        if grep -q "agent-duo-notify" "$codex_config" 2>/dev/null; then
            success "Codex hooks: configured"
        else
            warn "Codex hooks: not configured for agent-duo"
            warn "  Run: agent-duo setup"
        fi
    else
        warn "Codex config: $codex_config not found"
    fi

    echo ""

    # --- PATH Check ---
    echo "=== PATH Configuration ==="

    local install_dir="$HOME/.local/bin"
    if [[ ":$PATH:" == *":$install_dir:"* ]]; then
        success "~/.local/bin is in PATH"
    else
        warn "~/.local/bin is NOT in PATH"
        warn "  Add to your shell profile:"
        warn "  export PATH=\"\$HOME/.local/bin:\$PATH\""
        all_ok=false
    fi

    # Check if agent-duo is accessible
    if command -v agent-duo >/dev/null 2>&1; then
        success "agent-duo: found at $(command -v agent-duo)"
    else
        warn "agent-duo: not found in PATH"
        warn "  Run: agent-duo setup"
        all_ok=false
    fi

    echo ""

    # --- Summary ---
    echo "=== Summary ==="
    if [ "$all_ok" = true ]; then
        success "All checks passed!"
    else
        warn "Some issues found - see above for details"
        return 1
    fi
}

#------------------------------------------------------------------------------
# Command: config
#------------------------------------------------------------------------------

cmd_config() {
    local config_dir="$HOME/.config/agent-duo"
    local config_file="$config_dir/config"

    # List all config if no arguments
    if [ $# -eq 0 ]; then
        info "Configuration file: $config_file"
        echo ""
        if [ -f "$config_file" ]; then
            # Display config with token masked
            while IFS= read -r line; do
                if [[ "$line" =~ ^ntfy_token= ]]; then
                    local token="${line#ntfy_token=}"
                    echo "ntfy_token=${token:0:6}...${token: -4}"
                else
                    echo "$line"
                fi
            done < "$config_file"
        else
            info "No configuration set"
        fi
        echo ""
        info "Available settings:"
        echo "  codex_model  - GPT model for Codex (e.g., o3, gpt-4.1)"
        echo "  claude_model - Claude model (e.g., opus, sonnet)"
        echo "  ntfy_topic   - ntfy.sh topic for push notifications"
        echo "  ntfy_token   - ntfy.sh access token (for reserved topics)"
        echo "  ntfy_server  - ntfy server URL (default: https://ntfy.sh)"
        echo ""
        info "Usage: agent-duo config <key> [value]"
        return 0
    fi

    local key="$1"
    local value="${2:-}"

    # Validate key
    case "$key" in
        codex_model|claude_model|ntfy_topic|ntfy_token|ntfy_server)
            ;;
        *)
            die "Unknown config key: $key (valid: codex_model, claude_model, ntfy_topic, ntfy_token, ntfy_server)"
            ;;
    esac

    # Get value if not setting
    if [ -z "$value" ]; then
        if [ -f "$config_file" ]; then
            local current
            current="$(grep -E "^${key}=" "$config_file" 2>/dev/null | cut -d= -f2-)"
            if [ -n "$current" ]; then
                # Mask token for security
                if [ "$key" = "ntfy_token" ]; then
                    echo "${current:0:6}...${current: -4}"
                else
                    echo "$current"
                fi
            else
                info "$key is not set"
                return 1
            fi
        else
            info "$key is not set"
            return 1
        fi
        return 0
    fi

    # Set value
    mkdir -p "$config_dir"

    if [ -f "$config_file" ]; then
        # Remove existing key if present
        grep -v "^${key}=" "$config_file" > "$config_file.tmp" 2>/dev/null || true
        mv "$config_file.tmp" "$config_file"
    fi

    # Add new value
    echo "${key}=${value}" >> "$config_file"

    # Mask token in success message
    if [ "$key" = "ntfy_token" ]; then
        success "Set $key=${value:0:6}...${value: -4}"
    else
        success "Set $key=$value"
    fi

    # Show helpful info based on key
    case "$key" in
        codex_model)
            echo ""
            info "Codex will use model: $value"
            echo "  Common models: o3, o4-mini, gpt-4.1"
            ;;
        claude_model)
            echo ""
            info "Claude will use model: $value"
            echo "  Common models: opus, sonnet, haiku"
            ;;
        ntfy_topic)
            local server
            server="$(get_ntfy_server)"
            echo ""
            info "To receive notifications:"
            echo "  1. Install ntfy app on your phone (iOS/Android)"
            echo "  2. Subscribe to topic: $value"
            echo "  3. Or open in browser: $server/$value"
            echo ""
            info "Test with: agent-duo doctor --send-ntfy"
            ;;
        ntfy_token)
            echo ""
            info "Token configured for authenticated access."
            info "Test with: agent-duo doctor --send-ntfy"
            ;;
    esac
}

#------------------------------------------------------------------------------
# Command: start
#------------------------------------------------------------------------------

cmd_start() {
    local feature=""
    local ttyd_mode=true
    local auto_run=false
    local clarify_mode=false
    local pushback_mode=false
    local work_timeout=$DEFAULT_WORK_TIMEOUT
    local review_timeout=$DEFAULT_REVIEW_TIMEOUT
    local clarify_timeout=$DEFAULT_CLARIFY_TIMEOUT
    local pushback_timeout=$DEFAULT_PUSHBACK_TIMEOUT
    local max_rounds=10
    local codex_thinking=$DEFAULT_CODEX_THINKING
    local codex_model=""
    local claude_model=""
    local base_port=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --no-ttyd) ttyd_mode=false; shift ;;
            --auto-run) auto_run=true; shift ;;
            --clarify) clarify_mode=true; shift ;;
            --pushback) pushback_mode=true; shift ;;
            --work-timeout) work_timeout="$2"; shift 2 ;;
            --review-timeout) review_timeout="$2"; shift 2 ;;
            --clarify-timeout) clarify_timeout="$2"; shift 2 ;;
            --pushback-timeout) pushback_timeout="$2"; shift 2 ;;
            --max-rounds) max_rounds="$2"; shift 2 ;;
            --codex-thinking) codex_thinking="$2"; shift 2 ;;
            --codex-model) codex_model="$2"; shift 2 ;;
            --claude-model) claude_model="$2"; shift 2 ;;
            --port) base_port="$2"; shift 2 ;;
            -*) die "Unknown option: $1" ;;
            *) feature="$1"; shift ;;
        esac
    done

    # Export model overrides if specified (used by get_agent_cmd)
    [ -n "$codex_model" ] && export AGENT_DUO_CODEX_MODEL="$codex_model"
    [ -n "$claude_model" ] && export AGENT_DUO_CLAUDE_MODEL="$claude_model"

    [ -z "$feature" ] && die "Usage: agent-duo start <feature> [--no-ttyd] [--auto-run] [--clarify]"

    # Validate codex thinking effort
    case "$codex_thinking" in
        low|medium|high) ;;
        *) die "Invalid --codex-thinking value: $codex_thinking (valid: low, medium, high)" ;;
    esac

    # Ensure we're in a git repo
    git rev-parse --is-inside-work-tree >/dev/null 2>&1 || die "Not a git repository"

    # Ensure repo has at least one commit
    git rev-parse HEAD >/dev/null 2>&1 || die "Repository has no commits. Create an initial commit first."

    local project_root
    project_root="$(git rev-parse --show-toplevel)"
    local project_name
    project_name="$(basename "$project_root")"

    # Check for existing session
    if [ -d "$project_root/.peer-sync" ]; then
        die "Session already exists (.peer-sync found).
To continue an existing session: agent-duo run
To start fresh: agent-duo cleanup && agent-duo start $feature"
    fi

    # Check for task file
    local task_file
    if task_file="$(find_task_file "$project_root" "$feature")"; then
        info "Found task file: $task_file"
    else
        warn "Task file not found: $feature.md"
        warn "Searched: $feature.md, doc/$feature.md, docs/$feature.md, **/$feature.md"
        warn "Create it with the task description, or the agents won't know what to do."
    fi

    info "Starting Agent Duo session: $feature"
    info "Project: $project_name"

    # Set up worktree paths (siblings of project root)
    local parent_dir
    parent_dir="$(dirname "$project_root")"
    local worktree_claude="$parent_dir/${project_name}-${feature}-claude"
    local worktree_codex="$parent_dir/${project_name}-${feature}-codex"

    # Create branches and worktrees
    cd "$project_root"

    # Detect main branch: try origin/HEAD, then common names, then current branch
    local main_branch
    main_branch="$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@')" || true
    if [ -z "$main_branch" ]; then
        # Try common branch names
        for candidate in main master; do
            if git rev-parse --verify "$candidate" >/dev/null 2>&1; then
                main_branch="$candidate"
                break
            fi
        done
    fi
    if [ -z "$main_branch" ]; then
        # Fall back to current branch
        main_branch="$(git rev-parse --abbrev-ref HEAD)"
    fi

    if [ ! -d "$worktree_claude" ]; then
        info "Creating worktree for claude..."
        git worktree add -b "${feature}-claude" "$worktree_claude" "$main_branch" 2>/dev/null || \
            git worktree add "$worktree_claude" "${feature}-claude"
    else
        warn "Worktree already exists: $worktree_claude"
    fi

    if [ ! -d "$worktree_codex" ]; then
        info "Creating worktree for codex..."
        git worktree add -b "${feature}-codex" "$worktree_codex" "$main_branch" 2>/dev/null || \
            git worktree add "$worktree_codex" "${feature}-codex"
    else
        warn "Worktree already exists: $worktree_codex"
    fi

    # Initialize .peer-sync
    local peer_sync="$project_root/.peer-sync"
    mkdir -p "$peer_sync/reviews"
    mkdir -p "$peer_sync/pids"

    echo "active" > "$peer_sync/session"
    # Determine initial phase: clarify -> pushback -> work
    if $clarify_mode; then
        echo "clarify" > "$peer_sync/phase"
        echo "true" > "$peer_sync/clarify-mode"
        echo "clarifying|$(date +%s)|starting" > "$peer_sync/claude.status"
        echo "clarifying|$(date +%s)|starting" > "$peer_sync/codex.status"
    elif $pushback_mode; then
        echo "pushback" > "$peer_sync/phase"
        echo "pushing-back|$(date +%s)|starting" > "$peer_sync/claude.status"
        echo "pushing-back|$(date +%s)|starting" > "$peer_sync/codex.status"
    else
        echo "work" > "$peer_sync/phase"
        echo "working|$(date +%s)|starting" > "$peer_sync/claude.status"
        echo "working|$(date +%s)|starting" > "$peer_sync/codex.status"
    fi
    echo "$clarify_mode" > "$peer_sync/clarify-mode"
    echo "$pushback_mode" > "$peer_sync/pushback-mode"
    echo "1" > "$peer_sync/round"
    echo "$feature" > "$peer_sync/feature"
    echo "$codex_thinking" > "$peer_sync/codex-thinking"
    echo "duo" > "$peer_sync/mode"

    # Create symlinks in worktrees
    ln -sfn "$peer_sync" "$worktree_claude/.peer-sync"
    ln -sfn "$peer_sync" "$worktree_codex/.peer-sync"

    # Ensure .peer-sync is excluded from git (using .git/info/exclude to avoid modifying tracked files)
    local git_exclude="$project_root/.git/info/exclude"
    if [ -f "$git_exclude" ]; then
        if ! grep -qxF ".peer-sync" "$git_exclude"; then
            echo ".peer-sync" >> "$git_exclude"
        fi
    else
        mkdir -p "$(dirname "$git_exclude")"
        echo ".peer-sync" > "$git_exclude"
    fi

    # Copy task file to worktrees if it exists
    if [ -f "$task_file" ]; then
        cp "$task_file" "$worktree_claude/"
        cp "$task_file" "$worktree_codex/"
    fi

    if $ttyd_mode; then
        start_ttyd_mode "$feature" "$project_root" "$worktree_claude" "$worktree_codex" "$peer_sync" \
            "$auto_run" "$work_timeout" "$review_timeout" "$max_rounds" "$codex_thinking" "$clarify_mode" "$clarify_timeout" "$pushback_mode" "$pushback_timeout"
    else
        start_tmux_mode "$feature" "$project_root" "$worktree_claude" "$worktree_codex" "$peer_sync" "$codex_thinking" "$clarify_mode" "$pushback_mode"
    fi
}

start_tmux_mode() {
    local feature="$1"
    local project_root="$2"
    local worktree_claude="$3"
    local worktree_codex="$4"
    local peer_sync="$5"
    local codex_thinking="${6:-$DEFAULT_CODEX_THINKING}"
    local clarify_mode="${7:-false}"
    local pushback_mode="${8:-false}"

    local session_name="duo-${feature}"

    # Kill existing session if any
    tmux kill-session -t "$session_name" 2>/dev/null || true

    # Create new tmux session with orchestrator window
    tmux new-session -d -s "$session_name" -n "orchestrator" -c "$project_root"

    # Create claude window
    tmux new-window -t "$session_name" -n "claude" -c "$worktree_claude"
    tmux send-keys -t "$session_name:claude" "export PEER_SYNC='$peer_sync'"
    tmux send-keys -t "$session_name:claude" C-m
    tmux send-keys -t "$session_name:claude" "export MY_NAME='claude'"
    tmux send-keys -t "$session_name:claude" C-m
    tmux send-keys -t "$session_name:claude" "export PEER_NAME='codex'"
    tmux send-keys -t "$session_name:claude" C-m
    tmux send-keys -t "$session_name:claude" "export PEER_WORKTREE='$worktree_codex'"
    tmux send-keys -t "$session_name:claude" C-m
    tmux send-keys -t "$session_name:claude" "export FEATURE='$feature'"
    tmux send-keys -t "$session_name:claude" C-m

    # Create codex window
    tmux new-window -t "$session_name" -n "codex" -c "$worktree_codex"
    tmux send-keys -t "$session_name:codex" "export PEER_SYNC='$peer_sync'"
    tmux send-keys -t "$session_name:codex" C-m
    tmux send-keys -t "$session_name:codex" "export MY_NAME='codex'"
    tmux send-keys -t "$session_name:codex" C-m
    tmux send-keys -t "$session_name:codex" "export PEER_NAME='claude'"
    tmux send-keys -t "$session_name:codex" C-m
    tmux send-keys -t "$session_name:codex" "export PEER_WORKTREE='$worktree_claude'"
    tmux send-keys -t "$session_name:codex" C-m
    tmux send-keys -t "$session_name:codex" "export FEATURE='$feature'"
    tmux send-keys -t "$session_name:codex" C-m

    success "Created tmux session: $session_name"
    echo ""
    echo "Windows:"
    echo "  0: orchestrator  - Main project root"
    echo "  1: claude        - $worktree_claude"
    echo "  2: codex         - $worktree_codex"
    echo ""
    echo "Attach with: tmux attach -t $session_name"
    echo ""
    echo "To start agents, in each window run their CLI:"
    echo "  claude window: $(get_agent_cmd claude)"
    echo "  codex window:  $(get_agent_cmd codex "$codex_thinking")"
    if [ "$clarify_mode" = "true" ]; then
        echo ""
        echo "Clarify stage enabled. After agents submit their approaches:"
        echo "  1. Review approaches in .peer-sync/clarify-*.md"
        echo "  2. Respond to agents in their terminals (back-and-forth OK)"
        echo "  3. Press Enter in the orchestrator to proceed"
    fi
    if [ "$pushback_mode" = "true" ]; then
        echo ""
        echo "Pushback stage enabled. After clarify (if enabled), agents will:"
        echo "  1. Propose improvements to the task file"
        echo "  2. You can accept, reject, or modify the pushbacks"
    fi
}

start_ttyd_mode() {
    local feature="$1"
    local project_root="$2"
    local worktree_claude="$3"
    local worktree_codex="$4"
    local peer_sync="$5"
    local auto_run="${6:-false}"
    local work_timeout="${7:-$DEFAULT_WORK_TIMEOUT}"
    local review_timeout="${8:-$DEFAULT_REVIEW_TIMEOUT}"
    local max_rounds="${9:-10}"
    local codex_thinking="${10:-$DEFAULT_CODEX_THINKING}"
    local clarify_mode="${11:-false}"
    local clarify_timeout="${12:-$DEFAULT_CLARIFY_TIMEOUT}"
    local pushback_mode="${13:-false}"
    local pushback_timeout="${14:-$DEFAULT_PUSHBACK_TIMEOUT}"

    local session_name="duo-${feature}"

    # Check ttyd is installed
    command -v ttyd >/dev/null 2>&1 || die "ttyd not found. Install with: brew install ttyd"

    # Kill existing sessions if any
    tmux kill-session -t "${session_name}-orchestrator" 2>/dev/null || true
    tmux kill-session -t "${session_name}-claude" 2>/dev/null || true
    tmux kill-session -t "${session_name}-codex" 2>/dev/null || true

    # Create tmux sessions for orchestrator and each agent
    tmux new-session -d -s "${session_name}-orchestrator" -c "$project_root"
    tmux new-session -d -s "${session_name}-claude" -c "$worktree_claude"
    tmux new-session -d -s "${session_name}-codex" -c "$worktree_codex"

    # Set environment variables for orchestrator
    for var in "PEER_SYNC='$peer_sync'" "FEATURE='$feature'"; do
        tmux send-keys -t "${session_name}-orchestrator" "export $var"
        tmux send-keys -t "${session_name}-orchestrator" C-m
    done

    # Set environment variables for agents
    for var in "PEER_SYNC='$peer_sync'" "MY_NAME='claude'" "PEER_NAME='codex'" "PEER_WORKTREE='$worktree_codex'" "FEATURE='$feature'"; do
        tmux send-keys -t "${session_name}-claude" "export $var"
        tmux send-keys -t "${session_name}-claude" C-m
    done

    for var in "PEER_SYNC='$peer_sync'" "MY_NAME='codex'" "PEER_NAME='claude'" "PEER_WORKTREE='$worktree_claude'" "FEATURE='$feature'"; do
        tmux send-keys -t "${session_name}-codex" "export $var"
        tmux send-keys -t "${session_name}-codex" C-m
    done

    # Allocate and load ports
    allocate_ports "$peer_sync" "$base_port"
    get_ports "$peer_sync"
    local orchestrator_port=$ORCHESTRATOR_PORT
    local claude_port=$CLAUDE_PORT
    local codex_port=$CODEX_PORT

    ttyd -p "$orchestrator_port" -W tmux attach -t "${session_name}-orchestrator" &
    echo $! > "$peer_sync/pids/ttyd-orchestrator.pid"

    ttyd -p "$claude_port" -W tmux attach -t "${session_name}-claude" &
    echo $! > "$peer_sync/pids/ttyd-claude.pid"

    ttyd -p "$codex_port" -W tmux attach -t "${session_name}-codex" &
    echo $! > "$peer_sync/pids/ttyd-codex.pid"

    success "Started ttyd servers"
    echo ""
    echo "Web terminals:"
    echo "  Orchestrator: http://localhost:$orchestrator_port"
    echo "  Claude:       http://localhost:$claude_port"
    echo "  Codex:        http://localhost:$codex_port"
    echo ""

    # If auto-run, start the orchestrator loop in the orchestrator session
    if [ "$auto_run" = "true" ]; then
        info "Starting orchestrator with --auto-start..."
        local run_cmd="agent-duo run --auto-start --work-timeout $work_timeout --review-timeout $review_timeout --max-rounds $max_rounds"
        if [ "$clarify_mode" = "true" ]; then
            run_cmd="$run_cmd --clarify-timeout $clarify_timeout"
        fi
        if [ "$pushback_mode" = "true" ]; then
            run_cmd="$run_cmd --pushback-timeout $pushback_timeout"
        fi
        tmux send-keys -t "${session_name}-orchestrator" "$run_cmd"
        tmux send-keys -t "${session_name}-orchestrator" C-m
    else
        echo "Start orchestrator with: agent-duo run --auto-start"
    fi
    echo "Stop with: agent-duo stop"
    if [ "$clarify_mode" = "true" ]; then
        echo ""
        echo "Clarify stage enabled. After agents submit their approaches:"
        echo "  1. Review approaches (shown in orchestrator, also emailed)"
        echo "  2. Respond to agents in their terminals (back-and-forth OK)"
        echo "  3. Press Enter in the orchestrator to proceed"
    fi
    if [ "$pushback_mode" = "true" ]; then
        echo ""
        echo "Pushback stage enabled. After clarify (if enabled), agents will:"
        echo "  1. Propose improvements to the task file"
        echo "  2. You can accept, reject, or modify the pushbacks"
    fi
}

#------------------------------------------------------------------------------
# Command: stop
#------------------------------------------------------------------------------

cmd_stop() {
    local root
    root="$(get_project_root)"
    local peer_sync="$root/.peer-sync"

    info "Stopping Agent Duo..."

    # Kill ttyd processes from PID files
    if [ -d "$peer_sync/pids" ]; then
        for pidfile in "$peer_sync/pids"/*.pid; do
            [ -f "$pidfile" ] || continue
            local pid
            pid="$(cat "$pidfile")"
            if kill -0 "$pid" 2>/dev/null; then
                kill "$pid" 2>/dev/null || true
                info "Killed process $pid ($(basename "$pidfile" .pid))"
            fi
            rm -f "$pidfile"
        done
    fi

    # Get feature name for session-specific cleanup
    local feature
    feature="$(get_feature 2>/dev/null)" || true

    # Fallback: kill ttyd processes for THIS session only (in case PID files are missing)
    if [ -n "$feature" ]; then
        pkill -f "ttyd.*duo-${feature}-" 2>/dev/null && info "Killed remaining ttyd processes for duo-${feature}" || true
    fi

    # Kill tmux sessions for this feature
    if [ -n "$feature" ]; then
        tmux kill-session -t "duo-${feature}" 2>/dev/null && info "Killed tmux session: duo-${feature}" || true
        tmux kill-session -t "duo-${feature}-orchestrator" 2>/dev/null && info "Killed tmux session: duo-${feature}-orchestrator" || true
        tmux kill-session -t "duo-${feature}-claude" 2>/dev/null && info "Killed tmux session: duo-${feature}-claude" || true
        tmux kill-session -t "duo-${feature}-codex" 2>/dev/null && info "Killed tmux session: duo-${feature}-codex" || true
    fi

    success "Stopped"
}

#------------------------------------------------------------------------------
# Command: restart
#------------------------------------------------------------------------------

cmd_restart() {
    local auto_run=false
    local work_timeout=$DEFAULT_WORK_TIMEOUT
    local review_timeout=$DEFAULT_REVIEW_TIMEOUT
    local max_rounds=10

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --auto-run) auto_run=true; shift ;;
            --work-timeout) work_timeout="$2"; shift 2 ;;
            --review-timeout) review_timeout="$2"; shift 2 ;;
            --max-rounds) max_rounds="$2"; shift 2 ;;
            -*) die "Unknown option: $1" ;;
            *) die "Unknown argument: $1" ;;
        esac
    done

    local root
    root="$(get_project_root 2>/dev/null)" || die "Not in an agent-duo session (no .peer-sync found)"
    local peer_sync="$root/.peer-sync"

    # Check we have an active session
    [ -f "$peer_sync/feature" ] || die "No active session (missing .peer-sync/feature)"
    [ -f "$peer_sync/ports" ] || die "No port allocations found. Was this a ttyd session?"

    local feature
    feature="$(get_feature)"
    local project_name
    project_name="$(basename "$root")"
    local parent_dir
    parent_dir="$(dirname "$root")"

    # Calculate paths
    local worktree_claude="$parent_dir/${project_name}-${feature}-claude"
    local worktree_codex="$parent_dir/${project_name}-${feature}-codex"
    local session_name="duo-${feature}"

    # Load ports
    get_ports "$peer_sync"
    local orchestrator_port=$ORCHESTRATOR_PORT
    local claude_port=$CLAUDE_PORT
    local codex_port=$CODEX_PORT

    # Load codex thinking effort
    local codex_thinking
    codex_thinking="$(cat "$peer_sync/codex-thinking" 2>/dev/null)" || codex_thinking="$DEFAULT_CODEX_THINKING"

    echo ""
    echo "=== Agent Duo Restart ==="
    echo ""
    echo "Feature:  $feature"
    echo "Project:  $project_name"
    echo "Codex thinking: $codex_thinking"
    echo ""

    # Ensure pids directory exists
    mkdir -p "$peer_sync/pids"

    local errors=0
    local restarted=0

    #---------------------------------------------------------------------------
    # Phase 1: Check and restart tmux sessions
    #---------------------------------------------------------------------------
    info "Checking tmux sessions..."

    # Check orchestrator tmux session
    if ! tmux_session_exists "${session_name}-orchestrator"; then
        info "Creating tmux session: ${session_name}-orchestrator"
        tmux new-session -d -s "${session_name}-orchestrator" -c "$root"
        for var in "PEER_SYNC='$peer_sync'" "FEATURE='$feature'"; do
            tmux send-keys -t "${session_name}-orchestrator" "export $var"
            tmux send-keys -t "${session_name}-orchestrator" C-m
        done
        restarted=$((restarted + 1))
    else
        success "  orchestrator tmux session: OK"
    fi

    # Check claude tmux session
    if ! tmux_session_exists "${session_name}-claude"; then
        if [ ! -d "$worktree_claude" ]; then
            warn "  claude worktree missing: $worktree_claude"
            errors=$((errors + 1))
        else
            info "Creating tmux session: ${session_name}-claude"
            tmux new-session -d -s "${session_name}-claude" -c "$worktree_claude"
            for var in "PEER_SYNC='$peer_sync'" "MY_NAME='claude'" "PEER_NAME='codex'" "PEER_WORKTREE='$worktree_codex'" "FEATURE='$feature'"; do
                tmux send-keys -t "${session_name}-claude" "export $var"
                tmux send-keys -t "${session_name}-claude" C-m
            done
            restarted=$((restarted + 1))
        fi
    else
        success "  claude tmux session: OK"
    fi

    # Check codex tmux session
    if ! tmux_session_exists "${session_name}-codex"; then
        if [ ! -d "$worktree_codex" ]; then
            warn "  codex worktree missing: $worktree_codex"
            errors=$((errors + 1))
        else
            info "Creating tmux session: ${session_name}-codex"
            tmux new-session -d -s "${session_name}-codex" -c "$worktree_codex"
            for var in "PEER_SYNC='$peer_sync'" "MY_NAME='codex'" "PEER_NAME='claude'" "PEER_WORKTREE='$worktree_claude'" "FEATURE='$feature'"; do
                tmux send-keys -t "${session_name}-codex" "export $var"
                tmux send-keys -t "${session_name}-codex" C-m
            done
            restarted=$((restarted + 1))
        fi
    else
        success "  codex tmux session: OK"
    fi

    #---------------------------------------------------------------------------
    # Phase 2: Check and restart ttyd servers
    #---------------------------------------------------------------------------
    echo ""
    info "Checking ttyd servers..."

    # Check orchestrator ttyd
    if ! restart_ttyd_for_session "orchestrator" "$orchestrator_port" \
            "${session_name}-orchestrator" "$peer_sync/pids/ttyd-orchestrator.pid"; then
        errors=$((errors + 1))
    elif [ $? -eq 0 ] && ! is_port_in_use "$orchestrator_port" 2>/dev/null; then
        # Verify port came up
        sleep 0.5
        is_port_in_use "$orchestrator_port" || errors=$((errors + 1))
    fi

    # Check claude ttyd
    if ! restart_ttyd_for_session "claude" "$claude_port" \
            "${session_name}-claude" "$peer_sync/pids/ttyd-claude.pid"; then
        errors=$((errors + 1))
    fi

    # Check codex ttyd
    if ! restart_ttyd_for_session "codex" "$codex_port" \
            "${session_name}-codex" "$peer_sync/pids/ttyd-codex.pid"; then
        errors=$((errors + 1))
    fi

    #---------------------------------------------------------------------------
    # Phase 3: Check and restart agent TUIs
    #---------------------------------------------------------------------------
    echo ""
    info "Checking agent TUIs..."

    # Check claude TUI (thinking effort not used for claude)
    if ! restart_agent_tui "claude" "${session_name}-claude"; then
        errors=$((errors + 1))
    fi

    # Check codex TUI (pass thinking effort)
    if ! restart_agent_tui "codex" "${session_name}-codex" "$codex_thinking"; then
        errors=$((errors + 1))
    fi

    #---------------------------------------------------------------------------
    # Phase 4: Check orchestration state and optionally restart orchestrator
    #---------------------------------------------------------------------------
    echo ""
    info "Checking orchestration state..."

    local session_state
    session_state="$(cat "$peer_sync/session" 2>/dev/null)" || session_state="unknown"
    local phase
    phase="$(cat "$peer_sync/phase" 2>/dev/null)" || phase="unknown"
    local round
    round="$(cat "$peer_sync/round" 2>/dev/null)" || round="1"

    echo "  Session: $session_state"
    echo "  Phase:   $phase"
    echo "  Round:   $round"

    # Check if both agents have PRs (terminal state)
    local claude_has_pr=false
    local codex_has_pr=false
    [ -f "$peer_sync/claude.pr" ] && claude_has_pr=true
    [ -f "$peer_sync/codex.pr" ] && codex_has_pr=true

    if [ "$session_state" = "complete" ] || ($claude_has_pr && $codex_has_pr); then
        echo ""
        if [ -f "$peer_sync/claude.pr" ]; then
            echo "  Claude PR: $(cat "$peer_sync/claude.pr")"
        fi
        if [ -f "$peer_sync/codex.pr" ]; then
            echo "  Codex PR:  $(cat "$peer_sync/codex.pr")"
        fi
        if [ "$auto_run" = "true" ]; then
            info "PRs created. Transitioning to pr-comments phase for monitoring..."
            echo "pr-comments" > "$peer_sync/phase"
            echo "active" > "$peer_sync/session"
            tmux send-keys -t "${session_name}-orchestrator" \
                "agent-duo run --auto-start --work-timeout $work_timeout --review-timeout $review_timeout --max-rounds $max_rounds"
            tmux send-keys -t "${session_name}-orchestrator" C-m
            success "Started PR comment monitoring"
        else
            info "PRs created. To monitor for PR comments:"
            echo "  agent-duo restart --auto-run"
        fi
    elif [ "$auto_run" = "true" ]; then
        echo ""
        info "Restarting orchestrator loop..."

        # Determine if orchestrator is already running
        local orchestrator_running=false
        if agent_tui_is_running "${session_name}-orchestrator" "orchestrator"; then
            orchestrator_running=true
        fi

        if ! $orchestrator_running; then
            tmux send-keys -t "${session_name}-orchestrator" \
                "agent-duo run --auto-start --work-timeout $work_timeout --review-timeout $review_timeout --max-rounds $max_rounds"
            tmux send-keys -t "${session_name}-orchestrator" C-m
            success "Started orchestrator loop"
        else
            info "Orchestrator appears to already be running"
        fi
    else
        echo ""
        info "Session is not complete. To restart the orchestrator loop:"
        echo "  agent-duo restart --auto-run"
        echo "Or manually in the orchestrator terminal:"
        echo "  agent-duo run --auto-start"
    fi

    #---------------------------------------------------------------------------
    # Summary
    #---------------------------------------------------------------------------
    echo ""
    echo "--- Web Terminals ---"
    echo "Orchestrator: http://localhost:$orchestrator_port"
    echo "Claude:       http://localhost:$claude_port"
    echo "Codex:        http://localhost:$codex_port"
    echo ""

    if [ "$errors" -gt 0 ]; then
        warn "Restart completed with $errors error(s)"
        return 1
    else
        success "Restart complete!"
        return 0
    fi
}

#------------------------------------------------------------------------------
# Command: status
#------------------------------------------------------------------------------

cmd_status() {
    local root
    root="$(get_project_root 2>/dev/null)" || die "Not in an agent-duo session"
    local peer_sync="$root/.peer-sync"

    echo ""
    echo "=== Agent Duo Status ==="
    echo ""

    if [ -f "$peer_sync/feature" ]; then
        echo "Feature:  $(cat "$peer_sync/feature")"
    fi

    if [ -f "$peer_sync/session" ]; then
        echo "Session:  $(cat "$peer_sync/session")"
    fi

    if [ -f "$peer_sync/phase" ]; then
        echo "Phase:    $(cat "$peer_sync/phase")"
    fi

    if [ -f "$peer_sync/round" ]; then
        echo "Round:    $(cat "$peer_sync/round")"
    fi

    # Show allocated ports if available
    if [ -f "$peer_sync/ports" ]; then
        # shellcheck source=/dev/null
        source "$peer_sync/ports"
        echo ""
        echo "--- Web Terminals ---"
        echo "Orchestrator: http://localhost:$ORCHESTRATOR_PORT"
        echo "Claude:       http://localhost:$CLAUDE_PORT"
        echo "Codex:        http://localhost:$CODEX_PORT"
    fi

    echo ""
    echo "--- Agent Status ---"

    for agent in claude codex; do
        local status_file="$peer_sync/${agent}.status"
        if [ -f "$status_file" ]; then
            local line
            line="$(cat "$status_file")"
            local status msg timestamp
            status="$(echo "$line" | cut -d'|' -f1)"
            timestamp="$(echo "$line" | cut -d'|' -f2)"
            msg="$(echo "$line" | cut -d'|' -f3-)"

            local time_str=""
            if [ -n "$timestamp" ] && [ "$timestamp" != "$status" ]; then
                time_str=" ($(date -r "$timestamp" '+%H:%M:%S' 2>/dev/null || echo "$timestamp"))"
            fi

            printf "%-8s: %s%s" "$agent" "$status" "$time_str"
            [ -n "$msg" ] && [ "$msg" != "$status" ] && printf " - %s" "$msg"
            echo ""
        else
            echo "$agent:   (no status)"
        fi
    done

    # Check for PRs
    echo ""
    echo "--- Pull Requests ---"
    for agent in claude codex; do
        local pr_file="$peer_sync/${agent}.pr"
        if [ -f "$pr_file" ]; then
            echo "$agent:   $(cat "$pr_file")"
        else
            echo "$agent:   (none)"
        fi
    done

    # List reviews
    if [ -d "$peer_sync/reviews" ] && [ "$(ls -A "$peer_sync/reviews" 2>/dev/null)" ]; then
        echo ""
        echo "--- Reviews ---"
        ls -1 "$peer_sync/reviews"
    fi

    echo ""
}

#------------------------------------------------------------------------------
# Command: pr
#------------------------------------------------------------------------------

cmd_pr() {
    local agent="$1"
    [ -z "$agent" ] && die "Usage: agent-duo pr <agent>"

    local root
    root="$(get_project_root)"
    local peer_sync="$root/.peer-sync"
    local feature
    feature="$(get_feature)"

    # Determine worktree
    local project_name
    project_name="$(basename "$root")"
    local parent_dir
    parent_dir="$(dirname "$root")"
    local worktree="$parent_dir/${project_name}-${feature}-${agent}"

    [ -d "$worktree" ] || die "Worktree not found: $worktree"

    info "Creating PR for $agent..."

    cd "$worktree"

    # Check if feature file exists and was NOT modified (should be deleted)
    # The feature file is copied to the worktree root during start
    local feature_file="$worktree/${feature}.md"
    if [ -f "$feature_file" ]; then
        # Get the main branch to compare against
        local main_branch
        main_branch="$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@')" || true
        if [ -z "$main_branch" ]; then
            for candidate in main master; do
                if git rev-parse --verify "$candidate" >/dev/null 2>&1; then
                    main_branch="$candidate"
                    break
                fi
            done
        fi
        if [ -z "$main_branch" ]; then
            main_branch="HEAD~1"  # fallback: compare to parent commit
        fi

        # Check if the feature file was modified compared to when it was copied
        # We compare the file content in the worktree against main branch
        local file_modified=false
        if git show "${main_branch}:${feature}.md" >/dev/null 2>&1; then
            # File exists in main branch - check if content differs
            if ! git diff --quiet "${main_branch}" -- "${feature}.md" 2>/dev/null; then
                file_modified=true
            fi
        else
            # File doesn't exist in main branch (was copied during start)
            # Check if it was modified from the original task file in .peer-sync or root
            local original_task_file
            if original_task_file="$(find_task_file "$root" "$feature")"; then
                if ! diff -q "$feature_file" "$original_task_file" >/dev/null 2>&1; then
                    file_modified=true
                fi
            fi
        fi

        if [ "$file_modified" = "false" ]; then
            info "Feature file ${feature}.md was not modified - removing it"
            git rm "${feature}.md"
            git commit -m "Remove unmodified feature file ${feature}.md"
        fi
    fi

    # Check for changes
    if [ -z "$(git status --porcelain)" ]; then
        warn "No changes to commit in $agent's worktree"
    else
        # Auto-commit changes
        git add -A
        git commit -m "Solution from $agent for $feature" || true
    fi

    # Push branch
    local branch="${feature}-${agent}"
    git push -u origin "$branch" 2>/dev/null || git push origin "$branch"

    # Look for PR body file
    local pr_body=""
    local pr_body_file="$root/${feature}-${agent}-PR.md"
    if [ -f "$pr_body_file" ]; then
        pr_body="$(cat "$pr_body_file")"
    else
        pr_body="Solution from $agent for feature: $feature"
    fi

    # Create PR
    local pr_url
    pr_url="$(gh pr create --title "${agent}'s solution for $feature" --body "$pr_body" --head "$branch" 2>/dev/null)" || \
        pr_url="$(gh pr view --json url -q '.url' 2>/dev/null)" || \
        die "Failed to create PR. Is gh installed and authenticated?"

    # Record PR
    echo "$pr_url" > "$peer_sync/${agent}.pr"
    atomic_write "$peer_sync/${agent}.status" "pr-created|$(date +%s)|$pr_url"

    success "PR created: $pr_url"

    # Send notification
    send_pr_notification "$agent" "$feature" "$pr_url" "duo"

    # Check if both PRs exist
    if [ -f "$peer_sync/claude.pr" ] && [ -f "$peer_sync/codex.pr" ]; then
        echo "complete" > "$peer_sync/session"
        success "Both PRs created - session complete!"
    fi
}

#------------------------------------------------------------------------------
# Command: cleanup
#------------------------------------------------------------------------------

cmd_cleanup() {
    local full=false
    [ "$1" = "--full" ] && full=true

    local root
    root="$(get_project_root)"
    local peer_sync="$root/.peer-sync"
    local feature
    feature="$(get_feature)"
    local project_name
    project_name="$(basename "$root")"
    local parent_dir
    parent_dir="$(dirname "$root")"

    info "Cleaning up session: $feature"

    # Stop any running processes first
    cmd_stop

    # Always remove session state (.peer-sync)
    rm -rf "$peer_sync"
    info "Removed .peer-sync"

    if $full; then
        # Remove worktrees
        local worktree_claude="$parent_dir/${project_name}-${feature}-claude"
        local worktree_codex="$parent_dir/${project_name}-${feature}-codex"

        cd "$root"  # Make sure we're not in a worktree

        if [ -d "$worktree_claude" ]; then
            git worktree remove --force "$worktree_claude" 2>/dev/null || rm -rf "$worktree_claude"
            info "Removed worktree: $worktree_claude"
        fi

        if [ -d "$worktree_codex" ]; then
            git worktree remove --force "$worktree_codex" 2>/dev/null || rm -rf "$worktree_codex"
            info "Removed worktree: $worktree_codex"
        fi

        # Prune worktree references
        git worktree prune

        # Delete branches
        git branch -D "${feature}-claude" 2>/dev/null && info "Deleted branch: ${feature}-claude" || true
        git branch -D "${feature}-codex" 2>/dev/null && info "Deleted branch: ${feature}-codex" || true
    fi

    success "Cleanup complete"
}

#------------------------------------------------------------------------------
# Command: merge - Start merge phase to consolidate PRs
#------------------------------------------------------------------------------

# Extract vote from a merge-vote file (returns "claude" or "codex")
extract_vote() {
    local vote_file="$1"
    if [ ! -f "$vote_file" ]; then
        echo ""
        return
    fi
    # Look for "## My Vote: claude" or "## My Vote: codex" pattern
    grep -i "^## My Vote:" "$vote_file" | head -1 | sed 's/.*: *\([a-z]*\).*/\1/' | tr '[:upper:]' '[:lower:]'
}

# Check if both agents have voted
both_voted() {
    local peer_sync="$1"
    [ -f "$peer_sync/merge-vote-claude.md" ] && [ -f "$peer_sync/merge-vote-codex.md" ]
}

# Check if votes agree
votes_agree() {
    local peer_sync="$1"
    local claude_vote codex_vote
    claude_vote="$(extract_vote "$peer_sync/merge-vote-claude.md")"
    codex_vote="$(extract_vote "$peer_sync/merge-vote-codex.md")"
    [ -n "$claude_vote" ] && [ "$claude_vote" = "$codex_vote" ]
}

# Get the agreed vote (or empty if no agreement)
get_agreed_vote() {
    local peer_sync="$1"
    local claude_vote codex_vote
    claude_vote="$(extract_vote "$peer_sync/merge-vote-claude.md")"
    codex_vote="$(extract_vote "$peer_sync/merge-vote-codex.md")"
    if [ -n "$claude_vote" ] && [ "$claude_vote" = "$codex_vote" ]; then
        echo "$claude_vote"
    else
        echo ""
    fi
}

# Generate merge vote message for agents (sent at start of merge phase)
generate_merge_vote_message() {
    local agent="$1"
    local peer="$2"
    local feature="$3"
    local peer_sync="$4"
    local claude_pr="$5"
    local codex_pr="$6"

    cat <<EOF
# Merge Phase: Vote on PR to Merge

Both PRs are ready. You must analyze them and vote on which one to merge.

---
## Agent-Duo Context - MERGE VOTE PHASE

You are **$agent** in a fresh merge session. This is NOT the agent who created either PR.

**Your Task**: Objectively evaluate both solutions and vote.

### PRs to Evaluate

- **Claude's PR**: $claude_pr
- **Codex's PR**: $codex_pr

### Environment

- **Working directory**: Main branch (project root)
- **Sync directory**: $peer_sync
- **Feature**: $feature

### Steps

1. Read the original task: \`cat "$feature.md"\`
2. View both PRs: \`gh pr view <url>\` and \`gh pr diff <url>\`
3. Read previous reviews: \`ls "$peer_sync/reviews/" && cat "$peer_sync/reviews/"*.md\`

### Write Your Vote

\`\`\`bash
cat > "$peer_sync/merge-vote-${agent}.md" << 'VOTE_EOF'
# Merge Vote from $agent

## Summary of Claude's PR
[2-3 sentences on approach and key decisions]

## Summary of Codex's PR
[2-3 sentences on approach and key decisions]

## Comparison
| Aspect | Claude's PR | Codex's PR |
|--------|-------------|------------|
| Code quality | | |
| Test coverage | | |
| Alignment with task | | |

## My Vote: [claude / codex]

### Rationale
[3-5 sentences explaining your choice]

### Features to Cherry-Pick from Losing PR
[List specific features that should be incorporated]

VOTE_EOF
\`\`\`

Edit with actual content, then signal:

\`\`\`bash
agent-duo signal "$agent" vote-done "merge vote submitted"
\`\`\`

Then **STOP and wait** for consensus check.
EOF
}

# Generate merge debate message for agents (triggered when votes disagree)
generate_merge_debate_message() {
    local agent="$1"
    local peer="$2"
    local feature="$3"
    local peer_sync="$4"
    local debate_round="$5"

    cat <<EOF
# Merge Phase: Debate Round $debate_round

Your vote differs from $peer's. Review their reasoning and respond.

---
## Agent-Duo Context - MERGE DEBATE

Read your peer's vote and reconsider:

\`\`\`bash
cat "$peer_sync/merge-vote-${peer}.md"
\`\`\`

Then update your vote file:

\`\`\`bash
cat > "$peer_sync/merge-vote-${agent}.md" << 'VOTE_EOF'
# Merge Vote from $agent (Debate Round $debate_round)

## Response to $peer's Arguments
[Address their key points. What do you agree/disagree with?]

## My Vote: [claude / codex]

### Position: [CHANGED / UNCHANGED]

### Rationale
[If changed: what convinced you. If unchanged: why their arguments don't outweigh yours]

### Features to Cherry-Pick from Losing PR
[Updated list combining insights from both analyses]

VOTE_EOF
\`\`\`

Edit with actual content, then signal:

\`\`\`bash
agent-duo signal "$agent" debate-done "debate response submitted"
\`\`\`

Then **STOP and wait**.
EOF
}

cmd_merge() {
    local root
    root="$(get_project_root)"
    local peer_sync="$root/.peer-sync"
    local feature
    feature="$(get_feature)"

    # Validate both PRs exist
    if ! has_pr "claude" "$peer_sync" || ! has_pr "codex" "$peer_sync"; then
        die "Both PRs must exist before merge phase. Run 'agent-duo pr <agent>' first."
    fi

    local claude_pr codex_pr
    claude_pr="$(cat "$peer_sync/claude.pr")"
    codex_pr="$(cat "$peer_sync/codex.pr")"

    info "=== Merge Phase ==="
    echo "Claude PR: $claude_pr"
    echo "Codex PR:  $codex_pr"
    echo ""

    # Check if PRs are still open
    local claude_open=false codex_open=false
    is_pr_open "$claude_pr" && claude_open=true
    is_pr_open "$codex_pr" && codex_open=true

    if ! $claude_open && ! $codex_open; then
        die "Both PRs are already closed/merged. Nothing to do."
    fi

    # Initialize merge phase state
    echo "merge" > "$peer_sync/phase"
    echo "1" > "$peer_sync/merge-round"
    rm -f "$peer_sync/merge-vote-claude.md" "$peer_sync/merge-vote-codex.md"
    rm -f "$peer_sync/merge-decision"

    # Get tmux session info
    local session_name="duo-${feature}"
    local claude_session codex_session

    if tmux has-session -t "$session_name" 2>/dev/null; then
        claude_session="${session_name}:claude"
        codex_session="${session_name}:codex"
    elif tmux has-session -t "${session_name}-claude" 2>/dev/null; then
        claude_session="${session_name}-claude"
        codex_session="${session_name}-codex"
    else
        die "No tmux sessions found. Start a session first with 'agent-duo restart'."
    fi

    # Timeouts
    local vote_timeout="${VOTE_TIMEOUT:-600}"
    local debate_timeout="${DEBATE_TIMEOUT:-300}"
    local max_debate_rounds=2
    local poll_interval=5

    # === VOTE PHASE ===
    info "=== Vote Phase ==="

    # Send vote messages to both agents
    atomic_write "$peer_sync/claude.status" "voting|$(date +%s)|merge vote phase"
    info "Sending vote request to claude..."
    local claude_vote_msg
    claude_vote_msg="$(generate_merge_vote_message "claude" "codex" "$feature" "$peer_sync" "$claude_pr" "$codex_pr")"
    tmux send-keys -t "$claude_session" "$claude_vote_msg"
    sleep 0.5
    tmux send-keys -t "$claude_session" C-m

    atomic_write "$peer_sync/codex.status" "voting|$(date +%s)|merge vote phase"
    info "Sending vote request to codex..."
    local codex_vote_msg
    codex_vote_msg="$(generate_merge_vote_message "codex" "claude" "$feature" "$peer_sync" "$claude_pr" "$codex_pr")"
    tmux send-keys -t "$codex_session" "$codex_vote_msg"
    sleep 0.5
    tmux send-keys -t "$codex_session" C-m

    # Wait for both votes
    local vote_start=$SECONDS
    local claude_voted=false codex_voted=false

    while ! ($claude_voted && $codex_voted); do
        local elapsed=$((SECONDS - vote_start))

        local claude_status codex_status
        claude_status="$(get_agent_status "claude" "$peer_sync")"
        codex_status="$(get_agent_status "codex" "$peer_sync")"

        [ "$claude_status" = "vote-done" ] && claude_voted=true
        [ "$codex_status" = "vote-done" ] && codex_voted=true

        if $claude_voted && $codex_voted; then
            break
        fi

        if [ "$elapsed" -ge "$vote_timeout" ]; then
            warn "Vote phase timeout (${vote_timeout}s)"
            break
        fi

        printf "\r  Waiting... claude=%s codex=%s (%ds/%ds)  " "$claude_status" "$codex_status" "$elapsed" "$vote_timeout"
        sleep "$poll_interval"
    done
    echo ""

    # Check if we have votes
    if ! both_voted "$peer_sync"; then
        die "Not all agents submitted votes. Check agent terminals."
    fi

    # === CONSENSUS CHECK ===
    local debate_round=0
    local decision=""

    while [ -z "$decision" ] && [ "$debate_round" -lt "$max_debate_rounds" ]; do
        if votes_agree "$peer_sync"; then
            decision="$(get_agreed_vote "$peer_sync")"
            success "Consensus reached: merge $decision's PR"
            break
        fi

        # Votes disagree - start debate
        debate_round=$((debate_round + 1))
        echo "$debate_round" > "$peer_sync/merge-round"

        info "=== Debate Round $debate_round ==="
        local claude_vote codex_vote
        claude_vote="$(extract_vote "$peer_sync/merge-vote-claude.md")"
        codex_vote="$(extract_vote "$peer_sync/merge-vote-codex.md")"
        echo "  Claude votes: $claude_vote"
        echo "  Codex votes:  $codex_vote"
        echo ""

        # Send debate messages
        atomic_write "$peer_sync/claude.status" "debating|$(date +%s)|debate round $debate_round"
        local claude_debate_msg
        claude_debate_msg="$(generate_merge_debate_message "claude" "codex" "$feature" "$peer_sync" "$debate_round")"
        tmux send-keys -t "$claude_session" "$claude_debate_msg"
        sleep 0.5
        tmux send-keys -t "$claude_session" C-m

        atomic_write "$peer_sync/codex.status" "debating|$(date +%s)|debate round $debate_round"
        local codex_debate_msg
        codex_debate_msg="$(generate_merge_debate_message "codex" "claude" "$feature" "$peer_sync" "$debate_round")"
        tmux send-keys -t "$codex_session" "$codex_debate_msg"
        sleep 0.5
        tmux send-keys -t "$codex_session" C-m

        # Wait for debate responses
        local debate_start=$SECONDS
        local claude_debated=false codex_debated=false

        while ! ($claude_debated && $codex_debated); do
            local elapsed=$((SECONDS - debate_start))

            local claude_status codex_status
            claude_status="$(get_agent_status "claude" "$peer_sync")"
            codex_status="$(get_agent_status "codex" "$peer_sync")"

            [ "$claude_status" = "debate-done" ] && claude_debated=true
            [ "$codex_status" = "debate-done" ] && codex_debated=true

            if $claude_debated && $codex_debated; then
                break
            fi

            if [ "$elapsed" -ge "$debate_timeout" ]; then
                warn "Debate timeout (${debate_timeout}s)"
                break
            fi

            printf "\r  Waiting... claude=%s codex=%s (%ds/%ds)  " "$claude_status" "$codex_status" "$elapsed" "$debate_timeout"
            sleep "$poll_interval"
        done
        echo ""
    done

    # === ESCALATE TO USER IF NO CONSENSUS ===
    if [ -z "$decision" ]; then
        warn "No consensus after $max_debate_rounds debate rounds."
        echo ""
        echo "--- Claude's Final Vote ---"
        cat "$peer_sync/merge-vote-claude.md"
        echo ""
        echo "--- Codex's Final Vote ---"
        cat "$peer_sync/merge-vote-codex.md"
        echo ""
        echo "=================================="
        echo ""
        info "Options:"
        echo "  [c] - Merge Claude's PR"
        echo "  [x] - Merge Codex's PR"
        echo ""
        read -r -p "Your decision: " user_choice

        case "$user_choice" in
            c|C) decision="claude" ;;
            x|X) decision="codex" ;;
            *) die "Invalid choice. Run 'agent-duo merge' again." ;;
        esac
        info "User decided: merge $decision's PR"
    fi

    # Record decision
    echo "$decision" > "$peer_sync/merge-decision"

    # === EXECUTION PHASE ===
    info "=== Merge Execution Phase ==="

    # Determine roles based on decision
    # "Losing" agent does the merge + cherry-pick work
    # "Winning" agent reviews
    local executor reviewer
    if [ "$decision" = "claude" ]; then
        executor="codex"
        reviewer="claude"
    else
        executor="claude"
        reviewer="codex"
    fi

    info "Executor (merge + cherry-pick): $executor"
    info "Reviewer: $reviewer"

    # Trigger merge-execute skill for executor
    local executor_session
    [ "$executor" = "claude" ] && executor_session="$claude_session" || executor_session="$codex_session"

    atomic_write "$peer_sync/${executor}.status" "merging|$(date +%s)|executing merge"
    info "Triggering duo-merge-execute for $executor..."
    trigger_skill "$executor" "$executor_session" "duo-merge-execute"

    # Wait for merge execution
    local merge_timeout="${MERGE_TIMEOUT:-900}"
    local merge_start=$SECONDS
    local merge_done=false

    while ! $merge_done; do
        local elapsed=$((SECONDS - merge_start))
        local executor_status
        executor_status="$(get_agent_status "$executor" "$peer_sync")"

        [ "$executor_status" = "merge-done" ] && merge_done=true

        if $merge_done; then
            break
        fi

        if [ "$elapsed" -ge "$merge_timeout" ]; then
            warn "Merge execution timeout (${merge_timeout}s)"
            break
        fi

        printf "\r  Waiting for merge... %s=%s (%ds/%ds)  " "$executor" "$executor_status" "$elapsed" "$merge_timeout"
        sleep "$poll_interval"
    done
    echo ""

    # === REVIEW/AMEND LOOP ===
    local reviewer_session executor_session
    [ "$reviewer" = "claude" ] && reviewer_session="$claude_session" || reviewer_session="$codex_session"
    [ "$executor" = "claude" ] && executor_session="$claude_session" || executor_session="$codex_session"

    local review_timeout="${MERGE_REVIEW_TIMEOUT:-600}"
    local amend_timeout="${MERGE_AMEND_TIMEOUT:-600}"
    local max_amend_rounds=3
    local amend_round=0
    local merge_approved=false

    while ! $merge_approved && [ "$amend_round" -lt "$max_amend_rounds" ]; do
        # === REVIEW PHASE ===
        info "=== Merge Review Phase ==="

        atomic_write "$peer_sync/${reviewer}.status" "merge-reviewing|$(date +%s)|reviewing merge"
        info "Triggering duo-merge-review for $reviewer..."
        trigger_skill "$reviewer" "$reviewer_session" "duo-merge-review"

        # Wait for review
        local review_start=$SECONDS
        local review_done=false

        while ! $review_done; do
            local elapsed=$((SECONDS - review_start))
            local reviewer_status
            reviewer_status="$(get_agent_status "$reviewer" "$peer_sync")"

            [ "$reviewer_status" = "merge-review-done" ] && review_done=true

            if $review_done; then
                break
            fi

            if [ "$elapsed" -ge "$review_timeout" ]; then
                warn "Merge review timeout (${review_timeout}s)"
                break
            fi

            printf "\r  Waiting for review... %s=%s (%ds/%ds)  " "$reviewer" "$reviewer_status" "$elapsed" "$review_timeout"
            sleep "$poll_interval"
        done
        echo ""

        # Check review result
        if [ -f "$peer_sync/merge-review-${reviewer}.md" ]; then
            if grep -qi "CHANGES REQUESTED" "$peer_sync/merge-review-${reviewer}.md"; then
                amend_round=$((amend_round + 1))
                warn "Review requested changes (round $amend_round/$max_amend_rounds)"

                if [ "$amend_round" -ge "$max_amend_rounds" ]; then
                    warn "Max amend rounds reached. Manual intervention needed."
                    break
                fi

                # === AMEND PHASE ===
                info "=== Merge Amend Phase (round $amend_round) ==="

                atomic_write "$peer_sync/${executor}.status" "merging|$(date +%s)|addressing review feedback"
                info "Triggering duo-merge-amend for $executor..."
                trigger_skill "$executor" "$executor_session" "duo-merge-amend"

                # Wait for amend
                local amend_start=$SECONDS
                local amend_done=false

                while ! $amend_done; do
                    local elapsed=$((SECONDS - amend_start))
                    local executor_status
                    executor_status="$(get_agent_status "$executor" "$peer_sync")"

                    [ "$executor_status" = "merge-done" ] && amend_done=true

                    if $amend_done; then
                        break
                    fi

                    if [ "$elapsed" -ge "$amend_timeout" ]; then
                        warn "Merge amend timeout (${amend_timeout}s)"
                        break
                    fi

                    printf "\r  Waiting for amend... %s=%s (%ds/%ds)  " "$executor" "$executor_status" "$elapsed" "$amend_timeout"
                    sleep "$poll_interval"
                done
                echo ""

                # Clear the old review for next round
                rm -f "$peer_sync/merge-review-${reviewer}.md"
            else
                merge_approved=true
                success "Merge approved!"
            fi
        else
            # No review file - assume approved
            merge_approved=true
            success "Merge complete (no review file found)"
        fi
    done

    echo ""
    info "=== Merge Phase Complete ==="
    echo "Decision: $decision's PR was merged"
    if [ -f "$peer_sync/merge-review-${reviewer}.md" ]; then
        echo "See merge review: $peer_sync/merge-review-${reviewer}.md"
    fi
}

#------------------------------------------------------------------------------
# Command: signal (for agents)
#------------------------------------------------------------------------------

cmd_signal() {
    local agent="$1"
    local status="$2"
    local message="${3:-}"

    [ -z "$agent" ] || [ -z "$status" ] && die "Usage: agent-duo signal <agent> <status> [message]"

    local root
    root="$(get_project_root)"
    local peer_sync="$root/.peer-sync"

    # Validate status
    case "$status" in
        clarifying|clarify-done|pushing-back|pushback-done|working|done|reviewing|review-done|interrupted|error|pr-created|escalated|voting|vote-done|debating|debate-done|merging|merge-done|merge-reviewing|merge-review-done) ;;
        *) die "Invalid status: $status (valid: clarifying, clarify-done, pushing-back, pushback-done, working, done, reviewing, review-done, interrupted, error, pr-created, escalated, voting, vote-done, debating, debate-done, merging, merge-done, merge-reviewing, merge-review-done)" ;;
    esac

    local content="${status}|$(date +%s)|${message}"
    atomic_write "$peer_sync/${agent}.status" "$content"

    success "$agent status: $status"
}

#------------------------------------------------------------------------------
# Command: peer-status (for agents)
#------------------------------------------------------------------------------

cmd_peer_status() {
    local peer="${PEER_NAME:-}"
    [ -z "$peer" ] && die "PEER_NAME not set. Are you in an agent session?"

    local root
    root="$(get_project_root)"
    local peer_sync="$root/.peer-sync"
    local status_file="$peer_sync/${peer}.status"

    if [ -f "$status_file" ]; then
        cat "$status_file"
    else
        echo "unknown"
    fi
}

#------------------------------------------------------------------------------
# Command: phase (for agents)
#------------------------------------------------------------------------------

cmd_phase() {
    local root
    root="$(get_project_root)"
    local peer_sync="$root/.peer-sync"

    if [ -f "$peer_sync/phase" ]; then
        cat "$peer_sync/phase"
    else
        echo "unknown"
    fi
}

#------------------------------------------------------------------------------
# Command: confirm (user confirms clarify phase completion)
#------------------------------------------------------------------------------

cmd_confirm() {
    local root
    root="$(get_project_root)"
    local peer_sync="$root/.peer-sync"

    # Check we're in clarify phase
    local phase
    phase="$(cat "$peer_sync/phase" 2>/dev/null)" || die "No active session"

    if [ "$phase" != "clarify" ]; then
        if [ -f "$peer_sync/clarify-confirmed" ]; then
            info "Clarify phase already confirmed."
        else
            die "Not in clarify phase (current phase: $phase)"
        fi
        return 0
    fi

    # Mark clarify as confirmed
    echo "confirmed" > "$peer_sync/clarify-confirmed"

    # Transition to work phase
    echo "work" > "$peer_sync/phase"

    success "Clarify phase confirmed! Transitioning to work phase."
    echo "Note: If orchestrator is waiting for input, press Enter there to continue."
}

#------------------------------------------------------------------------------
# Command: escalate (for agents to flag issues needing user input)
#------------------------------------------------------------------------------

cmd_escalate() {
    local reason="$1"
    local message="${2:-}"

    [ -z "$reason" ] && die "Usage: agent-duo escalate <reason> [message]
Reasons:
  ambiguity     - Requirements are unclear, need clarification
  inconsistency - Conflicting requirements or code/docs mismatch
  misguided     - Evidence the task approach is wrong"

    # Validate reason
    case "$reason" in
        ambiguity|inconsistency|misguided) ;;
        *) die "Invalid reason: $reason (valid: ambiguity, inconsistency, misguided)" ;;
    esac

    local agent="${AGENT_NAME:-}"
    [ -z "$agent" ] && die "AGENT_NAME not set. Are you in an agent session?"

    local root
    root="$(get_project_root)"
    local peer_sync="$root/.peer-sync"

    # Write escalation file with details
    local escalation_file="$peer_sync/escalation-${agent}.md"
    {
        echo "# Escalation from $agent"
        echo ""
        echo "**Reason:** $reason"
        echo "**Time:** $(date)"
        echo ""
        if [ -n "$message" ]; then
            echo "## Details"
            echo ""
            echo "$message"
        fi
    } > "$escalation_file"

    # Update agent status to escalated
    local content="escalated|$(date +%s)|$reason: ${message:-no details}"
    atomic_write "$peer_sync/${agent}.status" "$content"

    success "Escalation filed: $reason"
    info "The orchestrator will pause before advancing phases."
    info "Continue your current work - you won't be interrupted."
}

#------------------------------------------------------------------------------
# Command: escalate-resolve (user resolves an escalation)
#------------------------------------------------------------------------------

cmd_escalate_resolve() {
    local root
    root="$(get_project_root)"
    local peer_sync="$root/.peer-sync"

    # Find pending escalations
    local escalations=()
    for f in "$peer_sync"/escalation-*.md; do
        [ -f "$f" ] && escalations+=("$f")
    done

    if [ ${#escalations[@]} -eq 0 ]; then
        info "No pending escalations."
        return 0
    fi

    # Display all escalations
    echo ""
    info "=== Pending Escalations ==="
    echo ""
    for f in "${escalations[@]}"; do
        cat "$f"
        echo ""
        echo "---"
        echo ""
    done

    # Prompt for resolution
    echo "Options:"
    echo "  1. Resolve all escalations (agents will continue normally)"
    echo "  2. Cancel (keep escalations pending)"
    echo ""
    read -r -p "Choice [1/2]: " choice

    case "$choice" in
        1)
            # Remove escalation files
            for f in "${escalations[@]}"; do
                rm -f "$f"
            done

            # Mark escalations as resolved
            echo "resolved|$(date +%s)" > "$peer_sync/escalation-resolved"

            success "Escalations resolved. Orchestrator will continue."
            echo "Note: If orchestrator is waiting, press Enter there to continue."
            ;;
        2|*)
            info "Escalations remain pending."
            ;;
    esac
}

# Note: send_clarify_notification is provided by agent-lib.sh
# It tries ntfy first (if configured), then email

#------------------------------------------------------------------------------
# Generate clarify phase message for agents
#------------------------------------------------------------------------------

generate_clarify_message() {
    local agent="$1"
    local peer="$2"
    local feature="$3"
    local task_content="$4"
    local peer_worktree="$5"
    local peer_sync="$6"

    cat <<EOF
# Task: $feature

$task_content

---
## Agent-Duo Context - CLARIFY PHASE

You are **$agent** in a duo workflow with **$peer** as your peer.

**PHASE: CLARIFY** - Before starting implementation, propose your high-level approach and ask clarifying questions.

### Your Environment

- **Your worktree**: Current directory
- **Peer's worktree**: $peer_worktree (read-only)
- **Sync directory**: $peer_sync

### Your Task

Produce TWO outputs:

1. **High-level approach** - Not a detailed plan, but a sketch: the key idea, first steps to explore, or general direction
2. **Clarifying questions** - Questions for the user that would help you start more effectively

### Write Your Approach and Questions

\`\`\`bash
cat > "$peer_sync/clarify-${agent}.md" << 'CLARIFY_EOF'
# Clarification from $agent

## Proposed Approach

[Write 3-5 sentences describing your high-level approach.]

## Questions for the User

1. [Question 1]
2. [Question 2]
3. [Question 3 - optional]

CLARIFY_EOF
\`\`\`

Edit the file with actual content, then signal completion:

\`\`\`bash
agent-duo signal "$agent" clarify-done "approach and questions submitted"
\`\`\`

Then **STOP and wait**. The user will review your approach and respond in this terminal.
Do NOT start implementing until the work phase begins.
EOF
}

#------------------------------------------------------------------------------
# Generate pushback stage message for agents
#------------------------------------------------------------------------------

generate_pushback_message() {
    local agent="$1"
    local peer="$2"
    local feature="$3"
    local task_content="$4"
    local peer_worktree="$5"
    local peer_sync="$6"

    cat <<EOF
# Task: $feature

$task_content

---
## Agent-Duo Context - PUSHBACK STAGE

You are **$agent** in a duo workflow with **$peer** as your peer.

**STAGE: PUSHBACK** - Before starting implementation, you may propose improvements to the task specification.

### Your Environment

- **Your worktree**: Current directory
- **Peer's worktree**: $peer_worktree (read-only)
- **Sync directory**: $peer_sync

### Purpose

The task file may specify both a goal and a plan. Sometimes the plan is suboptimal or could be improved. This is your opportunity to suggest modifications that would lead to a better solution.

### Your Task

Consider:
1. Is the stated plan the best approach to achieve the core goal?
2. Are there better alternatives or optimizations?
3. Are there missing requirements or edge cases?

### Modify the Task File Directly

If you believe the task could be improved, edit \`$feature.md\` directly in your worktree. The user will compare versions using diff3.

If the task is well-specified and needs no changes, skip to writing your rationale.

### Write Your Rationale

\`\`\`bash
cat > "$peer_sync/pushback-${agent}.md" << 'PUSHBACK_EOF'
# Pushback from $agent

## Summary of Proposed Changes

[1-3 sentences explaining what you changed and why, or "No changes proposed - the task is well-specified."]

## Reasoning

[Explain why your changes would improve the solution quality, or why the original is already good]

PUSHBACK_EOF
\`\`\`

Edit the file with actual content, then signal completion:

\`\`\`bash
agent-duo signal "$agent" pushback-done "proposed task modifications submitted"
\`\`\`

Then **STOP and wait**. The user will review task file changes (via diff3) and rationales, then decide whether to accept, reject, or modify.
Do NOT start implementing until the work phase begins.
EOF
}

#------------------------------------------------------------------------------
# Command: run (orchestrator)
#------------------------------------------------------------------------------

# Note: get_agent_status, has_pr, interrupt_agent, nudge_agent, and
# trigger_skill are all provided by agent-lib.sh

# Generate augmented first-round message with full context
# This replaces the need for /duo-work skill in round 1
generate_round1_message() {
    local agent="$1"
    local peer="$2"
    local feature="$3"
    local task_content="$4"
    local peer_worktree="$5"
    local peer_sync="$6"

    cat <<EOF
# Task: $feature

$task_content

---
## Agent-Duo Context

You are **$agent** in a duo workflow with **$peer** as your peer.
Both of you are developing **alternative solutions** in parallel.

- **Phase**: Work (Round 1)
- **Your worktree**: Current directory (read/write)
- **Peer's worktree**: $peer_worktree (read-only - look but don't touch)
- **Sync directory**: $peer_sync

### Your Goal

Implement your solution independently. Your peer works in parallel on the same task.

### Guidelines

1. **Diverge to explore the search space**: Produce an *alternative* solution, not a copy
2. **Different tradeoffs are good**: If peer chose approach A, consider approach B
3. **Read peer's code for insight, not imitation**
4. **Focus on your implementation**: Make progress on your own solution, convergence is fine if it arises organically from a confident consensus

### Checking Peer's Progress (Optional)

\`\`\`bash
agent-duo peer-status
git -C "$peer_worktree" diff
\`\`\`

### If You Discover a Blocking Issue

If you find ambiguity, inconsistency, or evidence the task is misguided — escalate:
\`\`\`bash
agent-duo escalate ambiguity "requirements unclear: what should happen when X?"
agent-duo escalate inconsistency "docs say X but code does Y"
agent-duo escalate misguided "this feature already exists in module Z"
\`\`\`
This notifies the user without interrupting your work. Continue with your best interpretation.

### When Done

Signal completion and **STOP**:
\`\`\`bash
agent-duo signal "$agent" done "brief summary of what you did"
\`\`\`

The orchestrator will then trigger the review phase.

### When Ready to Submit Final PR

When your solution is complete and tested, create your PR:
\`\`\`bash
agent-duo pr "$agent"   # recommended: handles commit, push, and orchestrator sync
# or: gh pr create ...  # also works, orchestrator will detect it
\`\`\`
EOF
}

cmd_run() {
    local work_timeout=$DEFAULT_WORK_TIMEOUT
    local review_timeout=$DEFAULT_REVIEW_TIMEOUT
    local clarify_timeout=$DEFAULT_CLARIFY_TIMEOUT
    local pushback_timeout=$DEFAULT_PUSHBACK_TIMEOUT
    local poll_interval=$DEFAULT_POLL_INTERVAL
    local max_rounds=10
    local auto_start=false
    local enable_clarify=""  # empty means use session default
    local enable_pushback="" # empty means use session default
    local tui_exit_behavior=$DEFAULT_TUI_EXIT_BEHAVIOR

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --work-timeout) work_timeout="$2"; shift 2 ;;
            --review-timeout) review_timeout="$2"; shift 2 ;;
            --clarify-timeout) clarify_timeout="$2"; shift 2 ;;
            --pushback-timeout) pushback_timeout="$2"; shift 2 ;;
            --clarify) enable_clarify="true"; shift ;;
            --pushback) enable_pushback="true"; shift ;;
            --poll) poll_interval="$2"; shift 2 ;;
            --max-rounds) max_rounds="$2"; shift 2 ;;
            --auto-start) auto_start=true; shift ;;
            --on-tui-exit) tui_exit_behavior="$2"; shift 2 ;;
            -*) die "Unknown option: $1" ;;
            *) die "Unknown argument: $1" ;;
        esac
    done

    local root
    root="$(get_project_root)"
    local peer_sync="$root/.peer-sync"
    local feature
    feature="$(get_feature)"

    # Determine tmux session name
    local session_name="duo-${feature}"

    # Check tmux session exists
    if ! tmux has-session -t "$session_name" 2>/dev/null; then
        # Try ttyd-style separate sessions
        if tmux has-session -t "${session_name}-claude" 2>/dev/null; then
            local claude_session="${session_name}-claude"
            local codex_session="${session_name}-codex"
        else
            die "No tmux session found. Run 'agent-duo restart' to resume, or 'agent-duo start $feature' to start fresh."
        fi
    else
        local claude_session="${session_name}:claude"
        local codex_session="${session_name}:codex"
    fi

    echo ""
    echo "=== Agent Duo Orchestrator ==="
    echo "Feature:        $feature"
    echo "Work timeout:   ${work_timeout}s"
    echo "Review timeout: ${review_timeout}s"
    echo "Max rounds:     $max_rounds"
    echo ""

    # Calculate worktree paths for augmented messages
    local project_name
    project_name="$(basename "$root")"
    local parent_dir
    parent_dir="$(dirname "$root")"
    local worktree_claude="$parent_dir/${project_name}-${feature}-claude"
    local worktree_codex="$parent_dir/${project_name}-${feature}-codex"

    # Load codex thinking effort from session
    local codex_thinking
    codex_thinking="$(cat "$peer_sync/codex-thinking" 2>/dev/null)" || codex_thinking="$DEFAULT_CODEX_THINKING"

    # Optionally auto-start agents
    if $auto_start; then
        info "Starting agents..."
        tmux send-keys -t "$claude_session" "$(get_agent_cmd claude)"
        tmux send-keys -t "$claude_session" C-m
        tmux send-keys -t "$codex_session" "$(get_agent_cmd codex "$codex_thinking")"
        tmux send-keys -t "$codex_session" C-m
        sleep 3
        # Task will be sent as augmented round 1 message or clarify message below
    fi

    # Check if clarify mode is enabled (command line overrides session setting)
    local clarify_mode
    if [ -n "$enable_clarify" ]; then
        clarify_mode="$enable_clarify"
        echo "$enable_clarify" > "$peer_sync/clarify-mode"
    else
        clarify_mode="$(cat "$peer_sync/clarify-mode" 2>/dev/null)" || clarify_mode="false"
    fi

    # Handle clarify phase if enabled and not already confirmed
    if [ "$clarify_mode" = "true" ] && [ ! -f "$peer_sync/clarify-confirmed" ]; then
        info "=== Clarify Phase ==="
        echo "clarify" > "$peer_sync/phase"

        # Read task content
        local task_file
        local task_content=""
        if task_file="$(find_task_file "$root" "$feature")"; then
            task_content="$(cat "$task_file" | head -c 4000)"
        fi

        # Send clarify message to both agents
        atomic_write "$peer_sync/claude.status" "clarifying|$(date +%s)|clarify phase"
        info "Sending clarify task to claude..."
        local claude_clarify_msg
        claude_clarify_msg="$(generate_clarify_message "claude" "codex" "$feature" "$task_content" "$worktree_codex" "$peer_sync")"
        tmux send-keys -t "$claude_session" "$claude_clarify_msg"
        sleep 0.5
        tmux send-keys -t "$claude_session" C-m

        atomic_write "$peer_sync/codex.status" "clarifying|$(date +%s)|clarify phase"
        info "Sending clarify task to codex..."
        local codex_clarify_msg
        codex_clarify_msg="$(generate_clarify_message "codex" "claude" "$feature" "$task_content" "$worktree_claude" "$peer_sync")"
        tmux send-keys -t "$codex_session" "$codex_clarify_msg"
        sleep 0.5
        tmux send-keys -t "$codex_session" C-m

        # Wait for both agents to complete clarify phase
        local clarify_start=$SECONDS
        local claude_clarify_done=false
        local codex_clarify_done=false

        while ! ($claude_clarify_done && $codex_clarify_done); do
            local elapsed=$((SECONDS - clarify_start))

            # Check for completion
            local claude_status
            claude_status="$(get_agent_status "claude" "$peer_sync")"
            local codex_status
            codex_status="$(get_agent_status "codex" "$peer_sync")"

            [ "$claude_status" = "clarify-done" ] && claude_clarify_done=true
            [ "$codex_status" = "clarify-done" ] && codex_clarify_done=true

            if $claude_clarify_done && $codex_clarify_done; then
                break
            fi

            # Check if agent TUIs have exited unexpectedly
            if ! $claude_clarify_done; then
                check_tui_health "claude" "$claude_session" "$peer_sync" "$tui_exit_behavior"
            fi
            if ! $codex_clarify_done; then
                check_tui_health "codex" "$codex_session" "$peer_sync" "$tui_exit_behavior"
            fi

            # Check timeout
            if [ "$elapsed" -ge "$clarify_timeout" ]; then
                warn "Clarify phase timeout (${clarify_timeout}s)"
                # Don't interrupt - just proceed with whatever was submitted
                break
            fi

            printf "\r  Waiting... claude=%s codex=%s (%ds/%ds)  " "$claude_status" "$codex_status" "$elapsed" "$clarify_timeout"
            sleep "$poll_interval"
        done
        echo ""

        # Send notification with clarify results (ntfy and/or email)
        send_clarify_notification "$peer_sync" "$feature" "duo"

        # Display clarify results
        echo ""
        info "=== Clarify Phase Results ==="
        echo ""

        if [ -f "$peer_sync/clarify-claude.md" ]; then
            echo "--- Claude's Approach ---"
            cat "$peer_sync/clarify-claude.md"
            echo ""
        else
            warn "Claude did not submit a clarification"
        fi

        if [ -f "$peer_sync/clarify-codex.md" ]; then
            echo "--- Codex's Approach ---"
            cat "$peer_sync/clarify-codex.md"
            echo ""
        else
            warn "Codex did not submit a clarification"
        fi

        echo ""
        echo "=================================="
        echo ""
        info "Respond to agents in their terminals if needed."
        echo ""
        read -r -p "Press Enter when ready to proceed... "

        # Mark clarify as confirmed
        echo "confirmed" > "$peer_sync/clarify-confirmed"

        success "Clarify stage confirmed!"
        echo ""
    fi

    # Check if pushback mode is enabled (command line overrides session setting)
    local pushback_mode
    if [ -n "$enable_pushback" ]; then
        pushback_mode="$enable_pushback"
        echo "$enable_pushback" > "$peer_sync/pushback-mode"
    else
        pushback_mode="$(cat "$peer_sync/pushback-mode" 2>/dev/null)" || pushback_mode="false"
    fi

    # Handle pushback stage if enabled and not already confirmed
    if [ "$pushback_mode" = "true" ] && [ ! -f "$peer_sync/pushback-confirmed" ]; then
        info "=== Pushback Stage ==="
        echo "pushback" > "$peer_sync/phase"

        # Find task file
        local task_file
        local task_content=""
        if task_file="$(find_task_file "$root" "$feature")"; then
            task_content="$(cat "$task_file" | head -c 4000)"
        fi
        local task_basename="${feature}.md"

        # Send pushback message to both agents
        atomic_write "$peer_sync/claude.status" "pushing-back|$(date +%s)|pushback stage"
        info "Sending pushback task to claude..."
        local claude_pushback_msg
        claude_pushback_msg="$(generate_pushback_message "claude" "codex" "$feature" "$task_content" "$worktree_codex" "$peer_sync")"
        tmux send-keys -t "$claude_session" "$claude_pushback_msg"
        sleep 0.5
        tmux send-keys -t "$claude_session" C-m

        atomic_write "$peer_sync/codex.status" "pushing-back|$(date +%s)|pushback stage"
        info "Sending pushback task to codex..."
        local codex_pushback_msg
        codex_pushback_msg="$(generate_pushback_message "codex" "claude" "$feature" "$task_content" "$worktree_claude" "$peer_sync")"
        tmux send-keys -t "$codex_session" "$codex_pushback_msg"
        sleep 0.5
        tmux send-keys -t "$codex_session" C-m

        # Wait for both agents to complete pushback stage
        local pushback_start=$SECONDS
        local claude_pushback_done=false
        local codex_pushback_done=false

        while ! ($claude_pushback_done && $codex_pushback_done); do
            local elapsed=$((SECONDS - pushback_start))

            # Check for completion
            local claude_status
            claude_status="$(get_agent_status "claude" "$peer_sync")"
            local codex_status
            codex_status="$(get_agent_status "codex" "$peer_sync")"

            [ "$claude_status" = "pushback-done" ] && claude_pushback_done=true
            [ "$codex_status" = "pushback-done" ] && codex_pushback_done=true

            if $claude_pushback_done && $codex_pushback_done; then
                break
            fi

            # Check if agent TUIs have exited unexpectedly
            if ! $claude_pushback_done; then
                check_tui_health "claude" "$claude_session" "$peer_sync" "$tui_exit_behavior"
            fi
            if ! $codex_pushback_done; then
                check_tui_health "codex" "$codex_session" "$peer_sync" "$tui_exit_behavior"
            fi

            # Check timeout
            if [ "$elapsed" -ge "$pushback_timeout" ]; then
                warn "Pushback stage timeout (${pushback_timeout}s)"
                break
            fi

            printf "\r  Waiting... claude=%s codex=%s (%ds/%ds)  " "$claude_status" "$codex_status" "$elapsed" "$pushback_timeout"
            sleep "$poll_interval"
        done
        echo ""

        # Send notification with pushback results
        send_pushback_notification "$peer_sync" "$feature" "duo"

        # Display pushback results
        echo ""
        info "=== Pushback Stage Results ==="
        echo ""

        if [ -f "$peer_sync/pushback-claude.md" ]; then
            echo "--- Claude's Pushback ---"
            cat "$peer_sync/pushback-claude.md"
            echo ""
        else
            warn "Claude did not submit a pushback"
        fi

        if [ -f "$peer_sync/pushback-codex.md" ]; then
            echo "--- Codex's Pushback ---"
            cat "$peer_sync/pushback-codex.md"
            echo ""
        else
            warn "Codex did not submit a pushback"
        fi

        echo ""
        echo "=================================="
        echo ""
        info "Options:"
        echo "  [Enter] - Reject pushbacks, proceed with original task"
        echo "  [c]     - Accept Claude's pushback"
        echo "  [x]     - Accept Codex's pushback"
        echo ""
        read -r -p "Your choice: " pushback_choice

        case "$pushback_choice" in
            c|C)
                # Accept Claude's: copy Claude's task file to Codex's worktree
                info "Accepting Claude's pushback..."
                if [ -f "$worktree_claude/$task_basename" ]; then
                    cp "$worktree_claude/$task_basename" "$worktree_codex/$task_basename"
                    success "Copied Claude's task file to Codex worktree"
                fi
                echo "claude" > "$peer_sync/pushback-accepted"
                ;;
            x|X)
                # Accept Codex's: copy Codex's task file to Claude's worktree
                info "Accepting Codex's pushback..."
                if [ -f "$worktree_codex/$task_basename" ]; then
                    cp "$worktree_codex/$task_basename" "$worktree_claude/$task_basename"
                    success "Copied Codex's task file to Claude worktree"
                fi
                echo "codex" > "$peer_sync/pushback-accepted"
                ;;
            *)
                # Reject: restore original task file from project root to both worktrees
                info "Rejecting pushbacks, restoring original task..."
                if [ -f "$root/$task_basename" ]; then
                    cp "$root/$task_basename" "$worktree_claude/$task_basename"
                    cp "$root/$task_basename" "$worktree_codex/$task_basename"
                    success "Restored original task file to both worktrees"
                else
                    warn "Original task file not found in project root"
                fi
                echo "rejected" > "$peer_sync/pushback-accepted"
                ;;
        esac

        # Mark pushback as confirmed
        echo "confirmed" > "$peer_sync/pushback-confirmed"
        echo "work" > "$peer_sync/phase"

        success "Pushback stage complete! Proceeding to work phase..."
        echo ""
    fi

    # Check if both PRs already exist - skip directly to PR comment watch phase
    if has_pr "claude" "$peer_sync" && has_pr "codex" "$peer_sync"; then
        success "Both PRs already created - skipping to PR comment watch phase"
        echo ""
        echo "Claude PR: $(cat "$peer_sync/claude.pr")"
        echo "Codex PR:  $(cat "$peer_sync/codex.pr")"
        # Jump directly to PR comment watch phase (after the main loop)
    else
        # Set phase to work if not already set
        if [ "$(cat "$peer_sync/phase" 2>/dev/null)" != "work" ]; then
            echo "work" > "$peer_sync/phase"
        fi

        # Resume from saved round or start at 1
        local round
        round="$(cat "$peer_sync/round" 2>/dev/null)" || round=1

        while [ "$round" -le "$max_rounds" ]; do
            # Check if session is complete
            if [ "$(cat "$peer_sync/session" 2>/dev/null)" = "complete" ]; then
                success "Session complete!"
                break
            fi

            # Check if both have PRs AND at least one review cycle completed (round >= 2)
            # This ensures both agents see at least one review before session ends
            if has_pr "claude" "$peer_sync" && has_pr "codex" "$peer_sync" && [ "$round" -ge 2 ]; then
                echo "complete" > "$peer_sync/session"
                success "Both PRs created - session complete!"
                echo ""
                echo "Claude PR: $(cat "$peer_sync/claude.pr")"
                echo "Codex PR:  $(cat "$peer_sync/codex.pr")"
                break
            fi

            echo ""
            info "=== Round $round: Work Phase ==="
            echo "$round" > "$peer_sync/round"
            echo "work" > "$peer_sync/phase"

            # Trigger work phase for agents that don't have PRs
            # Round 1: Send augmented message with full context (avoids skill race condition)
            # Round 2+: Trigger duo-work skill (agent already has context)
            if [ "$round" -eq 1 ]; then
                # Round 1: Send augmented task with full context
                local task_file
                local task_content=""
                if task_file="$(find_task_file "$root" "$feature")"; then
                    task_content="$(cat "$task_file" | head -c 4000)"
                fi

                if ! has_pr "claude" "$peer_sync"; then
                    atomic_write "$peer_sync/claude.status" "working|$(date +%s)|round $round work phase"
                    info "Sending augmented task to claude..."
                    local claude_msg
                    claude_msg="$(generate_round1_message "claude" "codex" "$feature" "$task_content" "$worktree_codex" "$peer_sync")"
                    tmux send-keys -t "$claude_session" "$claude_msg"
                    sleep 0.5
                    tmux send-keys -t "$claude_session" C-m
                fi
                if ! has_pr "codex" "$peer_sync"; then
                    atomic_write "$peer_sync/codex.status" "working|$(date +%s)|round $round work phase"
                    info "Sending augmented task to codex..."
                    local codex_msg
                    codex_msg="$(generate_round1_message "codex" "claude" "$feature" "$task_content" "$worktree_claude" "$peer_sync")"
                    tmux send-keys -t "$codex_session" "$codex_msg"
                    sleep 0.5
                    tmux send-keys -t "$codex_session" C-m
                fi
            else
                # Round 2+: Trigger skill (agent already knows the context)
                # Reset status to working before triggering (in case agent doesn't signal)
                # Check TUI health before triggering to avoid sending to dead session
                # Agents with PRs get duo-amend; others get duo-work
                check_tui_health "claude" "$claude_session" "$peer_sync" "$tui_exit_behavior"
                atomic_write "$peer_sync/claude.status" "working|$(date +%s)|round $round work phase"
                if has_pr "claude" "$peer_sync"; then
                    info "Triggering duo-amend for claude (has PR)..."
                    trigger_skill "claude" "$claude_session" "duo-amend"
                else
                    info "Triggering duo-work for claude..."
                    trigger_skill "claude" "$claude_session" "duo-work"
                fi

                check_tui_health "codex" "$codex_session" "$peer_sync" "$tui_exit_behavior"
                atomic_write "$peer_sync/codex.status" "working|$(date +%s)|round $round work phase"
                if has_pr "codex" "$peer_sync"; then
                    info "Triggering duo-amend for codex (has PR)..."
                    trigger_skill "codex" "$codex_session" "duo-amend"
                else
                    info "Triggering duo-work for codex..."
                    trigger_skill "codex" "$codex_session" "duo-work"
                fi
            fi

            # Wait for work phase completion with timeout
            # Note: Agents with PRs still participate to respond to peer reviews
            local work_start=$SECONDS
            local claude_done=false
            local codex_done=false

            while ! ($claude_done && $codex_done); do
                local elapsed=$((SECONDS - work_start))

                # Check for completion
                local claude_status
                claude_status="$(get_agent_status "claude" "$peer_sync")"
                local codex_status
                codex_status="$(get_agent_status "codex" "$peer_sync")"

                # Accept done, review-done (agent jumped ahead), or pr-created
                [[ "$claude_status" =~ ^(done|review-done|pr-created)$ ]] && claude_done=true
                [[ "$codex_status" =~ ^(done|review-done|pr-created)$ ]] && codex_done=true

                # Check for PRs created mid-phase
                has_pr "claude" "$peer_sync" && claude_done=true
                has_pr "codex" "$peer_sync" && codex_done=true

                if $claude_done && $codex_done; then
                    break
                fi

                # Check if agent TUIs have exited unexpectedly
                if ! $claude_done; then
                    check_tui_health "claude" "$claude_session" "$peer_sync" "$tui_exit_behavior"
                fi
                if ! $codex_done; then
                    check_tui_health "codex" "$codex_session" "$peer_sync" "$tui_exit_behavior"
                fi

                # Check timeout
                if [ "$elapsed" -ge "$work_timeout" ]; then
                    warn "Work phase timeout (${work_timeout}s)"

                    # Interrupt agents that aren't done
                    if ! $claude_done; then
                        interrupt_agent "claude" "$claude_session" "$peer_sync"
                        claude_done=true
                    fi
                    if ! $codex_done; then
                        interrupt_agent "codex" "$codex_session" "$peer_sync"
                        codex_done=true
                    fi
                    break
                fi

                printf "\r  Waiting... claude=%s codex=%s (%ds/%ds)  " "$claude_status" "$codex_status" "$elapsed" "$work_timeout"
                sleep "$poll_interval"
            done
            echo ""

            # Check again if both have PRs (might have been created during work)
            # Require round >= 2 to ensure at least one review cycle
            if has_pr "claude" "$peer_sync" && has_pr "codex" "$peer_sync" && [ "$round" -ge 2 ]; then
                echo "complete" > "$peer_sync/session"
                success "Both PRs created - session complete!"
                break
            fi

            # Check for escalations before transitioning to review phase
            # If user chooses to defer, escalations remain but we continue to review phase
            # They'll be checked again at the next phase boundary
            if has_pending_escalations "$peer_sync" >/dev/null; then
                handle_escalation_block "$peer_sync" "$feature" "duo" || true
            fi

            # Review phase
            info "=== Round $round: Review Phase ==="
            echo "review" > "$peer_sync/phase"

            # Trigger review phase for all agents (including those with PRs)
            # Agents with PRs still review peer's work and can see peer's review of their PR
            # Reset status to reviewing before triggering (in case agent doesn't signal)
            # Check TUI health before triggering to avoid sending to dead session
            check_tui_health "claude" "$claude_session" "$peer_sync" "$tui_exit_behavior"
            atomic_write "$peer_sync/claude.status" "reviewing|$(date +%s)|round $round review phase"
            info "Triggering duo-review for claude..."
            trigger_skill "claude" "$claude_session" "duo-review"

            check_tui_health "codex" "$codex_session" "$peer_sync" "$tui_exit_behavior"
            atomic_write "$peer_sync/codex.status" "reviewing|$(date +%s)|round $round review phase"
            info "Triggering duo-review for codex..."
            trigger_skill "codex" "$codex_session" "duo-review"

            # Wait for review phase completion with timeout
            # Note: Agents with PRs still participate in reviews
            local review_start=$SECONDS
            claude_done=false
            codex_done=false

            while ! ($claude_done && $codex_done); do
                local elapsed=$((SECONDS - review_start))

                local claude_status
                claude_status="$(get_agent_status "claude" "$peer_sync")"
                local codex_status
                codex_status="$(get_agent_status "codex" "$peer_sync")"

                # Accept review-done, done (agent skipped review), or pr-created
                [[ "$claude_status" =~ ^(done|review-done|pr-created)$ ]] && claude_done=true
                [[ "$codex_status" =~ ^(done|review-done|pr-created)$ ]] && codex_done=true

                has_pr "claude" "$peer_sync" && claude_done=true
                has_pr "codex" "$peer_sync" && codex_done=true

                if $claude_done && $codex_done; then
                    break
                fi

                # Check if agent TUIs have exited unexpectedly
                if ! $claude_done; then
                    check_tui_health "claude" "$claude_session" "$peer_sync" "$tui_exit_behavior"
                fi
                if ! $codex_done; then
                    check_tui_health "codex" "$codex_session" "$peer_sync" "$tui_exit_behavior"
                fi

                # Check timeout
                if [ "$elapsed" -ge "$review_timeout" ]; then
                    warn "Review phase timeout (${review_timeout}s)"

                    if ! $claude_done; then
                        interrupt_agent "claude" "$claude_session" "$peer_sync"
                        claude_done=true
                    fi
                    if ! $codex_done; then
                        interrupt_agent "codex" "$codex_session" "$peer_sync"
                        codex_done=true
                    fi
                    break
                fi

                printf "\r  Waiting... claude=%s codex=%s (%ds/%ds)  " "$claude_status" "$codex_status" "$elapsed" "$review_timeout"
                sleep "$poll_interval"
            done
            echo ""

            # Check if both have PRs after review phase (before starting next round)
            # Require round >= 2 to ensure at least one review cycle
            if has_pr "claude" "$peer_sync" && has_pr "codex" "$peer_sync" && [ "$round" -ge 2 ]; then
                echo "complete" > "$peer_sync/session"
                success "Both PRs created - session complete!"
                break
            fi

            # Check for escalations before transitioning to next work round
            # If user chooses to defer, escalations remain but we continue to next round
            # They'll be checked again at the next phase boundary
            if has_pending_escalations "$peer_sync" >/dev/null; then
                handle_escalation_block "$peer_sync" "$feature" "duo" || true
            fi

            round=$((round + 1))
        done

        if [ "$round" -gt "$max_rounds" ]; then
            warn "Reached max rounds ($max_rounds)"
        fi
    fi  # end of else block (PRs not already created)

    # PR Comment Watch Phase
    # After both PRs are created, monitor for new comments/reviews
    # This also works for backward compatibility: running on old sessions with PRs
    if has_pr "claude" "$peer_sync" && has_pr "codex" "$peer_sync"; then
        local claude_pr codex_pr
        claude_pr="$(cat "$peer_sync/claude.pr")"
        codex_pr="$(cat "$peer_sync/codex.pr")"

        # Check if both PRs are already closed/merged before entering watch phase
        local claude_open=false codex_open=false
        is_pr_open "$claude_pr" && claude_open=true
        is_pr_open "$codex_pr" && codex_open=true

        if ! $claude_open && ! $codex_open; then
            info "Both PRs are already closed/merged. Skipping PR watch phase."
        else
            echo ""
            info "=== PR Comment Watch Phase ==="
            echo "pr-comments" > "$peer_sync/phase"

            echo "Monitoring PRs for new comments..."
            echo "  Claude: $claude_pr"
            echo "  Codex:  $codex_pr"
            echo ""
            echo "Press Ctrl-C to stop watching."
            echo ""

            # Check if this is first entry to PR comment phase (no hash files yet)
            # If so, assume existing comments/reviews need to be processed
            local claude_first_entry=false
            local codex_first_entry=false
            if [ ! -f "$peer_sync/claude.pr-hash" ]; then
                claude_first_entry=true
                get_pr_comment_hash "$claude_pr" > "$peer_sync/claude.pr-hash" 2>/dev/null || true
            fi
            if [ ! -f "$peer_sync/codex.pr-hash" ]; then
                codex_first_entry=true
                get_pr_comment_hash "$codex_pr" > "$peer_sync/codex.pr-hash" 2>/dev/null || true
            fi

            while true; do
                # Check if both PRs are closed/merged
                claude_open=false codex_open=false
                is_pr_open "$claude_pr" && claude_open=true
                is_pr_open "$codex_pr" && codex_open=true

                if ! $claude_open && ! $codex_open; then
                    success "Both PRs are closed/merged. Session complete!"
                    break
                fi

                # Check for new comments on each open PR
                # On first entry, trigger if PR has any reviews (comment_count|review_count|...)
                local claude_needs_attention=false
                local codex_needs_attention=false

                if $claude_open; then
                    if $claude_first_entry; then
                        # First entry: check if PR has any reviews to process
                        local claude_hash
                        claude_hash="$(cat "$peer_sync/claude.pr-hash" 2>/dev/null)" || claude_hash=""
                        local claude_reviews="${claude_hash#*|}"  # remove comment count
                        claude_reviews="${claude_reviews%%|*}"    # extract review count
                        if [ -n "$claude_reviews" ] && [ "$claude_reviews" != "0" ]; then
                            claude_needs_attention=true
                            info "Claude's PR has $claude_reviews review(s) to process"
                        fi
                        claude_first_entry=false
                    elif pr_has_new_comments "claude" "$peer_sync"; then
                        claude_needs_attention=true
                        info "New comments on Claude's PR!"
                        send_pr_comment_notification "claude" "$feature" "$claude_pr" "duo"
                    fi
                fi

                if $codex_open; then
                    if $codex_first_entry; then
                        # First entry: check if PR has any reviews to process
                        local codex_hash
                        codex_hash="$(cat "$peer_sync/codex.pr-hash" 2>/dev/null)" || codex_hash=""
                        local codex_reviews="${codex_hash#*|}"  # remove comment count
                        codex_reviews="${codex_reviews%%|*}"    # extract review count
                        if [ -n "$codex_reviews" ] && [ "$codex_reviews" != "0" ]; then
                            codex_needs_attention=true
                            info "Codex's PR has $codex_reviews review(s) to process"
                        fi
                        codex_first_entry=false
                    elif pr_has_new_comments "codex" "$peer_sync"; then
                        codex_needs_attention=true
                        info "New comments on Codex's PR!"
                        send_pr_comment_notification "codex" "$feature" "$codex_pr" "duo"
                    fi
                fi

                # Trigger pr-comment skill for agents with new comments
                if $claude_needs_attention; then
                    check_tui_health "claude" "$claude_session" "$peer_sync" "$tui_exit_behavior"
                    atomic_write "$peer_sync/claude.status" "working|$(date +%s)|addressing PR comments"
                    info "Triggering duo-pr-comment for claude..."
                    trigger_skill "claude" "$claude_session" "duo-pr-comment"
                fi

                if $codex_needs_attention; then
                    check_tui_health "codex" "$codex_session" "$peer_sync" "$tui_exit_behavior"
                    atomic_write "$peer_sync/codex.status" "working|$(date +%s)|addressing PR comments"
                    info "Triggering duo-pr-comment for codex..."
                    trigger_skill "codex" "$codex_session" "duo-pr-comment"
                fi

                # Wait for agents to finish if they were triggered
                if $claude_needs_attention || $codex_needs_attention; then
                    local pr_watch_start=$SECONDS
                    local claude_done=true codex_done=true
                    $claude_needs_attention && claude_done=false
                    $codex_needs_attention && codex_done=false

                    while ! ($claude_done && $codex_done); do
                        local elapsed=$((SECONDS - pr_watch_start))

                        local claude_status codex_status
                        claude_status="$(get_agent_status "claude" "$peer_sync")"
                        codex_status="$(get_agent_status "codex" "$peer_sync")"

                        # Check for completion
                        if ! $claude_done && [[ "$claude_status" =~ ^(done|pr-created)$ ]]; then
                            claude_done=true
                        fi
                        if ! $codex_done && [[ "$codex_status" =~ ^(done|pr-created)$ ]]; then
                            codex_done=true
                        fi

                        if $claude_done && $codex_done; then
                            break
                        fi

                        # Check timeout
                        if [ "$elapsed" -ge "$DEFAULT_PR_WATCH_TIMEOUT" ]; then
                            warn "PR comment response timeout (${DEFAULT_PR_WATCH_TIMEOUT}s)"
                            break
                        fi

                        printf "\r  Waiting... claude=%s codex=%s (%ds)  " "$claude_status" "$codex_status" "$elapsed"
                        sleep "$poll_interval"
                    done
                    echo ""
                fi

                # Poll interval before next check
                printf "\r  Watching for PR comments... (Ctrl-C to stop)  "
                sleep "$poll_interval"
            done
        fi
    fi

    echo ""
    info "=== Final Status ==="
    cmd_status
}

#------------------------------------------------------------------------------
# Command: nudge
#------------------------------------------------------------------------------

cmd_nudge() {
    local agent="$1"
    local message="${2:-Continue.}"

    [ -z "$agent" ] && die "Usage: agent-duo nudge <agent> [message]"

    local root
    root="$(get_project_root)"
    local feature
    feature="$(get_feature)"
    local session_name="duo-${feature}"

    # Determine session target
    local session
    if tmux has-session -t "$session_name" 2>/dev/null; then
        session="${session_name}:${agent}"
    elif tmux has-session -t "${session_name}-${agent}" 2>/dev/null; then
        session="${session_name}-${agent}"
    else
        die "No tmux session found for $agent"
    fi

    nudge_agent "$agent" "$session" "$message"
    success "Nudged $agent"
}

#------------------------------------------------------------------------------
# Command: interrupt
#------------------------------------------------------------------------------

cmd_interrupt() {
    local agent="$1"

    [ -z "$agent" ] && die "Usage: agent-duo interrupt <agent>"

    local root
    root="$(get_project_root)"
    local peer_sync="$root/.peer-sync"
    local feature
    feature="$(get_feature)"
    local session_name="duo-${feature}"

    # Determine session target
    local session
    if tmux has-session -t "$session_name" 2>/dev/null; then
        session="${session_name}:${agent}"
    elif tmux has-session -t "${session_name}-${agent}" 2>/dev/null; then
        session="${session_name}-${agent}"
    else
        die "No tmux session found for $agent"
    fi

    interrupt_agent "$agent" "$session" "$peer_sync"
    success "Interrupted $agent"
}

#------------------------------------------------------------------------------
# Command: help
#------------------------------------------------------------------------------

cmd_help() {
    cat << 'EOF'
Agent Duo - Coordinate two AI coding agents

USAGE
    agent-duo <command> [options]

SESSION COMMANDS
    start <feature> [options]
        Start a new session for the given feature.
        Creates worktrees, tmux sessions, and ttyd web terminals.
        Looks for task description in: <feature>.md, doc/<feature>.md,
        docs/<feature>.md, or **/<feature>.md (anywhere in project).

        Options:
          --auto-run               Start orchestrator immediately in its own terminal
          --no-ttyd                Use single tmux session instead of web terminals
          --clarify                Enable clarify stage before work starts
          --pushback               Enable pushback stage (after clarify if both enabled)
          --work-timeout <secs>    Work phase timeout (default: 1200, with --auto-run)
          --review-timeout <secs>  Review phase timeout (default: 600, with --auto-run)
          --clarify-timeout <secs> Clarify stage timeout (default: 600, with --clarify)
          --pushback-timeout <secs> Pushback stage timeout (default: 600, with --pushback)
          --max-rounds <n>         Maximum rounds (default: 10, with --auto-run)
          --codex-thinking <level> Codex reasoning effort: low, medium, high (default: high)
          --codex-model <model>    GPT model for Codex (e.g., o3, gpt-4.1)
          --claude-model <model>   Claude model (e.g., opus, sonnet)
          --port <port>            Base port for web terminals (uses 3 consecutive ports)
                                   If not specified, finds first available consecutive ports.
                                   Fails if any of the 3 ports are occupied.

        With ttyd (default): Creates 3 web terminals on consecutive ports
          - Orchestrator: port (or first available)
          - Claude: port+1
          - Codex: port+2
          Port assignments are stored in .peer-sync/ports for the session.

        With --no-ttyd: Creates single tmux session with 3 windows

        With --clarify: Agents first propose approaches and questions.
          User receives email and can respond before work begins.

        With --pushback: Agents propose improvements to the task file.
          User can accept, reject, or modify the proposed changes.

    run [options]
        Run the orchestrator loop (work -> review -> work... -> pr-comments).
        Automatically manages phase transitions and timeouts.
        After both PRs are created, monitors for new GitHub comments/reviews.
        Not needed if using 'start --auto-run'.

        Options:
          --clarify                Enable clarify stage before work starts
          --pushback               Enable pushback stage (after clarify if both enabled)
          --work-timeout <secs>    Work phase timeout (default: 1200)
          --review-timeout <secs>  Review phase timeout (default: 600)
          --clarify-timeout <secs> Clarify stage timeout (default: 600)
          --pushback-timeout <secs> Pushback stage timeout (default: 600)
          --poll <secs>            Status poll interval (default: 10)
          --max-rounds <n>         Maximum rounds (default: 10)
          --auto-start             Auto-launch agent CLIs and send task

    stop
        Stop ttyd servers and tmux sessions, keep worktrees.

    restart [options]
        Restart a session after system restart or crash (DWIM behavior).
        - If healthy: no-op
        - If tmux sessions missing: recreates them
        - If ttyd down: restarts it (errors if port occupied by other process)
        - If agent TUIs not running: restarts them
        - If orchestration incomplete: optionally restarts orchestrator

        Options:
          --auto-run               Also restart the orchestrator loop
          --work-timeout <secs>    Work phase timeout (default: 1200)
          --review-timeout <secs>  Review phase timeout (default: 600)
          --max-rounds <n>         Maximum rounds (default: 10)

    status
        Show current session state, agent statuses, and PRs.

    confirm
        Confirm the clarify phase is complete and proceed to work phase.
        Alternative to pressing Enter in the orchestrator terminal.

    escalate-resolve
        Review and resolve pending escalations from agents.
        Escalations block phase transitions until resolved.

    pr <agent>
        Create a PR for the specified agent (claude or codex).
        Auto-commits uncommitted changes and pushes.

    merge
        Start merge phase to consolidate both PRs into main.
        Both agents vote on which PR to merge, debate if needed,
        then the losing agent merges and cherry-picks features.
        Requires both PRs to exist.

    cleanup [--full]
        Remove session state (.peer-sync). With --full, also removes
        worktrees and deletes the feature branches.

    setup
        Install agent-duo to ~/.local/bin and skills to agent dirs.

    doctor [--send-email] [--send-ntfy]
        Check system configuration and diagnose common issues.
        Verifies: required tools, AI CLIs, git config, email/ntfy setup,
        skills installation, hook configuration, and PATH.

        Options:
          --send-email    Send a test email to verify email delivery
          --send-ntfy     Send a test ntfy notification

    config [key] [value]
        Get or set configuration values.
        Without arguments, shows current configuration.

        Keys:
          ntfy_topic      ntfy.sh topic name for push notifications
          ntfy_token      ntfy.sh access token (for reserved/private topics)
          ntfy_server     ntfy server URL (default: https://ntfy.sh)

        Examples:
          agent-duo config                       # Show all config
          agent-duo config ntfy_topic            # Get ntfy topic
          agent-duo config ntfy_topic myapp123   # Set ntfy topic
          agent-duo config ntfy_token tk_abc123  # Set access token

CONTROL COMMANDS
    nudge <agent> [message]
        Send a message to an agent's terminal.
        Default message: "Continue."

    interrupt <agent>
        Send Escape to interrupt an agent and mark as interrupted.

AGENT COMMANDS (used by AI agents)
    signal <agent> <status> [message]
        Signal a status change. Status values:
        clarifying, clarify-done, pushing-back, pushback-done, working, done,
        reviewing, review-done, interrupted, error, pr-created, escalated,
        voting, vote-done, debating, debate-done, merging, merge-done,
        merge-reviewing, merge-review-done

    peer-status
        Read peer's current status (requires PEER_NAME env var).

    phase
        Read current phase (clarify, pushback, work, review, or merge).

    escalate <reason> [message]
        Escalate an issue requiring user input. Does not interrupt the agent.
        The orchestrator will block phase transitions until user resolves.

        Reasons:
          ambiguity     - Requirements are unclear
          inconsistency - Conflicting requirements or code/docs mismatch
          misguided     - Evidence the task approach is wrong

ENVIRONMENT VARIABLES (set in agent sessions)
    PEER_SYNC       Path to .peer-sync directory
    MY_NAME         This agent's name (claude or codex)
    PEER_NAME       Other agent's name
    PEER_WORKTREE   Path to peer's worktree
    FEATURE         Feature name

EXAMPLES
    # Recommended: start with auto-run (opens 3 web terminals, starts everything)
    agent-duo start auth --auto-run

    # With clarify stage: agents propose approaches before starting work
    agent-duo start auth --auto-run --clarify

    # With pushback stage: agents propose improvements to the task file
    agent-duo start auth --auto-run --pushback

    # With both stages: clarify -> pushback -> work
    agent-duo start auth --auto-run --clarify --pushback
    # Review approaches, respond to agents, then press Enter in orchestrator

    # Alternative: start manually then run orchestrator
    agent-duo start auth
    agent-duo run --auto-start

    # Use tmux instead of web terminals
    agent-duo start auth --no-ttyd
    tmux attach -t duo-auth
    # Then run: agent-duo run --auto-start

    # Recover after system restart
    agent-duo restart --auto-run

    # Nudge a stuck agent
    agent-duo nudge claude "Please continue with the implementation."

    # Check status
    agent-duo status

    # Create PR when done
    agent-duo pr claude

    # After both PRs created: merge phase
    agent-duo merge
    # Agents vote, debate if needed, then execute merge

    # Clean up
    agent-duo cleanup --full
EOF
}

#------------------------------------------------------------------------------
# Main
#------------------------------------------------------------------------------

main() {
    local cmd="${1:-help}"
    shift || true

    case "$cmd" in
        start)       cmd_start "$@" ;;
        run)         cmd_run "$@" ;;
        stop)        cmd_stop "$@" ;;
        restart)     cmd_restart "$@" ;;
        status)      cmd_status "$@" ;;
        confirm)     cmd_confirm "$@" ;;
        escalate)    cmd_escalate "$@" ;;
        escalate-resolve) cmd_escalate_resolve "$@" ;;
        pr)          cmd_pr "$@" ;;
        merge)       cmd_merge "$@" ;;
        cleanup)     cmd_cleanup "$@" ;;
        setup)       cmd_setup "$@" ;;
        doctor)      cmd_doctor "$@" ;;
        config)      cmd_config "$@" ;;
        nudge)       cmd_nudge "$@" ;;
        interrupt)   cmd_interrupt "$@" ;;
        signal)      cmd_signal "$@" ;;
        peer-status) cmd_peer_status "$@" ;;
        phase)       cmd_phase "$@" ;;
        help|--help|-h) cmd_help ;;
        *)           die "Unknown command: $cmd (try 'agent-duo help')" ;;
    esac
}

main "$@"
