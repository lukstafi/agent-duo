#!/bin/bash
# agent-duo - Coordinate two AI coding agents working in parallel
#
# Usage: agent-duo <command> [options]
#
# Session Commands:
#   start <feature> [--auto-run] [--no-ttyd]   Start session with web terminals
#   run [options]        Run orchestrator loop with timeouts
#   stop                 Stop ttyd servers, keep worktrees
#   status               Show session state
#   pr <agent>           Create PR for agent's solution
#   cleanup [--full]     Remove worktrees (--full: also state)
#   setup                Install agent-duo to PATH and skills
#
# Control Commands:
#   nudge <agent> [msg]  Send message to agent terminal
#   interrupt <agent>    Interrupt agent (Esc + Ctrl-C)
#
# Agent Commands:
#   signal <agent> <status> [message]   Signal status change
#   peer-status                         Read peer's status
#   phase                               Read current phase

set -e

# Determine script location (resolves symlinks)
SCRIPT_PATH="${BASH_SOURCE[0]}"
while [ -L "$SCRIPT_PATH" ]; do
    SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
    SCRIPT_PATH="$(readlink "$SCRIPT_PATH")"
    [[ $SCRIPT_PATH != /* ]] && SCRIPT_PATH="$SCRIPT_DIR/$SCRIPT_PATH"
done
SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Default agents
DEFAULT_AGENT_A="claude"
DEFAULT_AGENT_B="codex"

# Ports for ttyd
ORCHESTRATOR_PORT=7680
CLAUDE_PORT=7681
CODEX_PORT=7682

# Commands to launch each agent
CLAUDE_CMD="claude --dangerously-skip-permissions"
CODEX_CMD="codex --yolo"

#------------------------------------------------------------------------------
# Helper Functions
#------------------------------------------------------------------------------

die() {
    echo -e "${RED}Error: $1${NC}" >&2
    exit 1
}

info() {
    echo -e "${BLUE}$1${NC}"
}

success() {
    echo -e "${GREEN}$1${NC}"
}

warn() {
    echo -e "${YELLOW}$1${NC}"
}

# Get project root (where .peer-sync is)
get_project_root() {
    if [ -n "$PEER_SYNC" ]; then
        dirname "$PEER_SYNC"
    elif [ -d ".peer-sync" ]; then
        pwd
    else
        # Look for .peer-sync in parent directories
        local dir="$PWD"
        while [ "$dir" != "/" ]; do
            if [ -d "$dir/.peer-sync" ]; then
                echo "$dir"
                return
            fi
            dir="$(dirname "$dir")"
        done
        die "Not in an agent-duo session (no .peer-sync found)"
    fi
}

# Get feature name from session
get_feature() {
    local root
    root="$(get_project_root)"
    if [ -f "$root/.peer-sync/feature" ]; then
        cat "$root/.peer-sync/feature"
    else
        die "No active session (missing .peer-sync/feature)"
    fi
}

# Atomic file write with locking
atomic_write() {
    local file="$1"
    local content="$2"
    local lockdir
    lockdir="$(dirname "$file")/.lock"

    # Acquire lock
    while ! mkdir "$lockdir" 2>/dev/null; do
        sleep 0.05
    done

    # Write file
    echo "$content" > "$file"

    # Release lock
    rmdir "$lockdir"
}

# Get agent command
get_agent_cmd() {
    local agent="$1"
    case "$agent" in
        claude) echo "$CLAUDE_CMD" ;;
        codex) echo "$CODEX_CMD" ;;
        *) echo "$agent" ;;  # Allow custom agents
    esac
}

# Get agent port
get_agent_port() {
    local agent="$1"
    case "$agent" in
        claude) echo "$CLAUDE_PORT" ;;
        codex) echo "$CODEX_PORT" ;;
        *) echo "$((7680 + RANDOM % 100))" ;;
    esac
}

# Find task file for a feature
# Searches in order: <feature>.md, doc/<feature>.md, docs/<feature>.md, **/<feature>.md
find_task_file() {
    local project_root="$1"
    local feature="$2"

    # Check standard locations first
    for path in "$project_root/$feature.md" \
                "$project_root/doc/$feature.md" \
                "$project_root/docs/$feature.md"; do
        if [ -f "$path" ]; then
            echo "$path"
            return 0
        fi
    done

    # Fall back to searching anywhere in the project
    local found
    found="$(find "$project_root" -name "$feature.md" -type f 2>/dev/null | head -1)"
    if [ -n "$found" ]; then
        echo "$found"
        return 0
    fi

    return 1
}

#------------------------------------------------------------------------------
# Command: setup
#------------------------------------------------------------------------------

# Install a skill from template with agent-specific replacements
install_skill() {
    local template="$1"
    local dest="$2"
    local skill_cmd="$3"  # e.g., "/duo-work" for Claude, "$duo-work" for Codex

    if [ -f "$template" ]; then
        # Replace {{SKILL_CMD}} placeholder with agent-specific command prefix
        sed "s|{{SKILL_CMD}}|${skill_cmd}|g" "$template" > "$dest"
    fi
}

cmd_setup() {
    info "Installing agent-duo..."

    local templates_dir="$SCRIPT_DIR/skills/templates"

    if [ ! -d "$templates_dir" ]; then
        die "Skills templates not found at $templates_dir"
    fi

    # Install CLI to ~/.local/bin
    local install_dir="$HOME/.local/bin"
    mkdir -p "$install_dir"

    local install_path="$install_dir/agent-duo"
    if [ "$SCRIPT_DIR/agent-duo" != "$install_path" ]; then
        cp "$SCRIPT_DIR/agent-duo" "$install_path"
        chmod +x "$install_path"
        success "Installed agent-duo to $install_path"
    else
        success "agent-duo already installed at $install_path"
    fi

    # Check if ~/.local/bin is in PATH
    if [[ ":$PATH:" != *":$install_dir:"* ]]; then
        warn "Add $install_dir to your PATH:"
        echo "  export PATH=\"\$HOME/.local/bin:\$PATH\""
    fi

    # Install Claude skills (uses /command syntax)
    local claude_skills="$HOME/.claude/commands"
    mkdir -p "$claude_skills"

    install_skill "$templates_dir/duo-work.md" "$claude_skills/duo-work.md" "/duo-work"
    install_skill "$templates_dir/duo-review.md" "$claude_skills/duo-review.md" "/duo-review"
    success "Installed Claude skills to $claude_skills"

    # Install Codex skills (uses $command syntax)
    # Codex expects skills as directories with SKILL.md inside
    local codex_skills="$HOME/.codex/skills"
    mkdir -p "$codex_skills/duo-work" "$codex_skills/duo-review"

    install_skill "$templates_dir/duo-work.md" "$codex_skills/duo-work/SKILL.md" "\$duo-work"
    install_skill "$templates_dir/duo-review.md" "$codex_skills/duo-review/SKILL.md" "\$duo-review"
    success "Installed Codex skills to $codex_skills"

    # Install shared notify hook script for both agents
    # Called when agent completes a turn to auto-signal status
    local notify_script="$install_dir/agent-duo-notify"
    cat > "$notify_script" << 'NOTIFY_EOF'
#!/bin/bash
# Called by agent hooks when they complete a turn
# Signals the appropriate status based on current phase
# Usage: agent-duo-notify <agent-name>
#   or via environment: MY_NAME=<agent-name> agent-duo-notify

agent="${1:-$MY_NAME}"
[ -z "$agent" ] && exit 0

# Need PEER_SYNC to be set
[ -z "$PEER_SYNC" ] && exit 0
[ ! -d "$PEER_SYNC" ] && exit 0

# Read current phase
phase="$(cat "$PEER_SYNC/phase" 2>/dev/null)" || exit 0

# Read current status
current_status="$(cut -d'|' -f1 < "$PEER_SYNC/${agent}.status" 2>/dev/null)"

# Determine what status to signal based on phase
case "$phase" in
    work)
        # Don't override if already done or beyond
        case "$current_status" in
            done|review-done|pr-created) exit 0 ;;
        esac
        agent-duo signal "$agent" done "completed via hook"
        ;;
    review)
        # Don't override if already review-done or beyond
        case "$current_status" in
            review-done|pr-created) exit 0 ;;
        esac
        agent-duo signal "$agent" review-done "completed via hook"
        ;;
esac
NOTIFY_EOF
    chmod +x "$notify_script"
    success "Installed notify hook script to $notify_script"

    # Configure Codex to use the notify hook
    local codex_config="$HOME/.codex/config.toml"
    if [ -f "$codex_config" ]; then
        if grep -q "^notify" "$codex_config"; then
            warn "Codex config already has 'notify' setting - not overwriting"
            warn "To enable auto-signaling, set: notify = [\"$notify_script\"]"
        else
            echo "" >> "$codex_config"
            echo "# Agent-duo notify hook for auto-signaling completion" >> "$codex_config"
            echo "notify = [\"$notify_script\"]" >> "$codex_config"
            success "Added notify hook to Codex config"
        fi
    else
        mkdir -p "$(dirname "$codex_config")"
        echo "# Agent-duo notify hook for auto-signaling completion" > "$codex_config"
        echo "notify = [\"$notify_script\"]" >> "$codex_config"
        success "Created Codex config with notify hook"
    fi

    # Configure Claude to use the Stop hook
    local claude_settings="$HOME/.claude/settings.json"
    local hook_config="{\"Stop\":[{\"hooks\":[{\"type\":\"command\",\"command\":\"$notify_script\"}]}]}"

    if [ -f "$claude_settings" ]; then
        # Check if hooks already configured
        if grep -q '"hooks"' "$claude_settings"; then
            warn "Claude settings already has 'hooks' - not overwriting"
            warn "To enable auto-signaling, add Stop hook: $notify_script"
        else
            # Add hooks to existing settings using a temp file approach
            # Remove trailing } and add hooks
            local tmp_settings
            tmp_settings="$(mktemp)"
            # Use Python/jq if available, otherwise simple sed
            if command -v jq >/dev/null 2>&1; then
                jq --arg cmd "$notify_script" '.hooks = {"Stop":[{"hooks":[{"type":"command","command":$cmd}]}]}' "$claude_settings" > "$tmp_settings"
                mv "$tmp_settings" "$claude_settings"
                success "Added Stop hook to Claude settings"
            else
                warn "jq not found - please manually add hooks to $claude_settings:"
                echo "  \"hooks\": $hook_config"
            fi
        fi
    else
        mkdir -p "$(dirname "$claude_settings")"
        echo "{\"hooks\":$hook_config}" > "$claude_settings"
        success "Created Claude settings with Stop hook"
    fi

    success "Setup complete!"
}

#------------------------------------------------------------------------------
# Command: start
#------------------------------------------------------------------------------

cmd_start() {
    local feature=""
    local ttyd_mode=true
    local auto_run=false
    local work_timeout=$DEFAULT_WORK_TIMEOUT
    local review_timeout=$DEFAULT_REVIEW_TIMEOUT
    local max_rounds=10

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --no-ttyd) ttyd_mode=false; shift ;;
            --auto-run) auto_run=true; shift ;;
            --work-timeout) work_timeout="$2"; shift 2 ;;
            --review-timeout) review_timeout="$2"; shift 2 ;;
            --max-rounds) max_rounds="$2"; shift 2 ;;
            -*) die "Unknown option: $1" ;;
            *) feature="$1"; shift ;;
        esac
    done

    [ -z "$feature" ] && die "Usage: agent-duo start <feature> [--no-ttyd] [--auto-run]"

    # Ensure we're in a git repo
    git rev-parse --is-inside-work-tree >/dev/null 2>&1 || die "Not a git repository"

    # Ensure repo has at least one commit
    git rev-parse HEAD >/dev/null 2>&1 || die "Repository has no commits. Create an initial commit first."

    local project_root
    project_root="$(git rev-parse --show-toplevel)"
    local project_name
    project_name="$(basename "$project_root")"

    # Check for task file
    local task_file
    if task_file="$(find_task_file "$project_root" "$feature")"; then
        info "Found task file: $task_file"
    else
        warn "Task file not found: $feature.md"
        warn "Searched: $feature.md, doc/$feature.md, docs/$feature.md, **/$feature.md"
        warn "Create it with the task description, or the agents won't know what to do."
    fi

    info "Starting Agent Duo session: $feature"
    info "Project: $project_name"

    # Set up worktree paths (siblings of project root)
    local parent_dir
    parent_dir="$(dirname "$project_root")"
    local worktree_claude="$parent_dir/${project_name}-${feature}-claude"
    local worktree_codex="$parent_dir/${project_name}-${feature}-codex"

    # Create branches and worktrees
    cd "$project_root"

    # Detect main branch: try origin/HEAD, then common names, then current branch
    local main_branch
    main_branch="$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@')" || true
    if [ -z "$main_branch" ]; then
        # Try common branch names
        for candidate in main master; do
            if git rev-parse --verify "$candidate" >/dev/null 2>&1; then
                main_branch="$candidate"
                break
            fi
        done
    fi
    if [ -z "$main_branch" ]; then
        # Fall back to current branch
        main_branch="$(git rev-parse --abbrev-ref HEAD)"
    fi

    if [ ! -d "$worktree_claude" ]; then
        info "Creating worktree for claude..."
        git worktree add -b "${feature}-claude" "$worktree_claude" "$main_branch" 2>/dev/null || \
            git worktree add "$worktree_claude" "${feature}-claude"
    else
        warn "Worktree already exists: $worktree_claude"
    fi

    if [ ! -d "$worktree_codex" ]; then
        info "Creating worktree for codex..."
        git worktree add -b "${feature}-codex" "$worktree_codex" "$main_branch" 2>/dev/null || \
            git worktree add "$worktree_codex" "${feature}-codex"
    else
        warn "Worktree already exists: $worktree_codex"
    fi

    # Initialize .peer-sync
    local peer_sync="$project_root/.peer-sync"
    mkdir -p "$peer_sync/reviews"
    mkdir -p "$peer_sync/pids"

    echo "active" > "$peer_sync/session"
    echo "work" > "$peer_sync/phase"
    echo "1" > "$peer_sync/round"
    echo "$feature" > "$peer_sync/feature"
    echo "working|$(date +%s)|starting" > "$peer_sync/claude.status"
    echo "working|$(date +%s)|starting" > "$peer_sync/codex.status"

    # Create symlinks in worktrees
    ln -sfn "$peer_sync" "$worktree_claude/.peer-sync"
    ln -sfn "$peer_sync" "$worktree_codex/.peer-sync"

    # Copy task file to worktrees if it exists
    if [ -f "$task_file" ]; then
        cp "$task_file" "$worktree_claude/"
        cp "$task_file" "$worktree_codex/"
    fi

    if $ttyd_mode; then
        start_ttyd_mode "$feature" "$project_root" "$worktree_claude" "$worktree_codex" "$peer_sync" \
            "$auto_run" "$work_timeout" "$review_timeout" "$max_rounds"
    else
        start_tmux_mode "$feature" "$project_root" "$worktree_claude" "$worktree_codex" "$peer_sync"
    fi
}

start_tmux_mode() {
    local feature="$1"
    local project_root="$2"
    local worktree_claude="$3"
    local worktree_codex="$4"
    local peer_sync="$5"

    local session_name="duo-${feature}"

    # Kill existing session if any
    tmux kill-session -t "$session_name" 2>/dev/null || true

    # Create new tmux session with orchestrator window
    tmux new-session -d -s "$session_name" -n "orchestrator" -c "$project_root"

    # Create claude window
    tmux new-window -t "$session_name" -n "claude" -c "$worktree_claude"
    tmux send-keys -t "$session_name:claude" "export PEER_SYNC='$peer_sync'"
    tmux send-keys -t "$session_name:claude" C-m
    tmux send-keys -t "$session_name:claude" "export MY_NAME='claude'"
    tmux send-keys -t "$session_name:claude" C-m
    tmux send-keys -t "$session_name:claude" "export PEER_NAME='codex'"
    tmux send-keys -t "$session_name:claude" C-m
    tmux send-keys -t "$session_name:claude" "export PEER_WORKTREE='$worktree_codex'"
    tmux send-keys -t "$session_name:claude" C-m
    tmux send-keys -t "$session_name:claude" "export FEATURE='$feature'"
    tmux send-keys -t "$session_name:claude" C-m

    # Create codex window
    tmux new-window -t "$session_name" -n "codex" -c "$worktree_codex"
    tmux send-keys -t "$session_name:codex" "export PEER_SYNC='$peer_sync'"
    tmux send-keys -t "$session_name:codex" C-m
    tmux send-keys -t "$session_name:codex" "export MY_NAME='codex'"
    tmux send-keys -t "$session_name:codex" C-m
    tmux send-keys -t "$session_name:codex" "export PEER_NAME='claude'"
    tmux send-keys -t "$session_name:codex" C-m
    tmux send-keys -t "$session_name:codex" "export PEER_WORKTREE='$worktree_claude'"
    tmux send-keys -t "$session_name:codex" C-m
    tmux send-keys -t "$session_name:codex" "export FEATURE='$feature'"
    tmux send-keys -t "$session_name:codex" C-m

    success "Created tmux session: $session_name"
    echo ""
    echo "Windows:"
    echo "  0: orchestrator  - Main project root"
    echo "  1: claude        - $worktree_claude"
    echo "  2: codex         - $worktree_codex"
    echo ""
    echo "Attach with: tmux attach -t $session_name"
    echo ""
    echo "To start agents, in each window run their CLI:"
    echo "  claude window: $CLAUDE_CMD"
    echo "  codex window:  $CODEX_CMD"
}

start_ttyd_mode() {
    local feature="$1"
    local project_root="$2"
    local worktree_claude="$3"
    local worktree_codex="$4"
    local peer_sync="$5"
    local auto_run="${6:-false}"
    local work_timeout="${7:-$DEFAULT_WORK_TIMEOUT}"
    local review_timeout="${8:-$DEFAULT_REVIEW_TIMEOUT}"
    local max_rounds="${9:-10}"

    local session_name="duo-${feature}"

    # Check ttyd is installed
    command -v ttyd >/dev/null 2>&1 || die "ttyd not found. Install with: brew install ttyd"

    # Kill existing sessions if any
    tmux kill-session -t "${session_name}-orchestrator" 2>/dev/null || true
    tmux kill-session -t "${session_name}-claude" 2>/dev/null || true
    tmux kill-session -t "${session_name}-codex" 2>/dev/null || true

    # Create tmux sessions for orchestrator and each agent
    tmux new-session -d -s "${session_name}-orchestrator" -c "$project_root"
    tmux new-session -d -s "${session_name}-claude" -c "$worktree_claude"
    tmux new-session -d -s "${session_name}-codex" -c "$worktree_codex"

    # Set environment variables for orchestrator
    for var in "PEER_SYNC='$peer_sync'" "FEATURE='$feature'"; do
        tmux send-keys -t "${session_name}-orchestrator" "export $var"
        tmux send-keys -t "${session_name}-orchestrator" C-m
    done

    # Set environment variables for agents
    for var in "PEER_SYNC='$peer_sync'" "MY_NAME='claude'" "PEER_NAME='codex'" "PEER_WORKTREE='$worktree_codex'" "FEATURE='$feature'"; do
        tmux send-keys -t "${session_name}-claude" "export $var"
        tmux send-keys -t "${session_name}-claude" C-m
    done

    for var in "PEER_SYNC='$peer_sync'" "MY_NAME='codex'" "PEER_NAME='claude'" "PEER_WORKTREE='$worktree_claude'" "FEATURE='$feature'"; do
        tmux send-keys -t "${session_name}-codex" "export $var"
        tmux send-keys -t "${session_name}-codex" C-m
    done

    # Start ttyd servers
    local orchestrator_port=$ORCHESTRATOR_PORT
    local claude_port=$CLAUDE_PORT
    local codex_port=$CODEX_PORT

    ttyd -p "$orchestrator_port" -W tmux attach -t "${session_name}-orchestrator" &
    echo $! > "$peer_sync/pids/ttyd-orchestrator.pid"

    ttyd -p "$claude_port" -W tmux attach -t "${session_name}-claude" &
    echo $! > "$peer_sync/pids/ttyd-claude.pid"

    ttyd -p "$codex_port" -W tmux attach -t "${session_name}-codex" &
    echo $! > "$peer_sync/pids/ttyd-codex.pid"

    success "Started ttyd servers"
    echo ""
    echo "Web terminals:"
    echo "  Orchestrator: http://localhost:$orchestrator_port"
    echo "  Claude:       http://localhost:$claude_port"
    echo "  Codex:        http://localhost:$codex_port"
    echo ""

    # If auto-run, start the orchestrator loop in the orchestrator session
    if [ "$auto_run" = "true" ]; then
        info "Starting orchestrator with --auto-start..."
        tmux send-keys -t "${session_name}-orchestrator" \
            "agent-duo run --auto-start --work-timeout $work_timeout --review-timeout $review_timeout --max-rounds $max_rounds"
        tmux send-keys -t "${session_name}-orchestrator" C-m
    else
        echo "Start orchestrator with: agent-duo run --auto-start"
    fi
    echo "Stop with: agent-duo stop"
}

#------------------------------------------------------------------------------
# Command: stop
#------------------------------------------------------------------------------

cmd_stop() {
    local root
    root="$(get_project_root)"
    local peer_sync="$root/.peer-sync"

    info "Stopping Agent Duo..."

    # Kill ttyd processes from PID files
    if [ -d "$peer_sync/pids" ]; then
        for pidfile in "$peer_sync/pids"/*.pid; do
            [ -f "$pidfile" ] || continue
            local pid
            pid="$(cat "$pidfile")"
            if kill -0 "$pid" 2>/dev/null; then
                kill "$pid" 2>/dev/null || true
                info "Killed process $pid ($(basename "$pidfile" .pid))"
            fi
            rm -f "$pidfile"
        done
    fi

    # Fallback: kill any ttyd processes for duo- sessions (in case PID files are missing)
    pkill -f "ttyd.*duo-" 2>/dev/null && info "Killed remaining ttyd processes" || true

    # Kill tmux sessions with duo- prefix
    local feature
    feature="$(get_feature 2>/dev/null)" || true
    if [ -n "$feature" ]; then
        tmux kill-session -t "duo-${feature}" 2>/dev/null && info "Killed tmux session: duo-${feature}" || true
        tmux kill-session -t "duo-${feature}-orchestrator" 2>/dev/null && info "Killed tmux session: duo-${feature}-orchestrator" || true
        tmux kill-session -t "duo-${feature}-claude" 2>/dev/null && info "Killed tmux session: duo-${feature}-claude" || true
        tmux kill-session -t "duo-${feature}-codex" 2>/dev/null && info "Killed tmux session: duo-${feature}-codex" || true
    fi

    success "Stopped"
}

#------------------------------------------------------------------------------
# Command: status
#------------------------------------------------------------------------------

cmd_status() {
    local root
    root="$(get_project_root 2>/dev/null)" || die "Not in an agent-duo session"
    local peer_sync="$root/.peer-sync"

    echo ""
    echo "=== Agent Duo Status ==="
    echo ""

    if [ -f "$peer_sync/feature" ]; then
        echo "Feature:  $(cat "$peer_sync/feature")"
    fi

    if [ -f "$peer_sync/session" ]; then
        echo "Session:  $(cat "$peer_sync/session")"
    fi

    if [ -f "$peer_sync/phase" ]; then
        echo "Phase:    $(cat "$peer_sync/phase")"
    fi

    if [ -f "$peer_sync/round" ]; then
        echo "Round:    $(cat "$peer_sync/round")"
    fi

    echo ""
    echo "--- Agent Status ---"

    for agent in claude codex; do
        local status_file="$peer_sync/${agent}.status"
        if [ -f "$status_file" ]; then
            local line
            line="$(cat "$status_file")"
            local status msg timestamp
            status="$(echo "$line" | cut -d'|' -f1)"
            timestamp="$(echo "$line" | cut -d'|' -f2)"
            msg="$(echo "$line" | cut -d'|' -f3-)"

            local time_str=""
            if [ -n "$timestamp" ] && [ "$timestamp" != "$status" ]; then
                time_str=" ($(date -r "$timestamp" '+%H:%M:%S' 2>/dev/null || echo "$timestamp"))"
            fi

            printf "%-8s: %s%s" "$agent" "$status" "$time_str"
            [ -n "$msg" ] && [ "$msg" != "$status" ] && printf " - %s" "$msg"
            echo ""
        else
            echo "$agent:   (no status)"
        fi
    done

    # Check for PRs
    echo ""
    echo "--- Pull Requests ---"
    for agent in claude codex; do
        local pr_file="$peer_sync/${agent}.pr"
        if [ -f "$pr_file" ]; then
            echo "$agent:   $(cat "$pr_file")"
        else
            echo "$agent:   (none)"
        fi
    done

    # List reviews
    if [ -d "$peer_sync/reviews" ] && [ "$(ls -A "$peer_sync/reviews" 2>/dev/null)" ]; then
        echo ""
        echo "--- Reviews ---"
        ls -1 "$peer_sync/reviews"
    fi

    echo ""
}

#------------------------------------------------------------------------------
# Command: pr
#------------------------------------------------------------------------------

cmd_pr() {
    local agent="$1"
    [ -z "$agent" ] && die "Usage: agent-duo pr <agent>"

    local root
    root="$(get_project_root)"
    local peer_sync="$root/.peer-sync"
    local feature
    feature="$(get_feature)"

    # Determine worktree
    local project_name
    project_name="$(basename "$root")"
    local parent_dir
    parent_dir="$(dirname "$root")"
    local worktree="$parent_dir/${project_name}-${feature}-${agent}"

    [ -d "$worktree" ] || die "Worktree not found: $worktree"

    info "Creating PR for $agent..."

    cd "$worktree"

    # Check for changes
    if [ -z "$(git status --porcelain)" ]; then
        warn "No changes to commit in $agent's worktree"
    else
        # Auto-commit changes
        git add -A
        git commit -m "Solution from $agent for $feature" || true
    fi

    # Push branch
    local branch="${feature}-${agent}"
    git push -u origin "$branch" 2>/dev/null || git push origin "$branch"

    # Look for PR body file
    local pr_body=""
    local pr_body_file="$root/${feature}-${agent}-PR.md"
    if [ -f "$pr_body_file" ]; then
        pr_body="$(cat "$pr_body_file")"
    else
        pr_body="Solution from $agent for feature: $feature"
    fi

    # Create PR
    local pr_url
    pr_url="$(gh pr create --title "${agent}'s solution for $feature" --body "$pr_body" --head "$branch" 2>/dev/null)" || \
        pr_url="$(gh pr view --json url -q '.url' 2>/dev/null)" || \
        die "Failed to create PR. Is gh installed and authenticated?"

    # Record PR
    echo "$pr_url" > "$peer_sync/${agent}.pr"
    atomic_write "$peer_sync/${agent}.status" "pr-created|$(date +%s)|$pr_url"

    success "PR created: $pr_url"

    # Check if both PRs exist
    if [ -f "$peer_sync/claude.pr" ] && [ -f "$peer_sync/codex.pr" ]; then
        echo "complete" > "$peer_sync/session"
        success "Both PRs created - session complete!"
    fi
}

#------------------------------------------------------------------------------
# Command: cleanup
#------------------------------------------------------------------------------

cmd_cleanup() {
    local full=false
    [ "$1" = "--full" ] && full=true

    local root
    root="$(get_project_root)"
    local peer_sync="$root/.peer-sync"
    local feature
    feature="$(get_feature)"
    local project_name
    project_name="$(basename "$root")"
    local parent_dir
    parent_dir="$(dirname "$root")"

    info "Cleaning up session: $feature"

    # Stop any running processes first
    cmd_stop

    # Remove worktrees
    local worktree_claude="$parent_dir/${project_name}-${feature}-claude"
    local worktree_codex="$parent_dir/${project_name}-${feature}-codex"

    cd "$root"  # Make sure we're not in a worktree

    if [ -d "$worktree_claude" ]; then
        git worktree remove --force "$worktree_claude" 2>/dev/null || rm -rf "$worktree_claude"
        info "Removed worktree: $worktree_claude"
    fi

    if [ -d "$worktree_codex" ]; then
        git worktree remove --force "$worktree_codex" 2>/dev/null || rm -rf "$worktree_codex"
        info "Removed worktree: $worktree_codex"
    fi

    # Prune worktree references
    git worktree prune

    if $full; then
        # Remove state
        rm -rf "$peer_sync"
        info "Removed .peer-sync"

        # Optionally delete branches
        git branch -D "${feature}-claude" 2>/dev/null && info "Deleted branch: ${feature}-claude" || true
        git branch -D "${feature}-codex" 2>/dev/null && info "Deleted branch: ${feature}-codex" || true
    fi

    success "Cleanup complete"
}

#------------------------------------------------------------------------------
# Command: signal (for agents)
#------------------------------------------------------------------------------

cmd_signal() {
    local agent="$1"
    local status="$2"
    local message="${3:-}"

    [ -z "$agent" ] || [ -z "$status" ] && die "Usage: agent-duo signal <agent> <status> [message]"

    local root
    root="$(get_project_root)"
    local peer_sync="$root/.peer-sync"

    # Validate status
    case "$status" in
        working|done|reviewing|review-done|interrupted|error|pr-created) ;;
        *) die "Invalid status: $status (valid: working, done, reviewing, review-done, interrupted, error, pr-created)" ;;
    esac

    local content="${status}|$(date +%s)|${message}"
    atomic_write "$peer_sync/${agent}.status" "$content"

    success "$agent status: $status"
}

#------------------------------------------------------------------------------
# Command: peer-status (for agents)
#------------------------------------------------------------------------------

cmd_peer_status() {
    local peer="${PEER_NAME:-}"
    [ -z "$peer" ] && die "PEER_NAME not set. Are you in an agent session?"

    local root
    root="$(get_project_root)"
    local peer_sync="$root/.peer-sync"
    local status_file="$peer_sync/${peer}.status"

    if [ -f "$status_file" ]; then
        cat "$status_file"
    else
        echo "unknown"
    fi
}

#------------------------------------------------------------------------------
# Command: phase (for agents)
#------------------------------------------------------------------------------

cmd_phase() {
    local root
    root="$(get_project_root)"
    local peer_sync="$root/.peer-sync"

    if [ -f "$peer_sync/phase" ]; then
        cat "$peer_sync/phase"
    else
        echo "unknown"
    fi
}

#------------------------------------------------------------------------------
# Command: run (orchestrator)
#------------------------------------------------------------------------------

# Default timeouts in seconds
DEFAULT_WORK_TIMEOUT=600    # 10 minutes
DEFAULT_REVIEW_TIMEOUT=300  # 5 minutes
DEFAULT_POLL_INTERVAL=10    # Check every 10 seconds

# Get agent status (just the status part, not timestamp/message)
get_agent_status() {
    local agent="$1"
    local peer_sync="$2"
    local status_file="$peer_sync/${agent}.status"

    if [ -f "$status_file" ]; then
        cut -d'|' -f1 < "$status_file"
    else
        echo "unknown"
    fi
}

# Check if agent has created a PR
has_pr() {
    local agent="$1"
    local peer_sync="$2"
    [ -f "$peer_sync/${agent}.pr" ]
}

# Send interrupt to agent via tmux
interrupt_agent() {
    local agent="$1"
    local session="$2"
    local peer_sync="$3"

    info "Interrupting $agent..."

    # Try Escape first (works for many CLI tools)
    tmux send-keys -t "$session" Escape
    sleep 0.5

    # Then Ctrl-C as backup
    tmux send-keys -t "$session" C-c
    sleep 1

    # Update status
    atomic_write "$peer_sync/${agent}.status" "interrupted|$(date +%s)|timed out by orchestrator"
}

# Send a nudge message to agent
nudge_agent() {
    local agent="$1"
    local session="$2"
    local message="$3"

    info "Nudging $agent: $message"
    tmux send-keys -t "$session" "$message"
    tmux send-keys -t "$session" C-m
}

# Trigger skill for agent
# For Claude: use /skill invocation
# For Codex: send skill content directly (skill invocation unreliable)
trigger_skill() {
    local agent="$1"
    local session="$2"
    local skill="$3"

    case "$agent" in
        claude)
            tmux send-keys -t "$session" -l "/$skill"
            sleep 0.5
            tmux send-keys -t "$session" Enter
            ;;
        codex)
            # Send skill content directly instead of invoking $skill
            local skill_file="$HOME/.codex/skills/$skill/SKILL.md"
            if [ -f "$skill_file" ]; then
                local content
                content="$(cat "$skill_file" | head -c 4000)"
                # Use -- to prevent content with dashes from being interpreted as flags
                tmux send-keys -t "$session" -l -- "$content"
                sleep 0.5
                tmux send-keys -t "$session" Enter
            else
                # Fallback to skill invocation
                tmux send-keys -t "$session" -l -- "\$$skill"
                sleep 0.5
                tmux send-keys -t "$session" Enter
            fi
            ;;
    esac
}

# Generate augmented first-round message with full context
# This replaces the need for /duo-work skill in round 1
generate_round1_message() {
    local agent="$1"
    local peer="$2"
    local feature="$3"
    local task_content="$4"
    local peer_worktree="$5"
    local peer_sync="$6"

    cat <<EOF
# Task: $feature

$task_content

---
## Agent-Duo Context

You are **$agent** in a duo workflow with **$peer** as your peer.
Both of you are developing **alternative solutions** in parallel.

- **Phase**: Work (Round 1)
- **Your worktree**: Current directory (read/write)
- **Peer's worktree**: $peer_worktree (read-only - look but don't touch)
- **Sync directory**: $peer_sync

### Your Goal

Implement your solution independently. Your peer works in parallel on the same task.

### Guidelines

1. **Diverge, don't converge**: Produce an *alternative* solution, not a copy
2. **Different tradeoffs are good**: If peer chose approach A, consider approach B
3. **Read peer's code for insight, not imitation**
4. **Focus on your implementation**: Make progress on your own solution

### Checking Peer's Progress (Optional)

\`\`\`bash
agent-duo peer-status
git -C "$peer_worktree" diff
\`\`\`

### When Done

Signal completion and **STOP**:
\`\`\`bash
agent-duo signal "$agent" done "brief summary of what you did"
\`\`\`

The orchestrator will then trigger the review phase.

### When Ready to Submit Final PR

If your solution is complete:
\`\`\`bash
agent-duo pr "$agent"
\`\`\`
EOF
}

cmd_run() {
    local work_timeout=$DEFAULT_WORK_TIMEOUT
    local review_timeout=$DEFAULT_REVIEW_TIMEOUT
    local poll_interval=$DEFAULT_POLL_INTERVAL
    local max_rounds=10
    local auto_start=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --work-timeout) work_timeout="$2"; shift 2 ;;
            --review-timeout) review_timeout="$2"; shift 2 ;;
            --poll) poll_interval="$2"; shift 2 ;;
            --max-rounds) max_rounds="$2"; shift 2 ;;
            --auto-start) auto_start=true; shift ;;
            -*) die "Unknown option: $1" ;;
            *) die "Unknown argument: $1" ;;
        esac
    done

    local root
    root="$(get_project_root)"
    local peer_sync="$root/.peer-sync"
    local feature
    feature="$(get_feature)"

    # Determine tmux session name
    local session_name="duo-${feature}"

    # Check tmux session exists
    if ! tmux has-session -t "$session_name" 2>/dev/null; then
        # Try ttyd-style separate sessions
        if tmux has-session -t "${session_name}-claude" 2>/dev/null; then
            local claude_session="${session_name}-claude"
            local codex_session="${session_name}-codex"
        else
            die "No tmux session found. Run 'agent-duo start $feature' first."
        fi
    else
        local claude_session="${session_name}:claude"
        local codex_session="${session_name}:codex"
    fi

    echo ""
    echo "=== Agent Duo Orchestrator ==="
    echo "Feature:        $feature"
    echo "Work timeout:   ${work_timeout}s"
    echo "Review timeout: ${review_timeout}s"
    echo "Max rounds:     $max_rounds"
    echo ""

    # Calculate worktree paths for augmented messages
    local project_name
    project_name="$(basename "$root")"
    local parent_dir
    parent_dir="$(dirname "$root")"
    local worktree_claude="$parent_dir/${project_name}-${feature}-claude"
    local worktree_codex="$parent_dir/${project_name}-${feature}-codex"

    # Optionally auto-start agents
    if $auto_start; then
        info "Starting agents..."
        tmux send-keys -t "$claude_session" "$CLAUDE_CMD"
        tmux send-keys -t "$claude_session" C-m
        tmux send-keys -t "$codex_session" "$CODEX_CMD"
        tmux send-keys -t "$codex_session" C-m
        sleep 3
        # Task will be sent as augmented round 1 message below
    fi

    local round=1

    while [ "$round" -le "$max_rounds" ]; do
        # Check if session is complete
        if [ "$(cat "$peer_sync/session" 2>/dev/null)" = "complete" ]; then
            success "Session complete!"
            break
        fi

        # Check if both have PRs
        if has_pr "claude" "$peer_sync" && has_pr "codex" "$peer_sync"; then
            echo "complete" > "$peer_sync/session"
            success "Both PRs created - session complete!"
            echo ""
            echo "Claude PR: $(cat "$peer_sync/claude.pr")"
            echo "Codex PR:  $(cat "$peer_sync/codex.pr")"
            break
        fi

        echo ""
        info "=== Round $round: Work Phase ==="
        echo "$round" > "$peer_sync/round"
        echo "work" > "$peer_sync/phase"

        # Trigger work phase for agents that don't have PRs
        # Round 1: Send augmented message with full context (avoids skill race condition)
        # Round 2+: Trigger duo-work skill (agent already has context)
        if [ "$round" -eq 1 ]; then
            # Round 1: Send augmented task with full context
            local task_file
            local task_content=""
            if task_file="$(find_task_file "$root" "$feature")"; then
                task_content="$(cat "$task_file" | head -c 4000)"
            fi

            if ! has_pr "claude" "$peer_sync"; then
                atomic_write "$peer_sync/claude.status" "working|$(date +%s)|round $round work phase"
                info "Sending augmented task to claude..."
                local claude_msg
                claude_msg="$(generate_round1_message "claude" "codex" "$feature" "$task_content" "$worktree_codex" "$peer_sync")"
                tmux send-keys -t "$claude_session" "$claude_msg"
                sleep 0.5
                tmux send-keys -t "$claude_session" C-m
            fi
            if ! has_pr "codex" "$peer_sync"; then
                atomic_write "$peer_sync/codex.status" "working|$(date +%s)|round $round work phase"
                info "Sending augmented task to codex..."
                local codex_msg
                codex_msg="$(generate_round1_message "codex" "claude" "$feature" "$task_content" "$worktree_claude" "$peer_sync")"
                tmux send-keys -t "$codex_session" "$codex_msg"
                sleep 0.5
                tmux send-keys -t "$codex_session" C-m
            fi
        else
            # Round 2+: Trigger skill (agent already knows the context)
            # Reset status to working before triggering (in case agent doesn't signal)
            if ! has_pr "claude" "$peer_sync"; then
                atomic_write "$peer_sync/claude.status" "working|$(date +%s)|round $round work phase"
                info "Triggering duo-work for claude..."
                trigger_skill "claude" "$claude_session" "duo-work"
            fi
            if ! has_pr "codex" "$peer_sync"; then
                atomic_write "$peer_sync/codex.status" "working|$(date +%s)|round $round work phase"
                info "Triggering duo-work for codex..."
                trigger_skill "codex" "$codex_session" "duo-work"
            fi
        fi

        # Wait for work phase completion with timeout
        local work_start=$SECONDS
        local claude_done=false
        local codex_done=false

        # Skip agents that already have PRs
        has_pr "claude" "$peer_sync" && claude_done=true
        has_pr "codex" "$peer_sync" && codex_done=true

        while ! ($claude_done && $codex_done); do
            local elapsed=$((SECONDS - work_start))

            # Check for completion
            local claude_status
            claude_status="$(get_agent_status "claude" "$peer_sync")"
            local codex_status
            codex_status="$(get_agent_status "codex" "$peer_sync")"

            # Accept done, review-done (agent jumped ahead), or pr-created
            [[ "$claude_status" =~ ^(done|review-done|pr-created)$ ]] && claude_done=true
            [[ "$codex_status" =~ ^(done|review-done|pr-created)$ ]] && codex_done=true

            # Check for PRs created mid-phase
            has_pr "claude" "$peer_sync" && claude_done=true
            has_pr "codex" "$peer_sync" && codex_done=true

            if $claude_done && $codex_done; then
                break
            fi

            # Check timeout
            if [ "$elapsed" -ge "$work_timeout" ]; then
                warn "Work phase timeout (${work_timeout}s)"

                # Interrupt agents that aren't done
                if ! $claude_done; then
                    interrupt_agent "claude" "$claude_session" "$peer_sync"
                    claude_done=true
                fi
                if ! $codex_done; then
                    interrupt_agent "codex" "$codex_session" "$peer_sync"
                    codex_done=true
                fi
                break
            fi

            printf "\r  Waiting... claude=%s codex=%s (%ds/%ds)  " "$claude_status" "$codex_status" "$elapsed" "$work_timeout"
            sleep "$poll_interval"
        done
        echo ""

        # Check again if both have PRs (might have been created during work)
        if has_pr "claude" "$peer_sync" && has_pr "codex" "$peer_sync"; then
            echo "complete" > "$peer_sync/session"
            success "Both PRs created - session complete!"
            break
        fi

        # Review phase
        info "=== Round $round: Review Phase ==="
        echo "review" > "$peer_sync/phase"

        # Trigger review phase
        # Reset status to reviewing before triggering (in case agent doesn't signal)
        if ! has_pr "claude" "$peer_sync"; then
            atomic_write "$peer_sync/claude.status" "reviewing|$(date +%s)|round $round review phase"
            info "Triggering duo-review for claude..."
            trigger_skill "claude" "$claude_session" "duo-review"
        fi
        if ! has_pr "codex" "$peer_sync"; then
            atomic_write "$peer_sync/codex.status" "reviewing|$(date +%s)|round $round review phase"
            info "Triggering duo-review for codex..."
            trigger_skill "codex" "$codex_session" "duo-review"
        fi

        # Wait for review phase completion with timeout
        local review_start=$SECONDS
        claude_done=false
        codex_done=false

        has_pr "claude" "$peer_sync" && claude_done=true
        has_pr "codex" "$peer_sync" && codex_done=true

        while ! ($claude_done && $codex_done); do
            local elapsed=$((SECONDS - review_start))

            local claude_status
            claude_status="$(get_agent_status "claude" "$peer_sync")"
            local codex_status
            codex_status="$(get_agent_status "codex" "$peer_sync")"

            # Accept review-done, done (agent skipped review), or pr-created
            [[ "$claude_status" =~ ^(done|review-done|pr-created)$ ]] && claude_done=true
            [[ "$codex_status" =~ ^(done|review-done|pr-created)$ ]] && codex_done=true

            has_pr "claude" "$peer_sync" && claude_done=true
            has_pr "codex" "$peer_sync" && codex_done=true

            if $claude_done && $codex_done; then
                break
            fi

            # Check timeout
            if [ "$elapsed" -ge "$review_timeout" ]; then
                warn "Review phase timeout (${review_timeout}s)"

                if ! $claude_done; then
                    interrupt_agent "claude" "$claude_session" "$peer_sync"
                    claude_done=true
                fi
                if ! $codex_done; then
                    interrupt_agent "codex" "$codex_session" "$peer_sync"
                    codex_done=true
                fi
                break
            fi

            printf "\r  Waiting... claude=%s codex=%s (%ds/%ds)  " "$claude_status" "$codex_status" "$elapsed" "$review_timeout"
            sleep "$poll_interval"
        done
        echo ""

        round=$((round + 1))
    done

    if [ "$round" -gt "$max_rounds" ]; then
        warn "Reached max rounds ($max_rounds)"
    fi

    echo ""
    info "=== Final Status ==="
    cmd_status
}

#------------------------------------------------------------------------------
# Command: nudge
#------------------------------------------------------------------------------

cmd_nudge() {
    local agent="$1"
    local message="${2:-Continue.}"

    [ -z "$agent" ] && die "Usage: agent-duo nudge <agent> [message]"

    local root
    root="$(get_project_root)"
    local feature
    feature="$(get_feature)"
    local session_name="duo-${feature}"

    # Determine session target
    local session
    if tmux has-session -t "$session_name" 2>/dev/null; then
        session="${session_name}:${agent}"
    elif tmux has-session -t "${session_name}-${agent}" 2>/dev/null; then
        session="${session_name}-${agent}"
    else
        die "No tmux session found for $agent"
    fi

    nudge_agent "$agent" "$session" "$message"
    success "Nudged $agent"
}

#------------------------------------------------------------------------------
# Command: interrupt
#------------------------------------------------------------------------------

cmd_interrupt() {
    local agent="$1"

    [ -z "$agent" ] && die "Usage: agent-duo interrupt <agent>"

    local root
    root="$(get_project_root)"
    local peer_sync="$root/.peer-sync"
    local feature
    feature="$(get_feature)"
    local session_name="duo-${feature}"

    # Determine session target
    local session
    if tmux has-session -t "$session_name" 2>/dev/null; then
        session="${session_name}:${agent}"
    elif tmux has-session -t "${session_name}-${agent}" 2>/dev/null; then
        session="${session_name}-${agent}"
    else
        die "No tmux session found for $agent"
    fi

    interrupt_agent "$agent" "$session" "$peer_sync"
    success "Interrupted $agent"
}

#------------------------------------------------------------------------------
# Command: help
#------------------------------------------------------------------------------

cmd_help() {
    cat << 'EOF'
Agent Duo - Coordinate two AI coding agents

USAGE
    agent-duo <command> [options]

SESSION COMMANDS
    start <feature> [options]
        Start a new session for the given feature.
        Creates worktrees, tmux sessions, and ttyd web terminals.
        Looks for task description in: <feature>.md, doc/<feature>.md,
        docs/<feature>.md, or **/<feature>.md (anywhere in project).

        Options:
          --auto-run               Start orchestrator immediately in its own terminal
          --no-ttyd                Use single tmux session instead of web terminals
          --work-timeout <secs>    Work phase timeout (default: 600, with --auto-run)
          --review-timeout <secs>  Review phase timeout (default: 300, with --auto-run)
          --max-rounds <n>         Maximum rounds (default: 10, with --auto-run)

        With ttyd (default): Creates 3 web terminals at ports 7680-7682
          - Orchestrator (7680): Main project root
          - Claude (7681): Claude's worktree
          - Codex (7682): Codex's worktree

        With --no-ttyd: Creates single tmux session with 3 windows

    run [options]
        Run the orchestrator loop (work -> review -> work...).
        Automatically manages phase transitions and timeouts.
        Not needed if using 'start --auto-run'.

        Options:
          --work-timeout <secs>    Work phase timeout (default: 600)
          --review-timeout <secs>  Review phase timeout (default: 300)
          --poll <secs>            Status poll interval (default: 10)
          --max-rounds <n>         Maximum rounds (default: 10)
          --auto-start             Auto-launch agent CLIs and send task

    stop
        Stop ttyd servers and tmux sessions, keep worktrees.

    status
        Show current session state, agent statuses, and PRs.

    pr <agent>
        Create a PR for the specified agent (claude or codex).
        Auto-commits uncommitted changes and pushes.

    cleanup [--full]
        Remove worktrees. With --full, also removes .peer-sync
        and deletes the feature branches.

    setup
        Install agent-duo to ~/.local/bin and skills to agent dirs.

CONTROL COMMANDS
    nudge <agent> [message]
        Send a message to an agent's terminal.
        Default message: "Continue."

    interrupt <agent>
        Send Escape + Ctrl-C to interrupt an agent and mark as interrupted.

AGENT COMMANDS (used by AI agents)
    signal <agent> <status> [message]
        Signal a status change. Status values:
        working, done, reviewing, review-done, interrupted, error, pr-created

    peer-status
        Read peer's current status (requires PEER_NAME env var).

    phase
        Read current phase (work or review).

ENVIRONMENT VARIABLES (set in agent sessions)
    PEER_SYNC       Path to .peer-sync directory
    MY_NAME         This agent's name (claude or codex)
    PEER_NAME       Other agent's name
    PEER_WORKTREE   Path to peer's worktree
    FEATURE         Feature name

EXAMPLES
    # Recommended: start with auto-run (opens 3 web terminals, starts everything)
    agent-duo start auth --auto-run

    # Alternative: start manually then run orchestrator
    agent-duo start auth
    agent-duo run --auto-start

    # Use tmux instead of web terminals
    agent-duo start auth --no-ttyd
    tmux attach -t duo-auth
    # Then run: agent-duo run --auto-start

    # Nudge a stuck agent
    agent-duo nudge claude "Please continue with the implementation."

    # Check status
    agent-duo status

    # Create PR when done
    agent-duo pr claude

    # Clean up
    agent-duo cleanup --full
EOF
}

#------------------------------------------------------------------------------
# Main
#------------------------------------------------------------------------------

main() {
    local cmd="${1:-help}"
    shift || true

    case "$cmd" in
        start)       cmd_start "$@" ;;
        run)         cmd_run "$@" ;;
        stop)        cmd_stop "$@" ;;
        status)      cmd_status "$@" ;;
        pr)          cmd_pr "$@" ;;
        cleanup)     cmd_cleanup "$@" ;;
        setup)       cmd_setup "$@" ;;
        nudge)       cmd_nudge "$@" ;;
        interrupt)   cmd_interrupt "$@" ;;
        signal)      cmd_signal "$@" ;;
        peer-status) cmd_peer_status "$@" ;;
        phase)       cmd_phase "$@" ;;
        help|--help|-h) cmd_help ;;
        *)           die "Unknown command: $cmd (try 'agent-duo help')" ;;
    esac
}

main "$@"
