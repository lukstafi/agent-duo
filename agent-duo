#!/bin/bash
# agent-duo - Coordinate two AI coding agents working in parallel
#
# Usage: agent-duo <command> [options]
#
# Session Commands:
#   start <feature> [--auto-run] [--no-ttyd] [--clarify]  Start session
#   run [options]        Run orchestrator loop with timeouts
#                        --on-tui-exit=pause|quit|ignore  TUI exit behavior
#   stop                 Stop ttyd servers, keep worktrees
#   restart [--auto-run] Restart session after system restart/crash
#   status               Show session state
#   confirm              Confirm clarify phase completion (proceed to work)
#   pr <agent>           Create PR for agent's solution
#   cleanup [--full]     Remove worktrees (--full: also state)
#   setup                Install agent-duo to PATH and skills
#   doctor [--send-email|--send-ntfy]  Check system health and configuration
#   config <key> [value] Get/set configuration (e.g., ntfy_topic)
#
# Control Commands:
#   nudge <agent> [msg]  Send message to agent terminal
#   interrupt <agent>    Interrupt agent (Esc + Ctrl-C)
#
# Agent Commands:
#   signal <agent> <status> [message]   Signal status change
#   peer-status                         Read peer's status
#   phase                               Read current phase

set -e

# Determine script location (resolves symlinks)
SCRIPT_PATH="${BASH_SOURCE[0]}"
while [ -L "$SCRIPT_PATH" ]; do
    SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
    SCRIPT_PATH="$(readlink "$SCRIPT_PATH")"
    [[ $SCRIPT_PATH != /* ]] && SCRIPT_PATH="$SCRIPT_DIR/$SCRIPT_PATH"
done
SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"

# Source shared library
if [ -f "$SCRIPT_DIR/agent-lib.sh" ]; then
    # shellcheck source=agent-lib.sh
    source "$SCRIPT_DIR/agent-lib.sh"
elif [ -f "$HOME/.local/bin/agent-lib.sh" ]; then
    # shellcheck source=agent-lib.sh
    source "$HOME/.local/bin/agent-lib.sh"
else
    echo "Error: agent-lib.sh not found" >&2
    exit 1
fi

# Default agents for duo mode
DEFAULT_AGENT_A="claude"
DEFAULT_AGENT_B="codex"

# Allocate ports for a session and store in .peer-sync/ports
allocate_ports() {
    local peer_sync="$1"
    local ports_file="$peer_sync/ports"

    # If ports already allocated, return
    if [ -f "$ports_file" ]; then
        return 0
    fi

    local base=$DEFAULT_BASE_PORT
    local orchestrator_port claude_port codex_port

    orchestrator_port="$(find_available_port "$base")" || die "Could not find available port for orchestrator"
    claude_port="$(find_available_port "$((orchestrator_port + 1))")" || die "Could not find available port for claude"
    codex_port="$(find_available_port "$((claude_port + 1))")" || die "Could not find available port for codex"

    cat > "$ports_file" << EOF
ORCHESTRATOR_PORT=$orchestrator_port
CLAUDE_PORT=$claude_port
CODEX_PORT=$codex_port
EOF
}

# Note: get_ports, tmux_session_exists, ttyd_is_running, is_port_in_use,
# agent_tui_is_running, restart_ttyd_for_session, restart_agent_tui, and
# find_task_file are all provided by agent-lib.sh

#------------------------------------------------------------------------------
# Command: setup
#------------------------------------------------------------------------------

# Install a skill from template with agent-specific replacements
install_skill() {
    local template="$1"
    local dest="$2"
    local skill_cmd="$3"  # e.g., "/duo-work" for Claude, "$duo-work" for Codex

    if [ -f "$template" ]; then
        # Replace {{SKILL_CMD}} placeholder with agent-specific command prefix
        sed "s|{{SKILL_CMD}}|${skill_cmd}|g" "$template" > "$dest"
    fi
}

cmd_setup() {
    info "Installing agent-duo..."

    local templates_dir="$SCRIPT_DIR/skills/templates"

    if [ ! -d "$templates_dir" ]; then
        die "Skills templates not found at $templates_dir"
    fi

    # Install CLI to ~/.local/bin
    local install_dir="$HOME/.local/bin"
    mkdir -p "$install_dir"

    local install_path="$install_dir/agent-duo"
    if [ "$SCRIPT_DIR/agent-duo" != "$install_path" ]; then
        cp "$SCRIPT_DIR/agent-duo" "$install_path"
        chmod +x "$install_path"
        success "Installed agent-duo to $install_path"
    else
        success "agent-duo already installed at $install_path"
    fi

    # Install shared library
    local lib_path="$install_dir/agent-lib.sh"
    if [ -f "$SCRIPT_DIR/agent-lib.sh" ]; then
        cp "$SCRIPT_DIR/agent-lib.sh" "$lib_path"
        success "Installed agent-lib.sh to $lib_path"
    fi

    # Copy skills/templates to install dir so setup works from installed location
    local installed_templates="$install_dir/skills/templates"
    if [ "$templates_dir" != "$installed_templates" ]; then
        mkdir -p "$installed_templates"
        cp -r "$templates_dir"/* "$installed_templates/"
        success "Installed skill templates to $installed_templates"
    fi

    # Check if ~/.local/bin is in PATH
    if [[ ":$PATH:" != *":$install_dir:"* ]]; then
        warn "Add $install_dir to your PATH:"
        echo "  export PATH=\"\$HOME/.local/bin:\$PATH\""
    fi

    # Install Claude skills (uses /command syntax)
    local claude_skills="$HOME/.claude/commands"
    mkdir -p "$claude_skills"

    install_skill "$templates_dir/duo-work.md" "$claude_skills/duo-work.md" "/duo-work"
    install_skill "$templates_dir/duo-review.md" "$claude_skills/duo-review.md" "/duo-review"
    install_skill "$templates_dir/duo-clarify.md" "$claude_skills/duo-clarify.md" "/duo-clarify"
    success "Installed Claude skills to $claude_skills"

    # Install Codex skills (uses $command syntax)
    # Codex expects skills as directories with SKILL.md inside
    local codex_skills="$HOME/.codex/skills"
    mkdir -p "$codex_skills/duo-work" "$codex_skills/duo-review" "$codex_skills/duo-clarify"

    install_skill "$templates_dir/duo-work.md" "$codex_skills/duo-work/SKILL.md" "\$duo-work"
    install_skill "$templates_dir/duo-review.md" "$codex_skills/duo-review/SKILL.md" "\$duo-review"
    install_skill "$templates_dir/duo-clarify.md" "$codex_skills/duo-clarify/SKILL.md" "\$duo-clarify"
    success "Installed Codex skills to $codex_skills"

    # Install shared notify hook script for both agents
    # Called when agent completes a turn to auto-signal status
    local notify_script="$install_dir/agent-duo-notify"
    cat > "$notify_script" << 'NOTIFY_EOF'
#!/bin/bash
# Called by agent hooks when they complete a turn
# Signals the appropriate status based on current phase
# Usage: agent-duo-notify <agent-name>
#   Agent name is required as $1 (passed via hook configuration)
#   PEER_SYNC is discovered from $PWD/.peer-sync symlink

agent="$1"
[ -z "$agent" ] && exit 0

# Discover PEER_SYNC from working directory (worktrees have .peer-sync symlink)
if [ -z "$PEER_SYNC" ]; then
    if [ -d "$PWD/.peer-sync" ]; then
        PEER_SYNC="$PWD/.peer-sync"
    else
        exit 0
    fi
fi
[ ! -d "$PEER_SYNC" ] && exit 0

# Read current phase
phase="$(cat "$PEER_SYNC/phase" 2>/dev/null)" || exit 0

# Read current status
current_status="$(cut -d'|' -f1 < "$PEER_SYNC/${agent}.status" 2>/dev/null)"

# Determine what status to signal based on phase
case "$phase" in
    clarify)
        # Don't override if already clarify-done or beyond
        case "$current_status" in
            clarify-done|done|review-done|pr-created) exit 0 ;;
        esac
        agent-duo signal "$agent" clarify-done "completed via hook"
        ;;
    work)
        # Don't override if already done or beyond
        case "$current_status" in
            done|review-done|pr-created) exit 0 ;;
        esac
        agent-duo signal "$agent" done "completed via hook"
        ;;
    review)
        # Don't override if already review-done or beyond
        case "$current_status" in
            review-done|pr-created) exit 0 ;;
        esac
        agent-duo signal "$agent" review-done "completed via hook"
        ;;
esac
NOTIFY_EOF
    chmod +x "$notify_script"
    success "Installed notify hook script to $notify_script"

    # Configure Codex to use the notify hook (with "codex" as agent name argument)
    local codex_config="$HOME/.codex/config.toml"
    if [ -f "$codex_config" ]; then
        if grep -q "^notify" "$codex_config"; then
            warn "Codex config already has 'notify' setting - not overwriting"
            warn "To enable auto-signaling, set: notify = [\"$notify_script\", \"codex\"]"
        else
            echo "" >> "$codex_config"
            echo "# Agent-duo notify hook for auto-signaling completion" >> "$codex_config"
            echo "notify = [\"$notify_script\", \"codex\"]" >> "$codex_config"
            success "Added notify hook to Codex config"
        fi
    else
        mkdir -p "$(dirname "$codex_config")"
        echo "# Agent-duo notify hook for auto-signaling completion" > "$codex_config"
        echo "notify = [\"$notify_script\", \"codex\"]" >> "$codex_config"
        success "Created Codex config with notify hook"
    fi

    # Configure Claude to use the Stop hook (with "claude" as agent name argument)
    local claude_settings="$HOME/.claude/settings.json"
    local hook_config="{\"Stop\":[{\"hooks\":[{\"type\":\"command\",\"command\":\"$notify_script claude\"}]}]}"

    if [ -f "$claude_settings" ]; then
        # Check if hooks already configured
        if grep -q '"hooks"' "$claude_settings"; then
            warn "Claude settings already has 'hooks' - not overwriting"
            warn "To enable auto-signaling, add Stop hook: $notify_script claude"
        else
            # Add hooks to existing settings using a temp file approach
            # Remove trailing } and add hooks
            local tmp_settings
            tmp_settings="$(mktemp)"
            # Use Python/jq if available, otherwise simple sed
            if command -v jq >/dev/null 2>&1; then
                jq --arg cmd "$notify_script claude" '.hooks = {"Stop":[{"hooks":[{"type":"command","command":$cmd}]}]}' "$claude_settings" > "$tmp_settings"
                mv "$tmp_settings" "$claude_settings"
                success "Added Stop hook to Claude settings"
            else
                warn "jq not found - please manually add hooks to $claude_settings:"
                echo "  \"hooks\": $hook_config"
            fi
        fi
    else
        mkdir -p "$(dirname "$claude_settings")"
        echo "{\"hooks\":$hook_config}" > "$claude_settings"
        success "Created Claude settings with Stop hook"
    fi

    success "Setup complete!"
}

#------------------------------------------------------------------------------
# Command: doctor
#------------------------------------------------------------------------------

cmd_doctor() {
    local all_ok=true
    local send_test_email=false
    local send_test_ntfy=false

    # Parse arguments
    while [ $# -gt 0 ]; do
        case "$1" in
            --send-email) send_test_email=true ;;
            --send-ntfy) send_test_ntfy=true ;;
            *) die "Unknown option: $1" ;;
        esac
        shift
    done

    info "Running health checks..."
    echo ""

    # --- Required Tools ---
    echo "=== Required Tools ==="

    # git
    if command -v git >/dev/null 2>&1; then
        success "git: $(git --version | head -1)"
    else
        warn "git: NOT FOUND (required)"
        all_ok=false
    fi

    # tmux
    if command -v tmux >/dev/null 2>&1; then
        success "tmux: $(tmux -V)"
    else
        warn "tmux: NOT FOUND (required)"
        all_ok=false
    fi

    # ttyd (optional but recommended)
    if command -v ttyd >/dev/null 2>&1; then
        success "ttyd: $(ttyd --version 2>&1 | head -1)"
    else
        warn "ttyd: NOT FOUND (optional - use --no-ttyd flag without it)"
    fi

    # jq (optional but helpful)
    if command -v jq >/dev/null 2>&1; then
        success "jq: $(jq --version)"
    else
        warn "jq: NOT FOUND (optional - used for JSON config manipulation)"
    fi

    echo ""

    # --- AI Agent CLIs ---
    echo "=== AI Agent CLIs ==="

    # claude
    if command -v claude >/dev/null 2>&1; then
        success "claude: found at $(command -v claude)"
    else
        warn "claude: NOT FOUND"
        warn "  Install: npm install -g @anthropic-ai/claude-code"
        all_ok=false
    fi

    # codex
    if command -v codex >/dev/null 2>&1; then
        success "codex: found at $(command -v codex)"
    else
        warn "codex: NOT FOUND"
        warn "  Install: npm install -g @openai/codex"
        all_ok=false
    fi

    echo ""

    # --- Git Configuration ---
    echo "=== Git Configuration ==="

    local git_name git_email
    git_name="$(git config user.name 2>/dev/null || true)"
    git_email="$(git config user.email 2>/dev/null || true)"

    if [ -n "$git_name" ]; then
        success "git user.name: $git_name"
    else
        warn "git user.name: NOT SET"
        warn "  Run: git config --global user.name \"Your Name\""
        all_ok=false
    fi

    if [ -n "$git_email" ]; then
        success "git user.email: $git_email"
    else
        warn "git user.email: NOT SET (required for email notifications)"
        warn "  Run: git config --global user.email \"you@example.com\""
        all_ok=false
    fi

    echo ""

    # --- Email Setup ---
    echo "=== Email Notifications ==="

    local email_likely_works=false

    if command -v mail >/dev/null 2>&1; then
        success "mail command: found at $(command -v mail)"

        # Check if email delivery is likely to work
        local mail_warning=""

        # Check for running mail daemon (postfix, sendmail, etc.)
        if ! pgrep -x "master" >/dev/null 2>&1 && ! pgrep -x "sendmail" >/dev/null 2>&1; then
            # No mail daemon running - check if msmtp is configured as sendmail
            if command -v msmtp >/dev/null 2>&1; then
                # msmtp found - check if it's linked as sendmail
                local sendmail_path
                sendmail_path="$(command -v sendmail 2>/dev/null || true)"
                if [ -n "$sendmail_path" ] && readlink "$sendmail_path" 2>/dev/null | grep -q msmtp; then
                    success "msmtp: configured as sendmail relay"
                    email_likely_works=true
                elif [ -f "$HOME/.msmtprc" ]; then
                    success "msmtp: found with config"
                    info "  Tip: link msmtp as sendmail for mail command to use it"
                    email_likely_works=true
                else
                    warn "msmtp: found but not configured (~/.msmtprc missing)"
                fi
            else
                mail_warning="no mail daemon running"
            fi
        else
            success "Mail daemon: running"
            email_likely_works=true
        fi

        # On macOS, warn about common postfix issue
        if [ "$(uname)" = "Darwin" ] && [ "$email_likely_works" = false ]; then
            warn "macOS mail issue: $mail_warning"
            warn "  The 'mail' command will appear to succeed but emails won't deliver."
            warn "  Fix options:"
            warn "    1. Install msmtp: brew install msmtp"
            warn "       Configure ~/.msmtprc with SMTP relay (e.g., Gmail app password)"
            warn "    2. Start postfix: sudo postfix start (temporary)"
            warn "    3. Use a webhook notification service instead"
        elif [ "$email_likely_works" = false ]; then
            warn "Mail delivery issue: $mail_warning"
            warn "  Emails may not be delivered. Check your MTA configuration."
        fi

        if [ "$send_test_email" = true ]; then
            if [ -n "$git_email" ]; then
                info "Sending test email to $git_email..."
                local test_body="This is a test email from agent-duo doctor.

If you received this, your email configuration is working correctly.

Sent: $(date)"
                if echo "$test_body" | mail -s "[agent-duo] Test email from doctor" "$git_email" 2>/dev/null; then
                    if [ "$email_likely_works" = true ]; then
                        success "Test email sent to $git_email"
                        info "  Check your inbox (and spam folder)"
                    else
                        warn "Test email queued to $git_email (but delivery unlikely)"
                        warn "  The mail command succeeded, but without a working MTA,"
                        warn "  the email is probably sitting in a local queue."
                    fi
                else
                    warn "Failed to send test email"
                    warn "  Your mail system may not be configured correctly"
                fi
            else
                warn "Cannot send test email: git user.email not configured"
            fi
        else
            info "  Use --send-email to send a test email"
        fi
    else
        warn "mail command: NOT FOUND"
        warn "  Email notifications will not work"
        warn "  Install: mailutils (Linux) or configure msmtp (macOS)"
    fi

    echo ""

    # --- ntfy.sh Setup ---
    echo "=== ntfy.sh Notifications ==="

    local ntfy_topic
    ntfy_topic="$(get_ntfy_topic 2>/dev/null || true)"

    if [ -n "$ntfy_topic" ]; then
        success "ntfy topic: $ntfy_topic"
        local ntfy_server
        ntfy_server="$(get_ntfy_server)"
        info "  Server: $ntfy_server"

        # Check for token
        local ntfy_token
        if ntfy_token="$(get_ntfy_token 2>/dev/null)"; then
            success "ntfy token: ${ntfy_token:0:6}...${ntfy_token: -4} (authenticated)"
        else
            info "  Token: not set (using anonymous access)"
        fi

        if [ "$send_test_ntfy" = true ]; then
            info "Sending test notification..."
            if send_ntfy "agent-duo test" "This is a test notification from agent-duo doctor. Sent: $(date)" "default" "white_check_mark"; then
                success "Test notification sent to $ntfy_server/$ntfy_topic"
            else
                warn "Failed to send test notification"
                warn "  Check your internet connection, topic name, and token"
            fi
        else
            info "  Use --send-ntfy to send a test notification"
        fi
    else
        info "ntfy: not configured (optional)"
        info "  Configure with: agent-duo config ntfy_topic <your-topic>"
        info "  ntfy.sh is a free push notification service"
        info "  Subscribe at: https://ntfy.sh/<your-topic>"
    fi

    echo ""

    # --- Skills Installation ---
    echo "=== Skills Installation ==="

    # Claude skills
    local claude_skills="$HOME/.claude/commands"
    local claude_skills_ok=true
    for skill in duo-work duo-review duo-clarify; do
        if [ -f "$claude_skills/$skill.md" ]; then
            success "Claude skill: $skill"
        else
            warn "Claude skill: $skill NOT FOUND"
            claude_skills_ok=false
        fi
    done
    if [ "$claude_skills_ok" = false ]; then
        warn "  Run: agent-duo setup"
        all_ok=false
    fi

    # Codex skills
    local codex_skills="$HOME/.codex/skills"
    local codex_skills_ok=true
    for skill in duo-work duo-review duo-clarify; do
        if [ -f "$codex_skills/$skill/SKILL.md" ]; then
            success "Codex skill: $skill"
        else
            warn "Codex skill: $skill NOT FOUND"
            codex_skills_ok=false
        fi
    done
    if [ "$codex_skills_ok" = false ]; then
        warn "  Run: agent-duo setup"
        all_ok=false
    fi

    echo ""

    # --- Hook Configuration ---
    echo "=== Hook Configuration ==="

    local notify_script="$HOME/.local/bin/agent-duo-notify"
    if [ -x "$notify_script" ]; then
        success "Notify script: $notify_script"
    else
        warn "Notify script: NOT FOUND or not executable"
        warn "  Run: agent-duo setup"
        all_ok=false
    fi

    # Check Claude hooks
    local claude_settings="$HOME/.claude/settings.json"
    if [ -f "$claude_settings" ]; then
        if grep -q "agent-duo-notify" "$claude_settings" 2>/dev/null; then
            success "Claude hooks: configured"
        else
            warn "Claude hooks: not configured for agent-duo"
            warn "  Run: agent-duo setup"
        fi
    else
        warn "Claude settings: $claude_settings not found"
    fi

    # Check Codex hooks
    local codex_config="$HOME/.codex/config.toml"
    if [ -f "$codex_config" ]; then
        if grep -q "agent-duo-notify" "$codex_config" 2>/dev/null; then
            success "Codex hooks: configured"
        else
            warn "Codex hooks: not configured for agent-duo"
            warn "  Run: agent-duo setup"
        fi
    else
        warn "Codex config: $codex_config not found"
    fi

    echo ""

    # --- PATH Check ---
    echo "=== PATH Configuration ==="

    local install_dir="$HOME/.local/bin"
    if [[ ":$PATH:" == *":$install_dir:"* ]]; then
        success "~/.local/bin is in PATH"
    else
        warn "~/.local/bin is NOT in PATH"
        warn "  Add to your shell profile:"
        warn "  export PATH=\"\$HOME/.local/bin:\$PATH\""
        all_ok=false
    fi

    # Check if agent-duo is accessible
    if command -v agent-duo >/dev/null 2>&1; then
        success "agent-duo: found at $(command -v agent-duo)"
    else
        warn "agent-duo: not found in PATH"
        warn "  Run: agent-duo setup"
        all_ok=false
    fi

    echo ""

    # --- Summary ---
    echo "=== Summary ==="
    if [ "$all_ok" = true ]; then
        success "All checks passed!"
    else
        warn "Some issues found - see above for details"
        return 1
    fi
}

#------------------------------------------------------------------------------
# Command: config
#------------------------------------------------------------------------------

cmd_config() {
    local config_dir="$HOME/.config/agent-duo"
    local config_file="$config_dir/config"

    # List all config if no arguments
    if [ $# -eq 0 ]; then
        info "Configuration file: $config_file"
        echo ""
        if [ -f "$config_file" ]; then
            # Display config with token masked
            while IFS= read -r line; do
                if [[ "$line" =~ ^ntfy_token= ]]; then
                    local token="${line#ntfy_token=}"
                    echo "ntfy_token=${token:0:6}...${token: -4}"
                else
                    echo "$line"
                fi
            done < "$config_file"
        else
            info "No configuration set"
        fi
        echo ""
        info "Available settings:"
        echo "  ntfy_topic   - ntfy.sh topic for push notifications"
        echo "  ntfy_token   - ntfy.sh access token (for reserved topics)"
        echo "  ntfy_server  - ntfy server URL (default: https://ntfy.sh)"
        echo ""
        info "Usage: agent-duo config <key> [value]"
        return 0
    fi

    local key="$1"
    local value="${2:-}"

    # Validate key
    case "$key" in
        ntfy_topic|ntfy_token|ntfy_server)
            ;;
        *)
            die "Unknown config key: $key (valid: ntfy_topic, ntfy_token, ntfy_server)"
            ;;
    esac

    # Get value if not setting
    if [ -z "$value" ]; then
        if [ -f "$config_file" ]; then
            local current
            current="$(grep -E "^${key}=" "$config_file" 2>/dev/null | cut -d= -f2-)"
            if [ -n "$current" ]; then
                # Mask token for security
                if [ "$key" = "ntfy_token" ]; then
                    echo "${current:0:6}...${current: -4}"
                else
                    echo "$current"
                fi
            else
                info "$key is not set"
                return 1
            fi
        else
            info "$key is not set"
            return 1
        fi
        return 0
    fi

    # Set value
    mkdir -p "$config_dir"

    if [ -f "$config_file" ]; then
        # Remove existing key if present
        grep -v "^${key}=" "$config_file" > "$config_file.tmp" 2>/dev/null || true
        mv "$config_file.tmp" "$config_file"
    fi

    # Add new value
    echo "${key}=${value}" >> "$config_file"

    # Mask token in success message
    if [ "$key" = "ntfy_token" ]; then
        success "Set $key=${value:0:6}...${value: -4}"
    else
        success "Set $key=$value"
    fi

    # Show helpful info based on key
    case "$key" in
        ntfy_topic)
            local server
            server="$(get_ntfy_server)"
            echo ""
            info "To receive notifications:"
            echo "  1. Install ntfy app on your phone (iOS/Android)"
            echo "  2. Subscribe to topic: $value"
            echo "  3. Or open in browser: $server/$value"
            echo ""
            info "Test with: agent-duo doctor --send-ntfy"
            ;;
        ntfy_token)
            echo ""
            info "Token configured for authenticated access."
            info "Test with: agent-duo doctor --send-ntfy"
            ;;
    esac
}

#------------------------------------------------------------------------------
# Command: start
#------------------------------------------------------------------------------

cmd_start() {
    local feature=""
    local ttyd_mode=true
    local auto_run=false
    local clarify_mode=false
    local work_timeout=$DEFAULT_WORK_TIMEOUT
    local review_timeout=$DEFAULT_REVIEW_TIMEOUT
    local clarify_timeout=$DEFAULT_CLARIFY_TIMEOUT
    local max_rounds=10
    local codex_thinking=$DEFAULT_CODEX_THINKING

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --no-ttyd) ttyd_mode=false; shift ;;
            --auto-run) auto_run=true; shift ;;
            --clarify) clarify_mode=true; shift ;;
            --work-timeout) work_timeout="$2"; shift 2 ;;
            --review-timeout) review_timeout="$2"; shift 2 ;;
            --clarify-timeout) clarify_timeout="$2"; shift 2 ;;
            --max-rounds) max_rounds="$2"; shift 2 ;;
            --codex-thinking) codex_thinking="$2"; shift 2 ;;
            -*) die "Unknown option: $1" ;;
            *) feature="$1"; shift ;;
        esac
    done

    [ -z "$feature" ] && die "Usage: agent-duo start <feature> [--no-ttyd] [--auto-run] [--clarify]"

    # Validate codex thinking effort
    case "$codex_thinking" in
        low|medium|high) ;;
        *) die "Invalid --codex-thinking value: $codex_thinking (valid: low, medium, high)" ;;
    esac

    # Ensure we're in a git repo
    git rev-parse --is-inside-work-tree >/dev/null 2>&1 || die "Not a git repository"

    # Ensure repo has at least one commit
    git rev-parse HEAD >/dev/null 2>&1 || die "Repository has no commits. Create an initial commit first."

    local project_root
    project_root="$(git rev-parse --show-toplevel)"
    local project_name
    project_name="$(basename "$project_root")"

    # Check for task file
    local task_file
    if task_file="$(find_task_file "$project_root" "$feature")"; then
        info "Found task file: $task_file"
    else
        warn "Task file not found: $feature.md"
        warn "Searched: $feature.md, doc/$feature.md, docs/$feature.md, **/$feature.md"
        warn "Create it with the task description, or the agents won't know what to do."
    fi

    info "Starting Agent Duo session: $feature"
    info "Project: $project_name"

    # Set up worktree paths (siblings of project root)
    local parent_dir
    parent_dir="$(dirname "$project_root")"
    local worktree_claude="$parent_dir/${project_name}-${feature}-claude"
    local worktree_codex="$parent_dir/${project_name}-${feature}-codex"

    # Create branches and worktrees
    cd "$project_root"

    # Detect main branch: try origin/HEAD, then common names, then current branch
    local main_branch
    main_branch="$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@')" || true
    if [ -z "$main_branch" ]; then
        # Try common branch names
        for candidate in main master; do
            if git rev-parse --verify "$candidate" >/dev/null 2>&1; then
                main_branch="$candidate"
                break
            fi
        done
    fi
    if [ -z "$main_branch" ]; then
        # Fall back to current branch
        main_branch="$(git rev-parse --abbrev-ref HEAD)"
    fi

    if [ ! -d "$worktree_claude" ]; then
        info "Creating worktree for claude..."
        git worktree add -b "${feature}-claude" "$worktree_claude" "$main_branch" 2>/dev/null || \
            git worktree add "$worktree_claude" "${feature}-claude"
    else
        warn "Worktree already exists: $worktree_claude"
    fi

    if [ ! -d "$worktree_codex" ]; then
        info "Creating worktree for codex..."
        git worktree add -b "${feature}-codex" "$worktree_codex" "$main_branch" 2>/dev/null || \
            git worktree add "$worktree_codex" "${feature}-codex"
    else
        warn "Worktree already exists: $worktree_codex"
    fi

    # Initialize .peer-sync
    local peer_sync="$project_root/.peer-sync"
    mkdir -p "$peer_sync/reviews"
    mkdir -p "$peer_sync/pids"

    echo "active" > "$peer_sync/session"
    if $clarify_mode; then
        echo "clarify" > "$peer_sync/phase"
        echo "true" > "$peer_sync/clarify-mode"
        echo "clarifying|$(date +%s)|starting" > "$peer_sync/claude.status"
        echo "clarifying|$(date +%s)|starting" > "$peer_sync/codex.status"
    else
        echo "work" > "$peer_sync/phase"
        echo "false" > "$peer_sync/clarify-mode"
        echo "working|$(date +%s)|starting" > "$peer_sync/claude.status"
        echo "working|$(date +%s)|starting" > "$peer_sync/codex.status"
    fi
    echo "1" > "$peer_sync/round"
    echo "$feature" > "$peer_sync/feature"
    echo "$codex_thinking" > "$peer_sync/codex-thinking"
    echo "duo" > "$peer_sync/mode"

    # Create symlinks in worktrees
    ln -sfn "$peer_sync" "$worktree_claude/.peer-sync"
    ln -sfn "$peer_sync" "$worktree_codex/.peer-sync"

    # Ensure .peer-sync is excluded from git (using .git/info/exclude to avoid modifying tracked files)
    local git_exclude="$project_root/.git/info/exclude"
    if [ -f "$git_exclude" ]; then
        if ! grep -qxF ".peer-sync" "$git_exclude"; then
            echo ".peer-sync" >> "$git_exclude"
        fi
    else
        mkdir -p "$(dirname "$git_exclude")"
        echo ".peer-sync" > "$git_exclude"
    fi

    # Copy task file to worktrees if it exists
    if [ -f "$task_file" ]; then
        cp "$task_file" "$worktree_claude/"
        cp "$task_file" "$worktree_codex/"
    fi

    if $ttyd_mode; then
        start_ttyd_mode "$feature" "$project_root" "$worktree_claude" "$worktree_codex" "$peer_sync" \
            "$auto_run" "$work_timeout" "$review_timeout" "$max_rounds" "$codex_thinking" "$clarify_mode" "$clarify_timeout"
    else
        start_tmux_mode "$feature" "$project_root" "$worktree_claude" "$worktree_codex" "$peer_sync" "$codex_thinking" "$clarify_mode"
    fi
}

start_tmux_mode() {
    local feature="$1"
    local project_root="$2"
    local worktree_claude="$3"
    local worktree_codex="$4"
    local peer_sync="$5"
    local codex_thinking="${6:-$DEFAULT_CODEX_THINKING}"
    local clarify_mode="${7:-false}"

    local session_name="duo-${feature}"

    # Kill existing session if any
    tmux kill-session -t "$session_name" 2>/dev/null || true

    # Create new tmux session with orchestrator window
    tmux new-session -d -s "$session_name" -n "orchestrator" -c "$project_root"

    # Create claude window
    tmux new-window -t "$session_name" -n "claude" -c "$worktree_claude"
    tmux send-keys -t "$session_name:claude" "export PEER_SYNC='$peer_sync'"
    tmux send-keys -t "$session_name:claude" C-m
    tmux send-keys -t "$session_name:claude" "export MY_NAME='claude'"
    tmux send-keys -t "$session_name:claude" C-m
    tmux send-keys -t "$session_name:claude" "export PEER_NAME='codex'"
    tmux send-keys -t "$session_name:claude" C-m
    tmux send-keys -t "$session_name:claude" "export PEER_WORKTREE='$worktree_codex'"
    tmux send-keys -t "$session_name:claude" C-m
    tmux send-keys -t "$session_name:claude" "export FEATURE='$feature'"
    tmux send-keys -t "$session_name:claude" C-m

    # Create codex window
    tmux new-window -t "$session_name" -n "codex" -c "$worktree_codex"
    tmux send-keys -t "$session_name:codex" "export PEER_SYNC='$peer_sync'"
    tmux send-keys -t "$session_name:codex" C-m
    tmux send-keys -t "$session_name:codex" "export MY_NAME='codex'"
    tmux send-keys -t "$session_name:codex" C-m
    tmux send-keys -t "$session_name:codex" "export PEER_NAME='claude'"
    tmux send-keys -t "$session_name:codex" C-m
    tmux send-keys -t "$session_name:codex" "export PEER_WORKTREE='$worktree_claude'"
    tmux send-keys -t "$session_name:codex" C-m
    tmux send-keys -t "$session_name:codex" "export FEATURE='$feature'"
    tmux send-keys -t "$session_name:codex" C-m

    success "Created tmux session: $session_name"
    echo ""
    echo "Windows:"
    echo "  0: orchestrator  - Main project root"
    echo "  1: claude        - $worktree_claude"
    echo "  2: codex         - $worktree_codex"
    echo ""
    echo "Attach with: tmux attach -t $session_name"
    echo ""
    echo "To start agents, in each window run their CLI:"
    echo "  claude window: $CLAUDE_CMD"
    echo "  codex window:  $(get_agent_cmd codex "$codex_thinking")"
    if [ "$clarify_mode" = "true" ]; then
        echo ""
        echo "Clarify mode enabled. After agents submit their approaches:"
        echo "  1. Review approaches in .peer-sync/clarify-*.md"
        echo "  2. Respond to agents in their terminals (back-and-forth OK)"
        echo "  3. Press Enter in the orchestrator to proceed to work phase"
    fi
}

start_ttyd_mode() {
    local feature="$1"
    local project_root="$2"
    local worktree_claude="$3"
    local worktree_codex="$4"
    local peer_sync="$5"
    local auto_run="${6:-false}"
    local work_timeout="${7:-$DEFAULT_WORK_TIMEOUT}"
    local review_timeout="${8:-$DEFAULT_REVIEW_TIMEOUT}"
    local max_rounds="${9:-10}"
    local codex_thinking="${10:-$DEFAULT_CODEX_THINKING}"
    local clarify_mode="${11:-false}"
    local clarify_timeout="${12:-$DEFAULT_CLARIFY_TIMEOUT}"

    local session_name="duo-${feature}"

    # Check ttyd is installed
    command -v ttyd >/dev/null 2>&1 || die "ttyd not found. Install with: brew install ttyd"

    # Kill existing sessions if any
    tmux kill-session -t "${session_name}-orchestrator" 2>/dev/null || true
    tmux kill-session -t "${session_name}-claude" 2>/dev/null || true
    tmux kill-session -t "${session_name}-codex" 2>/dev/null || true

    # Create tmux sessions for orchestrator and each agent
    tmux new-session -d -s "${session_name}-orchestrator" -c "$project_root"
    tmux new-session -d -s "${session_name}-claude" -c "$worktree_claude"
    tmux new-session -d -s "${session_name}-codex" -c "$worktree_codex"

    # Set environment variables for orchestrator
    for var in "PEER_SYNC='$peer_sync'" "FEATURE='$feature'"; do
        tmux send-keys -t "${session_name}-orchestrator" "export $var"
        tmux send-keys -t "${session_name}-orchestrator" C-m
    done

    # Set environment variables for agents
    for var in "PEER_SYNC='$peer_sync'" "MY_NAME='claude'" "PEER_NAME='codex'" "PEER_WORKTREE='$worktree_codex'" "FEATURE='$feature'"; do
        tmux send-keys -t "${session_name}-claude" "export $var"
        tmux send-keys -t "${session_name}-claude" C-m
    done

    for var in "PEER_SYNC='$peer_sync'" "MY_NAME='codex'" "PEER_NAME='claude'" "PEER_WORKTREE='$worktree_claude'" "FEATURE='$feature'"; do
        tmux send-keys -t "${session_name}-codex" "export $var"
        tmux send-keys -t "${session_name}-codex" C-m
    done

    # Allocate and load ports
    allocate_ports "$peer_sync"
    get_ports "$peer_sync"
    local orchestrator_port=$ORCHESTRATOR_PORT
    local claude_port=$CLAUDE_PORT
    local codex_port=$CODEX_PORT

    ttyd -p "$orchestrator_port" -W tmux attach -t "${session_name}-orchestrator" &
    echo $! > "$peer_sync/pids/ttyd-orchestrator.pid"

    ttyd -p "$claude_port" -W tmux attach -t "${session_name}-claude" &
    echo $! > "$peer_sync/pids/ttyd-claude.pid"

    ttyd -p "$codex_port" -W tmux attach -t "${session_name}-codex" &
    echo $! > "$peer_sync/pids/ttyd-codex.pid"

    success "Started ttyd servers"
    echo ""
    echo "Web terminals:"
    echo "  Orchestrator: http://localhost:$orchestrator_port"
    echo "  Claude:       http://localhost:$claude_port"
    echo "  Codex:        http://localhost:$codex_port"
    echo ""

    # If auto-run, start the orchestrator loop in the orchestrator session
    if [ "$auto_run" = "true" ]; then
        info "Starting orchestrator with --auto-start..."
        local run_cmd="agent-duo run --auto-start --work-timeout $work_timeout --review-timeout $review_timeout --max-rounds $max_rounds"
        if [ "$clarify_mode" = "true" ]; then
            run_cmd="$run_cmd --clarify-timeout $clarify_timeout"
        fi
        tmux send-keys -t "${session_name}-orchestrator" "$run_cmd"
        tmux send-keys -t "${session_name}-orchestrator" C-m
    else
        echo "Start orchestrator with: agent-duo run --auto-start"
    fi
    echo "Stop with: agent-duo stop"
    if [ "$clarify_mode" = "true" ]; then
        echo ""
        echo "Clarify mode enabled. After agents submit their approaches:"
        echo "  1. Review approaches (shown in orchestrator, also emailed)"
        echo "  2. Respond to agents in their terminals (back-and-forth OK)"
        echo "  3. Press Enter in the orchestrator to proceed to work phase"
    fi
}

#------------------------------------------------------------------------------
# Command: stop
#------------------------------------------------------------------------------

cmd_stop() {
    local root
    root="$(get_project_root)"
    local peer_sync="$root/.peer-sync"

    info "Stopping Agent Duo..."

    # Kill ttyd processes from PID files
    if [ -d "$peer_sync/pids" ]; then
        for pidfile in "$peer_sync/pids"/*.pid; do
            [ -f "$pidfile" ] || continue
            local pid
            pid="$(cat "$pidfile")"
            if kill -0 "$pid" 2>/dev/null; then
                kill "$pid" 2>/dev/null || true
                info "Killed process $pid ($(basename "$pidfile" .pid))"
            fi
            rm -f "$pidfile"
        done
    fi

    # Get feature name for session-specific cleanup
    local feature
    feature="$(get_feature 2>/dev/null)" || true

    # Fallback: kill ttyd processes for THIS session only (in case PID files are missing)
    if [ -n "$feature" ]; then
        pkill -f "ttyd.*duo-${feature}-" 2>/dev/null && info "Killed remaining ttyd processes for duo-${feature}" || true
    fi

    # Kill tmux sessions for this feature
    if [ -n "$feature" ]; then
        tmux kill-session -t "duo-${feature}" 2>/dev/null && info "Killed tmux session: duo-${feature}" || true
        tmux kill-session -t "duo-${feature}-orchestrator" 2>/dev/null && info "Killed tmux session: duo-${feature}-orchestrator" || true
        tmux kill-session -t "duo-${feature}-claude" 2>/dev/null && info "Killed tmux session: duo-${feature}-claude" || true
        tmux kill-session -t "duo-${feature}-codex" 2>/dev/null && info "Killed tmux session: duo-${feature}-codex" || true
    fi

    success "Stopped"
}

#------------------------------------------------------------------------------
# Command: restart
#------------------------------------------------------------------------------

cmd_restart() {
    local auto_run=false
    local work_timeout=$DEFAULT_WORK_TIMEOUT
    local review_timeout=$DEFAULT_REVIEW_TIMEOUT
    local max_rounds=10

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --auto-run) auto_run=true; shift ;;
            --work-timeout) work_timeout="$2"; shift 2 ;;
            --review-timeout) review_timeout="$2"; shift 2 ;;
            --max-rounds) max_rounds="$2"; shift 2 ;;
            -*) die "Unknown option: $1" ;;
            *) die "Unknown argument: $1" ;;
        esac
    done

    local root
    root="$(get_project_root 2>/dev/null)" || die "Not in an agent-duo session (no .peer-sync found)"
    local peer_sync="$root/.peer-sync"

    # Check we have an active session
    [ -f "$peer_sync/feature" ] || die "No active session (missing .peer-sync/feature)"
    [ -f "$peer_sync/ports" ] || die "No port allocations found. Was this a ttyd session?"

    local feature
    feature="$(get_feature)"
    local project_name
    project_name="$(basename "$root")"
    local parent_dir
    parent_dir="$(dirname "$root")"

    # Calculate paths
    local worktree_claude="$parent_dir/${project_name}-${feature}-claude"
    local worktree_codex="$parent_dir/${project_name}-${feature}-codex"
    local session_name="duo-${feature}"

    # Load ports
    get_ports "$peer_sync"
    local orchestrator_port=$ORCHESTRATOR_PORT
    local claude_port=$CLAUDE_PORT
    local codex_port=$CODEX_PORT

    # Load codex thinking effort
    local codex_thinking
    codex_thinking="$(cat "$peer_sync/codex-thinking" 2>/dev/null)" || codex_thinking="$DEFAULT_CODEX_THINKING"

    echo ""
    echo "=== Agent Duo Restart ==="
    echo ""
    echo "Feature:  $feature"
    echo "Project:  $project_name"
    echo "Codex thinking: $codex_thinking"
    echo ""

    # Ensure pids directory exists
    mkdir -p "$peer_sync/pids"

    local errors=0
    local restarted=0

    #---------------------------------------------------------------------------
    # Phase 1: Check and restart tmux sessions
    #---------------------------------------------------------------------------
    info "Checking tmux sessions..."

    # Check orchestrator tmux session
    if ! tmux_session_exists "${session_name}-orchestrator"; then
        info "Creating tmux session: ${session_name}-orchestrator"
        tmux new-session -d -s "${session_name}-orchestrator" -c "$root"
        for var in "PEER_SYNC='$peer_sync'" "FEATURE='$feature'"; do
            tmux send-keys -t "${session_name}-orchestrator" "export $var"
            tmux send-keys -t "${session_name}-orchestrator" C-m
        done
        restarted=$((restarted + 1))
    else
        success "  orchestrator tmux session: OK"
    fi

    # Check claude tmux session
    if ! tmux_session_exists "${session_name}-claude"; then
        if [ ! -d "$worktree_claude" ]; then
            warn "  claude worktree missing: $worktree_claude"
            errors=$((errors + 1))
        else
            info "Creating tmux session: ${session_name}-claude"
            tmux new-session -d -s "${session_name}-claude" -c "$worktree_claude"
            for var in "PEER_SYNC='$peer_sync'" "MY_NAME='claude'" "PEER_NAME='codex'" "PEER_WORKTREE='$worktree_codex'" "FEATURE='$feature'"; do
                tmux send-keys -t "${session_name}-claude" "export $var"
                tmux send-keys -t "${session_name}-claude" C-m
            done
            restarted=$((restarted + 1))
        fi
    else
        success "  claude tmux session: OK"
    fi

    # Check codex tmux session
    if ! tmux_session_exists "${session_name}-codex"; then
        if [ ! -d "$worktree_codex" ]; then
            warn "  codex worktree missing: $worktree_codex"
            errors=$((errors + 1))
        else
            info "Creating tmux session: ${session_name}-codex"
            tmux new-session -d -s "${session_name}-codex" -c "$worktree_codex"
            for var in "PEER_SYNC='$peer_sync'" "MY_NAME='codex'" "PEER_NAME='claude'" "PEER_WORKTREE='$worktree_claude'" "FEATURE='$feature'"; do
                tmux send-keys -t "${session_name}-codex" "export $var"
                tmux send-keys -t "${session_name}-codex" C-m
            done
            restarted=$((restarted + 1))
        fi
    else
        success "  codex tmux session: OK"
    fi

    #---------------------------------------------------------------------------
    # Phase 2: Check and restart ttyd servers
    #---------------------------------------------------------------------------
    echo ""
    info "Checking ttyd servers..."

    # Check orchestrator ttyd
    if ! restart_ttyd_for_session "orchestrator" "$orchestrator_port" \
            "${session_name}-orchestrator" "$peer_sync/pids/ttyd-orchestrator.pid"; then
        errors=$((errors + 1))
    elif [ $? -eq 0 ] && ! is_port_in_use "$orchestrator_port" 2>/dev/null; then
        # Verify port came up
        sleep 0.5
        is_port_in_use "$orchestrator_port" || errors=$((errors + 1))
    fi

    # Check claude ttyd
    if ! restart_ttyd_for_session "claude" "$claude_port" \
            "${session_name}-claude" "$peer_sync/pids/ttyd-claude.pid"; then
        errors=$((errors + 1))
    fi

    # Check codex ttyd
    if ! restart_ttyd_for_session "codex" "$codex_port" \
            "${session_name}-codex" "$peer_sync/pids/ttyd-codex.pid"; then
        errors=$((errors + 1))
    fi

    #---------------------------------------------------------------------------
    # Phase 3: Check and restart agent TUIs
    #---------------------------------------------------------------------------
    echo ""
    info "Checking agent TUIs..."

    # Check claude TUI (thinking effort not used for claude)
    if ! restart_agent_tui "claude" "${session_name}-claude" \
            "$worktree_claude" "$peer_sync" "$worktree_codex" "$feature"; then
        errors=$((errors + 1))
    fi

    # Check codex TUI (pass thinking effort)
    if ! restart_agent_tui "codex" "${session_name}-codex" \
            "$worktree_codex" "$peer_sync" "$worktree_claude" "$feature" "$codex_thinking"; then
        errors=$((errors + 1))
    fi

    #---------------------------------------------------------------------------
    # Phase 4: Check orchestration state and optionally restart orchestrator
    #---------------------------------------------------------------------------
    echo ""
    info "Checking orchestration state..."

    local session_state
    session_state="$(cat "$peer_sync/session" 2>/dev/null)" || session_state="unknown"
    local phase
    phase="$(cat "$peer_sync/phase" 2>/dev/null)" || phase="unknown"
    local round
    round="$(cat "$peer_sync/round" 2>/dev/null)" || round="1"

    echo "  Session: $session_state"
    echo "  Phase:   $phase"
    echo "  Round:   $round"

    # Check if both agents have PRs (terminal state)
    local claude_has_pr=false
    local codex_has_pr=false
    [ -f "$peer_sync/claude.pr" ] && claude_has_pr=true
    [ -f "$peer_sync/codex.pr" ] && codex_has_pr=true

    if [ "$session_state" = "complete" ] || ($claude_has_pr && $codex_has_pr); then
        echo ""
        success "Session is in terminal state (complete). No orchestrator restart needed."
        if [ -f "$peer_sync/claude.pr" ]; then
            echo "  Claude PR: $(cat "$peer_sync/claude.pr")"
        fi
        if [ -f "$peer_sync/codex.pr" ]; then
            echo "  Codex PR:  $(cat "$peer_sync/codex.pr")"
        fi
    elif [ "$auto_run" = "true" ]; then
        echo ""
        info "Restarting orchestrator loop..."

        # Determine if orchestrator is already running
        local orchestrator_running=false
        if agent_tui_is_running "${session_name}-orchestrator" "orchestrator"; then
            orchestrator_running=true
        fi

        if ! $orchestrator_running; then
            tmux send-keys -t "${session_name}-orchestrator" \
                "agent-duo run --auto-start --work-timeout $work_timeout --review-timeout $review_timeout --max-rounds $max_rounds"
            tmux send-keys -t "${session_name}-orchestrator" C-m
            success "Started orchestrator loop"
        else
            info "Orchestrator appears to already be running"
        fi
    else
        echo ""
        info "Session is not complete. To restart the orchestrator loop:"
        echo "  agent-duo restart --auto-run"
        echo "Or manually in the orchestrator terminal:"
        echo "  agent-duo run --auto-start"
    fi

    #---------------------------------------------------------------------------
    # Summary
    #---------------------------------------------------------------------------
    echo ""
    echo "--- Web Terminals ---"
    echo "Orchestrator: http://localhost:$orchestrator_port"
    echo "Claude:       http://localhost:$claude_port"
    echo "Codex:        http://localhost:$codex_port"
    echo ""

    if [ "$errors" -gt 0 ]; then
        warn "Restart completed with $errors error(s)"
        return 1
    else
        success "Restart complete!"
        return 0
    fi
}

#------------------------------------------------------------------------------
# Command: status
#------------------------------------------------------------------------------

cmd_status() {
    local root
    root="$(get_project_root 2>/dev/null)" || die "Not in an agent-duo session"
    local peer_sync="$root/.peer-sync"

    echo ""
    echo "=== Agent Duo Status ==="
    echo ""

    if [ -f "$peer_sync/feature" ]; then
        echo "Feature:  $(cat "$peer_sync/feature")"
    fi

    if [ -f "$peer_sync/session" ]; then
        echo "Session:  $(cat "$peer_sync/session")"
    fi

    if [ -f "$peer_sync/phase" ]; then
        echo "Phase:    $(cat "$peer_sync/phase")"
    fi

    if [ -f "$peer_sync/round" ]; then
        echo "Round:    $(cat "$peer_sync/round")"
    fi

    # Show allocated ports if available
    if [ -f "$peer_sync/ports" ]; then
        # shellcheck source=/dev/null
        source "$peer_sync/ports"
        echo ""
        echo "--- Web Terminals ---"
        echo "Orchestrator: http://localhost:$ORCHESTRATOR_PORT"
        echo "Claude:       http://localhost:$CLAUDE_PORT"
        echo "Codex:        http://localhost:$CODEX_PORT"
    fi

    echo ""
    echo "--- Agent Status ---"

    for agent in claude codex; do
        local status_file="$peer_sync/${agent}.status"
        if [ -f "$status_file" ]; then
            local line
            line="$(cat "$status_file")"
            local status msg timestamp
            status="$(echo "$line" | cut -d'|' -f1)"
            timestamp="$(echo "$line" | cut -d'|' -f2)"
            msg="$(echo "$line" | cut -d'|' -f3-)"

            local time_str=""
            if [ -n "$timestamp" ] && [ "$timestamp" != "$status" ]; then
                time_str=" ($(date -r "$timestamp" '+%H:%M:%S' 2>/dev/null || echo "$timestamp"))"
            fi

            printf "%-8s: %s%s" "$agent" "$status" "$time_str"
            [ -n "$msg" ] && [ "$msg" != "$status" ] && printf " - %s" "$msg"
            echo ""
        else
            echo "$agent:   (no status)"
        fi
    done

    # Check for PRs
    echo ""
    echo "--- Pull Requests ---"
    for agent in claude codex; do
        local pr_file="$peer_sync/${agent}.pr"
        if [ -f "$pr_file" ]; then
            echo "$agent:   $(cat "$pr_file")"
        else
            echo "$agent:   (none)"
        fi
    done

    # List reviews
    if [ -d "$peer_sync/reviews" ] && [ "$(ls -A "$peer_sync/reviews" 2>/dev/null)" ]; then
        echo ""
        echo "--- Reviews ---"
        ls -1 "$peer_sync/reviews"
    fi

    echo ""
}

#------------------------------------------------------------------------------
# Command: pr
#------------------------------------------------------------------------------

cmd_pr() {
    local agent="$1"
    [ -z "$agent" ] && die "Usage: agent-duo pr <agent>"

    local root
    root="$(get_project_root)"
    local peer_sync="$root/.peer-sync"
    local feature
    feature="$(get_feature)"

    # Determine worktree
    local project_name
    project_name="$(basename "$root")"
    local parent_dir
    parent_dir="$(dirname "$root")"
    local worktree="$parent_dir/${project_name}-${feature}-${agent}"

    [ -d "$worktree" ] || die "Worktree not found: $worktree"

    info "Creating PR for $agent..."

    cd "$worktree"

    # Check if feature file exists and was NOT modified (should be deleted)
    # The feature file is copied to the worktree root during start
    local feature_file="$worktree/${feature}.md"
    if [ -f "$feature_file" ]; then
        # Get the main branch to compare against
        local main_branch
        main_branch="$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@')" || true
        if [ -z "$main_branch" ]; then
            for candidate in main master; do
                if git rev-parse --verify "$candidate" >/dev/null 2>&1; then
                    main_branch="$candidate"
                    break
                fi
            done
        fi
        if [ -z "$main_branch" ]; then
            main_branch="HEAD~1"  # fallback: compare to parent commit
        fi

        # Check if the feature file was modified compared to when it was copied
        # We compare the file content in the worktree against main branch
        local file_modified=false
        if git show "${main_branch}:${feature}.md" >/dev/null 2>&1; then
            # File exists in main branch - check if content differs
            if ! git diff --quiet "${main_branch}" -- "${feature}.md" 2>/dev/null; then
                file_modified=true
            fi
        else
            # File doesn't exist in main branch (was copied during start)
            # Check if it was modified from the original task file in .peer-sync or root
            local original_task_file
            if original_task_file="$(find_task_file "$root" "$feature")"; then
                if ! diff -q "$feature_file" "$original_task_file" >/dev/null 2>&1; then
                    file_modified=true
                fi
            fi
        fi

        if [ "$file_modified" = "false" ]; then
            info "Feature file ${feature}.md was not modified - removing it"
            git rm "${feature}.md"
            git commit -m "Remove unmodified feature file ${feature}.md"
        fi
    fi

    # Check for changes
    if [ -z "$(git status --porcelain)" ]; then
        warn "No changes to commit in $agent's worktree"
    else
        # Auto-commit changes
        git add -A
        git commit -m "Solution from $agent for $feature" || true
    fi

    # Push branch
    local branch="${feature}-${agent}"
    git push -u origin "$branch" 2>/dev/null || git push origin "$branch"

    # Look for PR body file
    local pr_body=""
    local pr_body_file="$root/${feature}-${agent}-PR.md"
    if [ -f "$pr_body_file" ]; then
        pr_body="$(cat "$pr_body_file")"
    else
        pr_body="Solution from $agent for feature: $feature"
    fi

    # Create PR
    local pr_url
    pr_url="$(gh pr create --title "${agent}'s solution for $feature" --body "$pr_body" --head "$branch" 2>/dev/null)" || \
        pr_url="$(gh pr view --json url -q '.url' 2>/dev/null)" || \
        die "Failed to create PR. Is gh installed and authenticated?"

    # Record PR
    echo "$pr_url" > "$peer_sync/${agent}.pr"
    atomic_write "$peer_sync/${agent}.status" "pr-created|$(date +%s)|$pr_url"

    success "PR created: $pr_url"

    # Check if both PRs exist
    if [ -f "$peer_sync/claude.pr" ] && [ -f "$peer_sync/codex.pr" ]; then
        echo "complete" > "$peer_sync/session"
        success "Both PRs created - session complete!"
    fi
}

#------------------------------------------------------------------------------
# Command: cleanup
#------------------------------------------------------------------------------

cmd_cleanup() {
    local full=false
    [ "$1" = "--full" ] && full=true

    local root
    root="$(get_project_root)"
    local peer_sync="$root/.peer-sync"
    local feature
    feature="$(get_feature)"
    local project_name
    project_name="$(basename "$root")"
    local parent_dir
    parent_dir="$(dirname "$root")"

    info "Cleaning up session: $feature"

    # Stop any running processes first
    cmd_stop

    # Remove worktrees
    local worktree_claude="$parent_dir/${project_name}-${feature}-claude"
    local worktree_codex="$parent_dir/${project_name}-${feature}-codex"

    cd "$root"  # Make sure we're not in a worktree

    if [ -d "$worktree_claude" ]; then
        git worktree remove --force "$worktree_claude" 2>/dev/null || rm -rf "$worktree_claude"
        info "Removed worktree: $worktree_claude"
    fi

    if [ -d "$worktree_codex" ]; then
        git worktree remove --force "$worktree_codex" 2>/dev/null || rm -rf "$worktree_codex"
        info "Removed worktree: $worktree_codex"
    fi

    # Prune worktree references
    git worktree prune

    if $full; then
        # Remove state
        rm -rf "$peer_sync"
        info "Removed .peer-sync"

        # Optionally delete branches
        git branch -D "${feature}-claude" 2>/dev/null && info "Deleted branch: ${feature}-claude" || true
        git branch -D "${feature}-codex" 2>/dev/null && info "Deleted branch: ${feature}-codex" || true
    fi

    success "Cleanup complete"
}

#------------------------------------------------------------------------------
# Command: signal (for agents)
#------------------------------------------------------------------------------

cmd_signal() {
    local agent="$1"
    local status="$2"
    local message="${3:-}"

    [ -z "$agent" ] || [ -z "$status" ] && die "Usage: agent-duo signal <agent> <status> [message]"

    local root
    root="$(get_project_root)"
    local peer_sync="$root/.peer-sync"

    # Validate status
    case "$status" in
        clarifying|clarify-done|working|done|reviewing|review-done|interrupted|error|pr-created) ;;
        *) die "Invalid status: $status (valid: clarifying, clarify-done, working, done, reviewing, review-done, interrupted, error, pr-created)" ;;
    esac

    local content="${status}|$(date +%s)|${message}"
    atomic_write "$peer_sync/${agent}.status" "$content"

    success "$agent status: $status"
}

#------------------------------------------------------------------------------
# Command: peer-status (for agents)
#------------------------------------------------------------------------------

cmd_peer_status() {
    local peer="${PEER_NAME:-}"
    [ -z "$peer" ] && die "PEER_NAME not set. Are you in an agent session?"

    local root
    root="$(get_project_root)"
    local peer_sync="$root/.peer-sync"
    local status_file="$peer_sync/${peer}.status"

    if [ -f "$status_file" ]; then
        cat "$status_file"
    else
        echo "unknown"
    fi
}

#------------------------------------------------------------------------------
# Command: phase (for agents)
#------------------------------------------------------------------------------

cmd_phase() {
    local root
    root="$(get_project_root)"
    local peer_sync="$root/.peer-sync"

    if [ -f "$peer_sync/phase" ]; then
        cat "$peer_sync/phase"
    else
        echo "unknown"
    fi
}

#------------------------------------------------------------------------------
# Command: confirm (user confirms clarify phase completion)
#------------------------------------------------------------------------------

cmd_confirm() {
    local root
    root="$(get_project_root)"
    local peer_sync="$root/.peer-sync"

    # Check we're in clarify phase
    local phase
    phase="$(cat "$peer_sync/phase" 2>/dev/null)" || die "No active session"

    if [ "$phase" != "clarify" ]; then
        if [ -f "$peer_sync/clarify-confirmed" ]; then
            info "Clarify phase already confirmed."
        else
            die "Not in clarify phase (current phase: $phase)"
        fi
        return 0
    fi

    # Mark clarify as confirmed
    echo "confirmed" > "$peer_sync/clarify-confirmed"

    # Transition to work phase
    echo "work" > "$peer_sync/phase"

    success "Clarify phase confirmed! Transitioning to work phase."
    echo "Note: If orchestrator is waiting for input, press Enter there to continue."
}

# Note: send_clarify_notification is provided by agent-lib.sh
# It tries ntfy first (if configured), then email

#------------------------------------------------------------------------------
# Generate clarify phase message for agents
#------------------------------------------------------------------------------

generate_clarify_message() {
    local agent="$1"
    local peer="$2"
    local feature="$3"
    local task_content="$4"
    local peer_worktree="$5"
    local peer_sync="$6"

    cat <<EOF
# Task: $feature

$task_content

---
## Agent-Duo Context - CLARIFY PHASE

You are **$agent** in a duo workflow with **$peer** as your peer.

**PHASE: CLARIFY** - Before starting implementation, propose your high-level approach and ask clarifying questions.

### Your Environment

- **Your worktree**: Current directory
- **Peer's worktree**: $peer_worktree (read-only)
- **Sync directory**: $peer_sync

### Your Task

Produce TWO outputs:

1. **High-level approach** - Not a detailed plan, but a sketch: the key idea, first steps to explore, or general direction
2. **Clarifying questions** - Questions for the user that would help you start more effectively

### Write Your Approach and Questions

\`\`\`bash
cat > "$peer_sync/clarify-${agent}.md" << 'CLARIFY_EOF'
# Clarification from $agent

## Proposed Approach

[Write 3-5 sentences describing your high-level approach.]

## Questions for the User

1. [Question 1]
2. [Question 2]
3. [Question 3 - optional]

CLARIFY_EOF
\`\`\`

Edit the file with actual content, then signal completion:

\`\`\`bash
agent-duo signal "$agent" clarify-done "approach and questions submitted"
\`\`\`

Then **STOP and wait**. The user will review your approach and respond in this terminal.
Do NOT start implementing until the work phase begins.
EOF
}

#------------------------------------------------------------------------------
# Command: run (orchestrator)
#------------------------------------------------------------------------------

# Note: get_agent_status, has_pr, interrupt_agent, nudge_agent, and
# trigger_skill are all provided by agent-lib.sh

# Generate augmented first-round message with full context
# This replaces the need for /duo-work skill in round 1
generate_round1_message() {
    local agent="$1"
    local peer="$2"
    local feature="$3"
    local task_content="$4"
    local peer_worktree="$5"
    local peer_sync="$6"

    cat <<EOF
# Task: $feature

$task_content

---
## Agent-Duo Context

You are **$agent** in a duo workflow with **$peer** as your peer.
Both of you are developing **alternative solutions** in parallel.

- **Phase**: Work (Round 1)
- **Your worktree**: Current directory (read/write)
- **Peer's worktree**: $peer_worktree (read-only - look but don't touch)
- **Sync directory**: $peer_sync

### Your Goal

Implement your solution independently. Your peer works in parallel on the same task.

### Guidelines

1. **Diverge to explore the search space**: Produce an *alternative* solution, not a copy
2. **Different tradeoffs are good**: If peer chose approach A, consider approach B
3. **Read peer's code for insight, not imitation**
4. **Focus on your implementation**: Make progress on your own solution, convergence is fine if it arises organically from a confident consensus

### Checking Peer's Progress (Optional)

\`\`\`bash
agent-duo peer-status
git -C "$peer_worktree" diff
\`\`\`

### When Done

Signal completion and **STOP**:
\`\`\`bash
agent-duo signal "$agent" done "brief summary of what you did"
\`\`\`

The orchestrator will then trigger the review phase.

### When Ready to Submit Final PR

When your solution is complete and tested, create your PR:
\`\`\`bash
agent-duo pr "$agent"   # recommended: handles commit, push, and orchestrator sync
# or: gh pr create ...  # also works, orchestrator will detect it
\`\`\`
EOF
}

cmd_run() {
    local work_timeout=$DEFAULT_WORK_TIMEOUT
    local review_timeout=$DEFAULT_REVIEW_TIMEOUT
    local clarify_timeout=$DEFAULT_CLARIFY_TIMEOUT
    local poll_interval=$DEFAULT_POLL_INTERVAL
    local max_rounds=10
    local auto_start=false
    local enable_clarify=""  # empty means use session default
    local tui_exit_behavior=$DEFAULT_TUI_EXIT_BEHAVIOR

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --work-timeout) work_timeout="$2"; shift 2 ;;
            --review-timeout) review_timeout="$2"; shift 2 ;;
            --clarify-timeout) clarify_timeout="$2"; shift 2 ;;
            --clarify) enable_clarify="true"; shift ;;
            --poll) poll_interval="$2"; shift 2 ;;
            --max-rounds) max_rounds="$2"; shift 2 ;;
            --auto-start) auto_start=true; shift ;;
            --on-tui-exit) tui_exit_behavior="$2"; shift 2 ;;
            -*) die "Unknown option: $1" ;;
            *) die "Unknown argument: $1" ;;
        esac
    done

    local root
    root="$(get_project_root)"
    local peer_sync="$root/.peer-sync"
    local feature
    feature="$(get_feature)"

    # Determine tmux session name
    local session_name="duo-${feature}"

    # Check tmux session exists
    if ! tmux has-session -t "$session_name" 2>/dev/null; then
        # Try ttyd-style separate sessions
        if tmux has-session -t "${session_name}-claude" 2>/dev/null; then
            local claude_session="${session_name}-claude"
            local codex_session="${session_name}-codex"
        else
            die "No tmux session found. Run 'agent-duo start $feature' first."
        fi
    else
        local claude_session="${session_name}:claude"
        local codex_session="${session_name}:codex"
    fi

    echo ""
    echo "=== Agent Duo Orchestrator ==="
    echo "Feature:        $feature"
    echo "Work timeout:   ${work_timeout}s"
    echo "Review timeout: ${review_timeout}s"
    echo "Max rounds:     $max_rounds"
    echo ""

    # Calculate worktree paths for augmented messages
    local project_name
    project_name="$(basename "$root")"
    local parent_dir
    parent_dir="$(dirname "$root")"
    local worktree_claude="$parent_dir/${project_name}-${feature}-claude"
    local worktree_codex="$parent_dir/${project_name}-${feature}-codex"

    # Load codex thinking effort from session
    local codex_thinking
    codex_thinking="$(cat "$peer_sync/codex-thinking" 2>/dev/null)" || codex_thinking="$DEFAULT_CODEX_THINKING"

    # Optionally auto-start agents
    if $auto_start; then
        info "Starting agents..."
        tmux send-keys -t "$claude_session" "$CLAUDE_CMD"
        tmux send-keys -t "$claude_session" C-m
        tmux send-keys -t "$codex_session" "$(get_agent_cmd codex "$codex_thinking")"
        tmux send-keys -t "$codex_session" C-m
        sleep 3
        # Task will be sent as augmented round 1 message or clarify message below
    fi

    # Check if clarify mode is enabled (command line overrides session setting)
    local clarify_mode
    if [ -n "$enable_clarify" ]; then
        clarify_mode="$enable_clarify"
        echo "$enable_clarify" > "$peer_sync/clarify-mode"
    else
        clarify_mode="$(cat "$peer_sync/clarify-mode" 2>/dev/null)" || clarify_mode="false"
    fi

    # Handle clarify phase if enabled and not already confirmed
    if [ "$clarify_mode" = "true" ] && [ ! -f "$peer_sync/clarify-confirmed" ]; then
        info "=== Clarify Phase ==="
        echo "clarify" > "$peer_sync/phase"

        # Read task content
        local task_file
        local task_content=""
        if task_file="$(find_task_file "$root" "$feature")"; then
            task_content="$(cat "$task_file" | head -c 4000)"
        fi

        # Send clarify message to both agents
        atomic_write "$peer_sync/claude.status" "clarifying|$(date +%s)|clarify phase"
        info "Sending clarify task to claude..."
        local claude_clarify_msg
        claude_clarify_msg="$(generate_clarify_message "claude" "codex" "$feature" "$task_content" "$worktree_codex" "$peer_sync")"
        tmux send-keys -t "$claude_session" "$claude_clarify_msg"
        sleep 0.5
        tmux send-keys -t "$claude_session" C-m

        atomic_write "$peer_sync/codex.status" "clarifying|$(date +%s)|clarify phase"
        info "Sending clarify task to codex..."
        local codex_clarify_msg
        codex_clarify_msg="$(generate_clarify_message "codex" "claude" "$feature" "$task_content" "$worktree_claude" "$peer_sync")"
        tmux send-keys -t "$codex_session" "$codex_clarify_msg"
        sleep 0.5
        tmux send-keys -t "$codex_session" C-m

        # Wait for both agents to complete clarify phase
        local clarify_start=$SECONDS
        local claude_clarify_done=false
        local codex_clarify_done=false

        while ! ($claude_clarify_done && $codex_clarify_done); do
            local elapsed=$((SECONDS - clarify_start))

            # Check for completion
            local claude_status
            claude_status="$(get_agent_status "claude" "$peer_sync")"
            local codex_status
            codex_status="$(get_agent_status "codex" "$peer_sync")"

            [ "$claude_status" = "clarify-done" ] && claude_clarify_done=true
            [ "$codex_status" = "clarify-done" ] && codex_clarify_done=true

            if $claude_clarify_done && $codex_clarify_done; then
                break
            fi

            # Check if agent TUIs have exited unexpectedly
            if ! $claude_clarify_done; then
                check_tui_health "claude" "$claude_session" "$peer_sync" "$tui_exit_behavior"
            fi
            if ! $codex_clarify_done; then
                check_tui_health "codex" "$codex_session" "$peer_sync" "$tui_exit_behavior"
            fi

            # Check timeout
            if [ "$elapsed" -ge "$clarify_timeout" ]; then
                warn "Clarify phase timeout (${clarify_timeout}s)"
                # Don't interrupt - just proceed with whatever was submitted
                break
            fi

            printf "\r  Waiting... claude=%s codex=%s (%ds/%ds)  " "$claude_status" "$codex_status" "$elapsed" "$clarify_timeout"
            sleep "$poll_interval"
        done
        echo ""

        # Send notification with clarify results (ntfy and/or email)
        send_clarify_notification "$peer_sync" "$feature" "duo"

        # Display clarify results
        echo ""
        info "=== Clarify Phase Results ==="
        echo ""

        if [ -f "$peer_sync/clarify-claude.md" ]; then
            echo "--- Claude's Approach ---"
            cat "$peer_sync/clarify-claude.md"
            echo ""
        else
            warn "Claude did not submit a clarification"
        fi

        if [ -f "$peer_sync/clarify-codex.md" ]; then
            echo "--- Codex's Approach ---"
            cat "$peer_sync/clarify-codex.md"
            echo ""
        else
            warn "Codex did not submit a clarification"
        fi

        echo ""
        echo "=================================="
        echo ""
        info "Respond to agents in their terminals if needed."
        echo ""
        read -r -p "Press Enter when ready to proceed to work phase... "

        # Mark clarify as confirmed
        echo "confirmed" > "$peer_sync/clarify-confirmed"
        echo "work" > "$peer_sync/phase"

        success "Clarify phase confirmed! Proceeding to work phase..."
        echo ""
    fi

    local round=1

    while [ "$round" -le "$max_rounds" ]; do
        # Check if session is complete
        if [ "$(cat "$peer_sync/session" 2>/dev/null)" = "complete" ]; then
            success "Session complete!"
            break
        fi

        # Check if both have PRs
        if has_pr "claude" "$peer_sync" && has_pr "codex" "$peer_sync"; then
            echo "complete" > "$peer_sync/session"
            success "Both PRs created - session complete!"
            echo ""
            echo "Claude PR: $(cat "$peer_sync/claude.pr")"
            echo "Codex PR:  $(cat "$peer_sync/codex.pr")"
            break
        fi

        echo ""
        info "=== Round $round: Work Phase ==="
        echo "$round" > "$peer_sync/round"
        echo "work" > "$peer_sync/phase"

        # Trigger work phase for agents that don't have PRs
        # Round 1: Send augmented message with full context (avoids skill race condition)
        # Round 2+: Trigger duo-work skill (agent already has context)
        if [ "$round" -eq 1 ]; then
            # Round 1: Send augmented task with full context
            local task_file
            local task_content=""
            if task_file="$(find_task_file "$root" "$feature")"; then
                task_content="$(cat "$task_file" | head -c 4000)"
            fi

            if ! has_pr "claude" "$peer_sync"; then
                atomic_write "$peer_sync/claude.status" "working|$(date +%s)|round $round work phase"
                info "Sending augmented task to claude..."
                local claude_msg
                claude_msg="$(generate_round1_message "claude" "codex" "$feature" "$task_content" "$worktree_codex" "$peer_sync")"
                tmux send-keys -t "$claude_session" "$claude_msg"
                sleep 0.5
                tmux send-keys -t "$claude_session" C-m
            fi
            if ! has_pr "codex" "$peer_sync"; then
                atomic_write "$peer_sync/codex.status" "working|$(date +%s)|round $round work phase"
                info "Sending augmented task to codex..."
                local codex_msg
                codex_msg="$(generate_round1_message "codex" "claude" "$feature" "$task_content" "$worktree_claude" "$peer_sync")"
                tmux send-keys -t "$codex_session" "$codex_msg"
                sleep 0.5
                tmux send-keys -t "$codex_session" C-m
            fi
        else
            # Round 2+: Trigger skill (agent already knows the context)
            # Reset status to working before triggering (in case agent doesn't signal)
            if ! has_pr "claude" "$peer_sync"; then
                atomic_write "$peer_sync/claude.status" "working|$(date +%s)|round $round work phase"
                info "Triggering duo-work for claude..."
                trigger_skill "claude" "$claude_session" "duo-work"
            fi
            if ! has_pr "codex" "$peer_sync"; then
                atomic_write "$peer_sync/codex.status" "working|$(date +%s)|round $round work phase"
                info "Triggering duo-work for codex..."
                trigger_skill "codex" "$codex_session" "duo-work"
            fi
        fi

        # Wait for work phase completion with timeout
        local work_start=$SECONDS
        local claude_done=false
        local codex_done=false

        # Skip agents that already have PRs
        has_pr "claude" "$peer_sync" && claude_done=true
        has_pr "codex" "$peer_sync" && codex_done=true

        while ! ($claude_done && $codex_done); do
            local elapsed=$((SECONDS - work_start))

            # Check for completion
            local claude_status
            claude_status="$(get_agent_status "claude" "$peer_sync")"
            local codex_status
            codex_status="$(get_agent_status "codex" "$peer_sync")"

            # Accept done, review-done (agent jumped ahead), or pr-created
            [[ "$claude_status" =~ ^(done|review-done|pr-created)$ ]] && claude_done=true
            [[ "$codex_status" =~ ^(done|review-done|pr-created)$ ]] && codex_done=true

            # Check for PRs created mid-phase
            has_pr "claude" "$peer_sync" && claude_done=true
            has_pr "codex" "$peer_sync" && codex_done=true

            if $claude_done && $codex_done; then
                break
            fi

            # Check if agent TUIs have exited unexpectedly
            if ! $claude_done; then
                check_tui_health "claude" "$claude_session" "$peer_sync" "$tui_exit_behavior"
            fi
            if ! $codex_done; then
                check_tui_health "codex" "$codex_session" "$peer_sync" "$tui_exit_behavior"
            fi

            # Check timeout
            if [ "$elapsed" -ge "$work_timeout" ]; then
                warn "Work phase timeout (${work_timeout}s)"

                # Interrupt agents that aren't done
                if ! $claude_done; then
                    interrupt_agent "claude" "$claude_session" "$peer_sync"
                    claude_done=true
                fi
                if ! $codex_done; then
                    interrupt_agent "codex" "$codex_session" "$peer_sync"
                    codex_done=true
                fi
                break
            fi

            printf "\r  Waiting... claude=%s codex=%s (%ds/%ds)  " "$claude_status" "$codex_status" "$elapsed" "$work_timeout"
            sleep "$poll_interval"
        done
        echo ""

        # Check again if both have PRs (might have been created during work)
        if has_pr "claude" "$peer_sync" && has_pr "codex" "$peer_sync"; then
            echo "complete" > "$peer_sync/session"
            success "Both PRs created - session complete!"
            break
        fi

        # Review phase
        info "=== Round $round: Review Phase ==="
        echo "review" > "$peer_sync/phase"

        # Trigger review phase
        # Reset status to reviewing before triggering (in case agent doesn't signal)
        if ! has_pr "claude" "$peer_sync"; then
            atomic_write "$peer_sync/claude.status" "reviewing|$(date +%s)|round $round review phase"
            info "Triggering duo-review for claude..."
            trigger_skill "claude" "$claude_session" "duo-review"
        fi
        if ! has_pr "codex" "$peer_sync"; then
            atomic_write "$peer_sync/codex.status" "reviewing|$(date +%s)|round $round review phase"
            info "Triggering duo-review for codex..."
            trigger_skill "codex" "$codex_session" "duo-review"
        fi

        # Wait for review phase completion with timeout
        local review_start=$SECONDS
        claude_done=false
        codex_done=false

        has_pr "claude" "$peer_sync" && claude_done=true
        has_pr "codex" "$peer_sync" && codex_done=true

        while ! ($claude_done && $codex_done); do
            local elapsed=$((SECONDS - review_start))

            local claude_status
            claude_status="$(get_agent_status "claude" "$peer_sync")"
            local codex_status
            codex_status="$(get_agent_status "codex" "$peer_sync")"

            # Accept review-done, done (agent skipped review), or pr-created
            [[ "$claude_status" =~ ^(done|review-done|pr-created)$ ]] && claude_done=true
            [[ "$codex_status" =~ ^(done|review-done|pr-created)$ ]] && codex_done=true

            has_pr "claude" "$peer_sync" && claude_done=true
            has_pr "codex" "$peer_sync" && codex_done=true

            if $claude_done && $codex_done; then
                break
            fi

            # Check if agent TUIs have exited unexpectedly
            if ! $claude_done; then
                check_tui_health "claude" "$claude_session" "$peer_sync" "$tui_exit_behavior"
            fi
            if ! $codex_done; then
                check_tui_health "codex" "$codex_session" "$peer_sync" "$tui_exit_behavior"
            fi

            # Check timeout
            if [ "$elapsed" -ge "$review_timeout" ]; then
                warn "Review phase timeout (${review_timeout}s)"

                if ! $claude_done; then
                    interrupt_agent "claude" "$claude_session" "$peer_sync"
                    claude_done=true
                fi
                if ! $codex_done; then
                    interrupt_agent "codex" "$codex_session" "$peer_sync"
                    codex_done=true
                fi
                break
            fi

            printf "\r  Waiting... claude=%s codex=%s (%ds/%ds)  " "$claude_status" "$codex_status" "$elapsed" "$review_timeout"
            sleep "$poll_interval"
        done
        echo ""

        # Check if both have PRs after review phase (before starting next round)
        if has_pr "claude" "$peer_sync" && has_pr "codex" "$peer_sync"; then
            echo "complete" > "$peer_sync/session"
            success "Both PRs created - session complete!"
            break
        fi

        round=$((round + 1))
    done

    if [ "$round" -gt "$max_rounds" ]; then
        warn "Reached max rounds ($max_rounds)"
    fi

    echo ""
    info "=== Final Status ==="
    cmd_status
}

#------------------------------------------------------------------------------
# Command: nudge
#------------------------------------------------------------------------------

cmd_nudge() {
    local agent="$1"
    local message="${2:-Continue.}"

    [ -z "$agent" ] && die "Usage: agent-duo nudge <agent> [message]"

    local root
    root="$(get_project_root)"
    local feature
    feature="$(get_feature)"
    local session_name="duo-${feature}"

    # Determine session target
    local session
    if tmux has-session -t "$session_name" 2>/dev/null; then
        session="${session_name}:${agent}"
    elif tmux has-session -t "${session_name}-${agent}" 2>/dev/null; then
        session="${session_name}-${agent}"
    else
        die "No tmux session found for $agent"
    fi

    nudge_agent "$agent" "$session" "$message"
    success "Nudged $agent"
}

#------------------------------------------------------------------------------
# Command: interrupt
#------------------------------------------------------------------------------

cmd_interrupt() {
    local agent="$1"

    [ -z "$agent" ] && die "Usage: agent-duo interrupt <agent>"

    local root
    root="$(get_project_root)"
    local peer_sync="$root/.peer-sync"
    local feature
    feature="$(get_feature)"
    local session_name="duo-${feature}"

    # Determine session target
    local session
    if tmux has-session -t "$session_name" 2>/dev/null; then
        session="${session_name}:${agent}"
    elif tmux has-session -t "${session_name}-${agent}" 2>/dev/null; then
        session="${session_name}-${agent}"
    else
        die "No tmux session found for $agent"
    fi

    interrupt_agent "$agent" "$session" "$peer_sync"
    success "Interrupted $agent"
}

#------------------------------------------------------------------------------
# Command: help
#------------------------------------------------------------------------------

cmd_help() {
    cat << 'EOF'
Agent Duo - Coordinate two AI coding agents

USAGE
    agent-duo <command> [options]

SESSION COMMANDS
    start <feature> [options]
        Start a new session for the given feature.
        Creates worktrees, tmux sessions, and ttyd web terminals.
        Looks for task description in: <feature>.md, doc/<feature>.md,
        docs/<feature>.md, or **/<feature>.md (anywhere in project).

        Options:
          --auto-run               Start orchestrator immediately in its own terminal
          --no-ttyd                Use single tmux session instead of web terminals
          --clarify                Enable clarify phase before work starts
          --work-timeout <secs>    Work phase timeout (default: 600, with --auto-run)
          --review-timeout <secs>  Review phase timeout (default: 300, with --auto-run)
          --clarify-timeout <secs> Clarify phase timeout (default: 300, with --clarify)
          --max-rounds <n>         Maximum rounds (default: 10, with --auto-run)
          --codex-thinking <level> Codex reasoning effort: low, medium, high (default: high)

        With ttyd (default): Creates 3 web terminals (ports allocated dynamically)
          - Orchestrator: Main project root
          - Claude: Claude's worktree
          - Codex: Codex's worktree
          Port assignments are stored in .peer-sync/ports for the session.

        With --no-ttyd: Creates single tmux session with 3 windows

        With --clarify: Agents first propose approaches and questions.
          User receives email and can respond before work begins.

    run [options]
        Run the orchestrator loop (work -> review -> work...).
        Automatically manages phase transitions and timeouts.
        Not needed if using 'start --auto-run'.

        Options:
          --clarify                Enable clarify phase before work starts
          --work-timeout <secs>    Work phase timeout (default: 600)
          --review-timeout <secs>  Review phase timeout (default: 300)
          --clarify-timeout <secs> Clarify phase timeout (default: 300)
          --poll <secs>            Status poll interval (default: 10)
          --max-rounds <n>         Maximum rounds (default: 10)
          --auto-start             Auto-launch agent CLIs and send task

    stop
        Stop ttyd servers and tmux sessions, keep worktrees.

    restart [options]
        Restart a session after system restart or crash (DWIM behavior).
        - If healthy: no-op
        - If tmux sessions missing: recreates them
        - If ttyd down: restarts it (errors if port occupied by other process)
        - If agent TUIs not running: restarts them
        - If orchestration incomplete: optionally restarts orchestrator

        Options:
          --auto-run               Also restart the orchestrator loop
          --work-timeout <secs>    Work phase timeout (default: 600)
          --review-timeout <secs>  Review phase timeout (default: 300)
          --max-rounds <n>         Maximum rounds (default: 10)

    status
        Show current session state, agent statuses, and PRs.

    confirm
        Confirm the clarify phase is complete and proceed to work phase.
        Alternative to pressing Enter in the orchestrator terminal.

    pr <agent>
        Create a PR for the specified agent (claude or codex).
        Auto-commits uncommitted changes and pushes.

    cleanup [--full]
        Remove worktrees. With --full, also removes .peer-sync
        and deletes the feature branches.

    setup
        Install agent-duo to ~/.local/bin and skills to agent dirs.

    doctor [--send-email] [--send-ntfy]
        Check system configuration and diagnose common issues.
        Verifies: required tools, AI CLIs, git config, email/ntfy setup,
        skills installation, hook configuration, and PATH.

        Options:
          --send-email    Send a test email to verify email delivery
          --send-ntfy     Send a test ntfy notification

    config [key] [value]
        Get or set configuration values.
        Without arguments, shows current configuration.

        Keys:
          ntfy_topic      ntfy.sh topic name for push notifications
          ntfy_token      ntfy.sh access token (for reserved/private topics)
          ntfy_server     ntfy server URL (default: https://ntfy.sh)

        Examples:
          agent-duo config                       # Show all config
          agent-duo config ntfy_topic            # Get ntfy topic
          agent-duo config ntfy_topic myapp123   # Set ntfy topic
          agent-duo config ntfy_token tk_abc123  # Set access token

CONTROL COMMANDS
    nudge <agent> [message]
        Send a message to an agent's terminal.
        Default message: "Continue."

    interrupt <agent>
        Send Escape + Ctrl-C to interrupt an agent and mark as interrupted.

AGENT COMMANDS (used by AI agents)
    signal <agent> <status> [message]
        Signal a status change. Status values:
        clarifying, clarify-done, working, done, reviewing, review-done,
        interrupted, error, pr-created

    peer-status
        Read peer's current status (requires PEER_NAME env var).

    phase
        Read current phase (clarify, work, or review).

ENVIRONMENT VARIABLES (set in agent sessions)
    PEER_SYNC       Path to .peer-sync directory
    MY_NAME         This agent's name (claude or codex)
    PEER_NAME       Other agent's name
    PEER_WORKTREE   Path to peer's worktree
    FEATURE         Feature name

EXAMPLES
    # Recommended: start with auto-run (opens 3 web terminals, starts everything)
    agent-duo start auth --auto-run

    # With clarify phase: agents propose approaches before starting work
    agent-duo start auth --auto-run --clarify
    # Review approaches, respond to agents, then press Enter in orchestrator

    # Alternative: start manually then run orchestrator
    agent-duo start auth
    agent-duo run --auto-start

    # Use tmux instead of web terminals
    agent-duo start auth --no-ttyd
    tmux attach -t duo-auth
    # Then run: agent-duo run --auto-start

    # Recover after system restart
    agent-duo restart --auto-run

    # Nudge a stuck agent
    agent-duo nudge claude "Please continue with the implementation."

    # Check status
    agent-duo status

    # Create PR when done
    agent-duo pr claude

    # Clean up
    agent-duo cleanup --full
EOF
}

#------------------------------------------------------------------------------
# Main
#------------------------------------------------------------------------------

main() {
    local cmd="${1:-help}"
    shift || true

    case "$cmd" in
        start)       cmd_start "$@" ;;
        run)         cmd_run "$@" ;;
        stop)        cmd_stop "$@" ;;
        restart)     cmd_restart "$@" ;;
        status)      cmd_status "$@" ;;
        confirm)     cmd_confirm "$@" ;;
        pr)          cmd_pr "$@" ;;
        cleanup)     cmd_cleanup "$@" ;;
        setup)       cmd_setup "$@" ;;
        doctor)      cmd_doctor "$@" ;;
        config)      cmd_config "$@" ;;
        nudge)       cmd_nudge "$@" ;;
        interrupt)   cmd_interrupt "$@" ;;
        signal)      cmd_signal "$@" ;;
        peer-status) cmd_peer_status "$@" ;;
        phase)       cmd_phase "$@" ;;
        help|--help|-h) cmd_help ;;
        *)           die "Unknown command: $cmd (try 'agent-duo help')" ;;
    esac
}

main "$@"
